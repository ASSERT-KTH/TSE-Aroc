Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/smartbugs-21-7-13/reentrancy31/spank_chain_payment.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.23;"
ContractDefinition "Token"
   Gas costs: 0
   Source: "contract Token {\n     /* This is a slight change to the ERC20 base standard.\n     function totalSupply() constant returns (uint256 supply);\n     is replaced with:\n     uint256 public totalSupply;\n     This automatically creates a getter function for the totalSupply.\n     This is moved to the base contract since public getter functions are not\n     currently recognised as an implementation of the matching abstract\n     function by the compiler.\n     */\n     /// total amount of tokens\n     uint256 public totalSupply;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function balanceOf(address _owner) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _to, uint256 _value) public returns (bool success);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function approve(address _spender, uint256 _value) public returns (bool success);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint256 public totalSupply"
    ElementaryTypeName uint256
       Source: "uint256"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance);"
    ParameterList
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success);"
    ParameterList
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining);"
    ParameterList
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "ECTools"
   Source: "library ECTools {\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n         require(_hashedMsg != 0x00);\n\n         // need this for test RPC\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function parseInt16Char(string _char) public pure returns (uint) {\n         bytes memory bresult = bytes(_char);\n         // bool decimals = false;\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function uintToBytes32(uint _uint) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }\n\n     // @dev Converts a uint in a string\n     function uintToString(uint _uint) public pure returns (string str) {\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }\n\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }\n }"
  FunctionDefinition "recoverSigner" - public
     Source: "function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n         require(_hashedMsg != 0x00);\n\n         // need this for test RPC\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _hashedMsg, string _sig)"
      VariableDeclaration "_hashedMsg"
         Type: bytes32
         Source: "bytes32 _hashedMsg"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_sig"
         Type: string memory
         Source: "string _sig"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\n         require(_hashedMsg != 0x00);\n\n         // need this for test RPC\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_hashedMsg != 0x00)"
        FunctionCall
           Type: tuple()
           Source: "require(_hashedMsg != 0x00)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_hashedMsg != 0x00"
            Identifier _hashedMsg
               Type: bytes32
               Source: "_hashedMsg"
            Literal, token: [no token] value: 0x00
               Type: int_const 0
               Source: "0x00"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\""
        VariableDeclaration "prefix"
           Type: bytes memory
           Source: "bytes memory prefix"
          ElementaryTypeName bytes
             Source: "bytes"
        Literal, token: [no token] value: Ethereum Signed Message:
32
           Type: literal_string "Ethereum Signed Message:
32"
           Source: "\"\\x19Ethereum Signed Message:\\n32\""
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg))"
        VariableDeclaration "prefixedHash"
           Type: bytes32
           Source: "bytes32 prefixedHash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(abi.encodePacked(prefix, _hashedMsg))"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(prefix, _hashedMsg)"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier prefix
               Type: bytes memory
               Source: "prefix"
            Identifier _hashedMsg
               Type: bytes32
               Source: "_hashedMsg"
      IfStatement
         Source: "if (bytes(_sig).length != 132) {\n             return 0x0;\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "bytes(_sig).length != 132"
          MemberAccess to member length
             Type: uint256
             Source: "bytes(_sig).length"
            FunctionCall
               Type: bytes memory
               Source: "bytes(_sig)"
              ElementaryTypeNameExpression bytes
                 Type: type(bytes storage pointer)
                 Source: "bytes"
              Identifier _sig
                 Type: string memory
                 Source: "_sig"
          Literal, token: [no token] value: 132
             Type: int_const 132
             Source: "132"
        Block
           Source: "{\n             return 0x0;\n         }"
          Return
             Gas costs: 0
             Source: "return 0x0"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 r"
        VariableDeclaration "r"
           Type: bytes32
           Source: "bytes32 r"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes32 s"
        VariableDeclaration "s"
           Type: bytes32
           Source: "bytes32 s"
          ElementaryTypeName bytes32
             Source: "bytes32"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint8 v"
        VariableDeclaration "v"
           Type: uint8
           Source: "uint8 v"
          ElementaryTypeName uint8
             Source: "uint8"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory sig = hexstrToBytes(substring(_sig, 2, 132))"
        VariableDeclaration "sig"
           Type: bytes memory
           Source: "bytes memory sig"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "hexstrToBytes(substring(_sig, 2, 132))"
          Identifier hexstrToBytes
             Type: function (string memory) pure returns (bytes memory)
             Source: "hexstrToBytes"
          FunctionCall
             Type: string memory
             Source: "substring(_sig, 2, 132)"
            Identifier substring
               Type: function (string memory,uint256,uint256) pure returns (string memory)
               Source: "substring"
            Identifier _sig
               Type: string memory
               Source: "_sig"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
            Literal, token: [no token] value: 132
               Type: int_const 132
               Source: "132"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if"
      IfStatement
         Source: "if (v < 27) {\n             v += 27;\n         }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "v < 27"
          Identifier v
             Type: uint8
             Source: "v"
          Literal, token: [no token] value: 27
             Type: int_const 27
             Source: "27"
        Block
           Source: "{\n             v += 27;\n         }"
          ExpressionStatement
             Gas costs: 0
             Source: "v += 27"
            Assignment using operator +=
               Type: uint8
               Source: "v += 27"
              Identifier v
                 Type: uint8
                 Source: "v"
              Literal, token: [no token] value: 27
                 Type: int_const 27
                 Source: "27"
      IfStatement
         Source: "if (v < 27 || v > 28) {\n             return 0x0;\n         }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 0
           Source: "v < 27 || v > 28"
          BinaryOperation using operator <
             Type: bool
             Source: "v < 27"
            Identifier v
               Type: uint8
               Source: "v"
            Literal, token: [no token] value: 27
               Type: int_const 27
               Source: "27"
          BinaryOperation using operator >
             Type: bool
             Source: "v > 28"
            Identifier v
               Type: uint8
               Source: "v"
            Literal, token: [no token] value: 28
               Type: int_const 28
               Source: "28"
        Block
           Source: "{\n             return 0x0;\n         }"
          Return
             Gas costs: 0
             Source: "return 0x0"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      Return
         Gas costs: 0
         Source: "return ecrecover(prefixedHash, v, r, s)"
        FunctionCall
           Type: address
           Source: "ecrecover(prefixedHash, v, r, s)"
          Identifier ecrecover
             Type: function (bytes32,uint8,bytes32,bytes32) pure returns (address)
             Source: "ecrecover"
          Identifier prefixedHash
             Type: bytes32
             Source: "prefixedHash"
          Identifier v
             Type: uint8
             Source: "v"
          Identifier r
             Type: bytes32
             Source: "r"
          Identifier s
             Type: bytes32
             Source: "s"
  FunctionDefinition "isSignedBy" - public
     Source: "function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _hashedMsg, string _sig, address _addr)"
      VariableDeclaration "_hashedMsg"
         Type: bytes32
         Source: "bytes32 _hashedMsg"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_sig"
         Type: string memory
         Source: "string _sig"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_addr"
         Type: address
         Source: "address _addr"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_addr != 0x0)"
        FunctionCall
           Type: tuple()
           Source: "require(_addr != 0x0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_addr != 0x0"
            Identifier _addr
               Type: address
               Source: "_addr"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
      Return
         Gas costs: 0
         Source: "return _addr == recoverSigner(_hashedMsg, _sig)"
        BinaryOperation using operator ==
           Type: bool
           Source: "_addr == recoverSigner(_hashedMsg, _sig)"
          Identifier _addr
             Type: address
             Source: "_addr"
          FunctionCall
             Type: address
             Source: "recoverSigner(_hashedMsg, _sig)"
            Identifier recoverSigner
               Type: function (bytes32,string memory) pure returns (address)
               Source: "recoverSigner"
            Identifier _hashedMsg
               Type: bytes32
               Source: "_hashedMsg"
            Identifier _sig
               Type: string memory
               Source: "_sig"
  FunctionDefinition "hexstrToBytes" - public
     Source: "function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(string _hexstr)"
      VariableDeclaration "_hexstr"
         Type: string memory
         Source: "string _hexstr"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes)"
      VariableDeclaration ""
         Type: bytes memory
         Source: "bytes"
        ElementaryTypeName bytes
           Source: "bytes"
    Block
       Source: "{\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint len = bytes(_hexstr).length"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "bytes(_hexstr).length"
          FunctionCall
             Type: bytes memory
             Source: "bytes(_hexstr)"
            ElementaryTypeNameExpression bytes
               Type: type(bytes storage pointer)
               Source: "bytes"
            Identifier _hexstr
               Type: string memory
               Source: "_hexstr"
      ExpressionStatement
         Gas costs: 0
         Source: "require(len % 2 == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(len % 2 == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "len % 2 == 0"
            BinaryOperation using operator %
               Type: uint256
               Source: "len % 2"
              Identifier len
                 Type: uint256
                 Source: "len"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory bstr = bytes(new string(len / 2))"
        VariableDeclaration "bstr"
           Type: bytes memory
           Source: "bytes memory bstr"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(new string(len / 2))"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          FunctionCall
             Type: string memory
             Source: "new string(len / 2)"
            NewExpression
               Type: function (uint256) pure returns (string memory)
               Source: "new string"
              ElementaryTypeName string
                 Source: "string"
            BinaryOperation using operator /
               Type: uint256
               Source: "len / 2"
              Identifier len
                 Type: uint256
                 Source: "len"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint k = 0"
        VariableDeclaration "k"
           Type: uint256
           Source: "uint k"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "string memory s"
        VariableDeclaration "s"
           Type: string memory
           Source: "string memory s"
          ElementaryTypeName string
             Source: "string"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "string memory r"
        VariableDeclaration "r"
           Type: string memory
           Source: "string memory r"
          ElementaryTypeName string
             Source: "string"
      ForStatement
         Source: "for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = 0"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < len"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier len
             Type: uint256
             Source: "len"
        ExpressionStatement
           Gas costs: 0
           Source: "i += 2"
          Assignment using operator +=
             Type: uint256
             Source: "i += 2"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
        Block
           Source: "{\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }"
          ExpressionStatement
             Gas costs: 0
             Source: "s = substring(_hexstr, i, i + 1)"
            Assignment using operator =
               Type: string memory
               Source: "s = substring(_hexstr, i, i + 1)"
              Identifier s
                 Type: string memory
                 Source: "s"
              FunctionCall
                 Type: string memory
                 Source: "substring(_hexstr, i, i + 1)"
                Identifier substring
                   Type: function (string memory,uint256,uint256) pure returns (string memory)
                   Source: "substring"
                Identifier _hexstr
                   Type: string memory
                   Source: "_hexstr"
                Identifier i
                   Type: uint256
                   Source: "i"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "i + 1"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
          ExpressionStatement
             Gas costs: 0
             Source: "r = substring(_hexstr, i + 1, i + 2)"
            Assignment using operator =
               Type: string memory
               Source: "r = substring(_hexstr, i + 1, i + 2)"
              Identifier r
                 Type: string memory
                 Source: "r"
              FunctionCall
                 Type: string memory
                 Source: "substring(_hexstr, i + 1, i + 2)"
                Identifier substring
                   Type: function (string memory,uint256,uint256) pure returns (string memory)
                   Source: "substring"
                Identifier _hexstr
                   Type: string memory
                   Source: "_hexstr"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "i + 1"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "i + 2"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint p = parseInt16Char(s) * 16 + parseInt16Char(r)"
            VariableDeclaration "p"
               Type: uint256
               Source: "uint p"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator +
               Type: uint256
               Source: "parseInt16Char(s) * 16 + parseInt16Char(r)"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "parseInt16Char(s) * 16"
                FunctionCall
                   Type: uint256
                   Source: "parseInt16Char(s)"
                  Identifier parseInt16Char
                     Type: function (string memory) pure returns (uint256)
                     Source: "parseInt16Char"
                  Identifier s
                     Type: string memory
                     Source: "s"
                Literal, token: [no token] value: 16
                   Type: int_const 16
                   Source: "16"
              FunctionCall
                 Type: uint256
                 Source: "parseInt16Char(r)"
                Identifier parseInt16Char
                   Type: function (string memory) pure returns (uint256)
                   Source: "parseInt16Char"
                Identifier r
                   Type: string memory
                   Source: "r"
          ExpressionStatement
             Gas costs: 0
             Source: "bstr[k++] = uintToBytes32(p)[31]"
            Assignment using operator =
               Type: bytes1
               Source: "bstr[k++] = uintToBytes32(p)[31]"
              IndexAccess
                 Type: bytes1
                 Source: "bstr[k++]"
                Identifier bstr
                   Type: bytes memory
                   Source: "bstr"
                UnaryOperation (postfix) ++
                   Type: uint256
                   Source: "k++"
                  Identifier k
                     Type: uint256
                     Source: "k"
              IndexAccess
                 Type: bytes1
                 Source: "uintToBytes32(p)[31]"
                FunctionCall
                   Type: bytes memory
                   Source: "uintToBytes32(p)"
                  Identifier uintToBytes32
                     Type: function (uint256) pure returns (bytes memory)
                     Source: "uintToBytes32"
                  Identifier p
                     Type: uint256
                     Source: "p"
                Literal, token: [no token] value: 31
                   Type: int_const 31
                   Source: "31"
      Return
         Gas costs: 0
         Source: "return bstr"
        Identifier bstr
           Type: bytes memory
           Source: "bstr"
  FunctionDefinition "parseInt16Char" - public
     Source: "function parseInt16Char(string _char) public pure returns (uint) {\n         bytes memory bresult = bytes(_char);\n         // bool decimals = false;\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }"
    ParameterList
       Gas costs: 0
       Source: "(string _char)"
      VariableDeclaration "_char"
         Type: string memory
         Source: "string _char"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         bytes memory bresult = bytes(_char);\n         // bool decimals = false;\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory bresult = bytes(_char)"
        VariableDeclaration "bresult"
           Type: bytes memory
           Source: "bytes memory bresult"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_char)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _char
             Type: string memory
             Source: "_char"
      IfStatement
         Source: "if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "(bresult[0] >= 48) && (bresult[0] <= 57)"
          TupleExpression
             Type: bool
             Source: "(bresult[0] >= 48)"
            BinaryOperation using operator >=
               Type: bool
               Source: "bresult[0] >= 48"
              IndexAccess
                 Type: bytes1
                 Source: "bresult[0]"
                Identifier bresult
                   Type: bytes memory
                   Source: "bresult"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: 48
                 Type: int_const 48
                 Source: "48"
          TupleExpression
             Type: bool
             Source: "(bresult[0] <= 57)"
            BinaryOperation using operator <=
               Type: bool
               Source: "bresult[0] <= 57"
              IndexAccess
                 Type: bytes1
                 Source: "bresult[0]"
                Identifier bresult
                   Type: bytes memory
                   Source: "bresult"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: 57
                 Type: int_const 57
                 Source: "57"
        Block
           Source: "{\n             return uint(bresult[0]) - 48;\n         }"
          Return
             Gas costs: 0
             Source: "return uint(bresult[0]) - 48"
            BinaryOperation using operator -
               Type: uint256
               Source: "uint(bresult[0]) - 48"
              FunctionCall
                 Type: uint256
                 Source: "uint(bresult[0])"
                ElementaryTypeNameExpression uint
                   Type: type(uint256)
                   Source: "uint"
                IndexAccess
                   Type: bytes1
                   Source: "bresult[0]"
                  Identifier bresult
                     Type: bytes memory
                     Source: "bresult"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Literal, token: [no token] value: 48
                 Type: int_const 48
                 Source: "48"
        IfStatement
           Source: "if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }"
          BinaryOperation using operator &&
             Type: bool
             Gas costs: 0
             Source: "(bresult[0] >= 65) && (bresult[0] <= 70)"
            TupleExpression
               Type: bool
               Source: "(bresult[0] >= 65)"
              BinaryOperation using operator >=
                 Type: bool
                 Source: "bresult[0] >= 65"
                IndexAccess
                   Type: bytes1
                   Source: "bresult[0]"
                  Identifier bresult
                     Type: bytes memory
                     Source: "bresult"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Literal, token: [no token] value: 65
                   Type: int_const 65
                   Source: "65"
            TupleExpression
               Type: bool
               Source: "(bresult[0] <= 70)"
              BinaryOperation using operator <=
                 Type: bool
                 Source: "bresult[0] <= 70"
                IndexAccess
                   Type: bytes1
                   Source: "bresult[0]"
                  Identifier bresult
                     Type: bytes memory
                     Source: "bresult"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Literal, token: [no token] value: 70
                   Type: int_const 70
                   Source: "70"
          Block
             Source: "{\n             return uint(bresult[0]) - 55;\n         }"
            Return
               Gas costs: 0
               Source: "return uint(bresult[0]) - 55"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "uint(bresult[0]) - 55"
                FunctionCall
                   Type: uint256
                   Source: "uint(bresult[0])"
                  ElementaryTypeNameExpression uint
                     Type: type(uint256)
                     Source: "uint"
                  IndexAccess
                     Type: bytes1
                     Source: "bresult[0]"
                    Identifier bresult
                       Type: bytes memory
                       Source: "bresult"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                Literal, token: [no token] value: 55
                   Type: int_const 55
                   Source: "55"
          IfStatement
             Source: "if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }"
            BinaryOperation using operator &&
               Type: bool
               Gas costs: 0
               Source: "(bresult[0] >= 97) && (bresult[0] <= 102)"
              TupleExpression
                 Type: bool
                 Source: "(bresult[0] >= 97)"
                BinaryOperation using operator >=
                   Type: bool
                   Source: "bresult[0] >= 97"
                  IndexAccess
                     Type: bytes1
                     Source: "bresult[0]"
                    Identifier bresult
                       Type: bytes memory
                       Source: "bresult"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  Literal, token: [no token] value: 97
                     Type: int_const 97
                     Source: "97"
              TupleExpression
                 Type: bool
                 Source: "(bresult[0] <= 102)"
                BinaryOperation using operator <=
                   Type: bool
                   Source: "bresult[0] <= 102"
                  IndexAccess
                     Type: bytes1
                     Source: "bresult[0]"
                    Identifier bresult
                       Type: bytes memory
                       Source: "bresult"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  Literal, token: [no token] value: 102
                     Type: int_const 102
                     Source: "102"
            Block
               Source: "{\n             return uint(bresult[0]) - 87;\n         }"
              Return
                 Gas costs: 0
                 Source: "return uint(bresult[0]) - 87"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "uint(bresult[0]) - 87"
                  FunctionCall
                     Type: uint256
                     Source: "uint(bresult[0])"
                    ElementaryTypeNameExpression uint
                       Type: type(uint256)
                       Source: "uint"
                    IndexAccess
                       Type: bytes1
                       Source: "bresult[0]"
                      Identifier bresult
                         Type: bytes memory
                         Source: "bresult"
                      Literal, token: [no token] value: 0
                         Type: int_const 0
                         Source: "0"
                  Literal, token: [no token] value: 87
                     Type: int_const 87
                     Source: "87"
            Block
               Source: "{\n             revert();\n         }"
              ExpressionStatement
                 Gas costs: 0
                 Source: "revert()"
                FunctionCall
                   Type: tuple()
                   Source: "revert()"
                  Identifier revert
                     Type: function () pure
                     Source: "revert"
  FunctionDefinition "uintToBytes32" - public
     Source: "function uintToBytes32(uint _uint) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint _uint)"
      VariableDeclaration "_uint"
         Type: uint256
         Source: "uint _uint"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bytes b)"
      VariableDeclaration "b"
         Type: bytes memory
         Source: "bytes b"
        ElementaryTypeName bytes
           Source: "bytes"
    Block
       Source: "{\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "b = new bytes(32)"
        Assignment using operator =
           Type: bytes memory
           Source: "b = new bytes(32)"
          Identifier b
             Type: bytes memory
             Source: "b"
          FunctionCall
             Type: bytes memory
             Source: "new bytes(32)"
            NewExpression
               Type: function (uint256) pure returns (bytes memory)
               Source: "new bytes"
              ElementaryTypeName bytes
                 Source: "bytes"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
      InlineAssembly
         Gas costs: 0
         Source: "assembly {mstore(add(b, 32), _uint)}\n     }"
  FunctionDefinition "toEthereumSignedMessage" - public
     Source: "function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }"
    ParameterList
       Gas costs: 0
       Source: "(string _msg)"
      VariableDeclaration "_msg"
         Type: string memory
         Source: "string _msg"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: "(bytes32)"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
    Block
       Source: "{\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint len = bytes(_msg).length"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member length
           Type: uint256
           Source: "bytes(_msg).length"
          FunctionCall
             Type: bytes memory
             Source: "bytes(_msg)"
            ElementaryTypeNameExpression bytes
               Type: type(bytes storage pointer)
               Source: "bytes"
            Identifier _msg
               Type: string memory
               Source: "_msg"
      ExpressionStatement
         Gas costs: 0
         Source: "require(len > 0)"
        FunctionCall
           Type: tuple()
           Source: "require(len > 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "len > 0"
            Identifier len
               Type: uint256
               Source: "len"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\""
        VariableDeclaration "prefix"
           Type: bytes memory
           Source: "bytes memory prefix"
          ElementaryTypeName bytes
             Source: "bytes"
        Literal, token: [no token] value: Ethereum Signed Message:

           Type: literal_string "Ethereum Signed Message:
"
           Source: "\"\\x19Ethereum Signed Message:\\n\""
      Return
         Gas costs: 0
         Source: "return keccak256(abi.encodePacked(prefix, uintToString(len), _msg))"
        FunctionCall
           Type: bytes32
           Source: "keccak256(abi.encodePacked(prefix, uintToString(len), _msg))"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(prefix, uintToString(len), _msg)"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier prefix
               Type: bytes memory
               Source: "prefix"
            FunctionCall
               Type: string memory
               Source: "uintToString(len)"
              Identifier uintToString
                 Type: function (uint256) pure returns (string memory)
                 Source: "uintToString"
              Identifier len
                 Type: uint256
                 Source: "len"
            Identifier _msg
               Type: string memory
               Source: "_msg"
  FunctionDefinition "uintToString" - public
     Source: "function uintToString(uint _uint) public pure returns (string str) {\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint _uint)"
      VariableDeclaration "_uint"
         Type: uint256
         Source: "uint _uint"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(string str)"
      VariableDeclaration "str"
         Type: string memory
         Source: "string str"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint len = 0"
        VariableDeclaration "len"
           Type: uint256
           Source: "uint len"
          ElementaryTypeName uint
             Source: "uint"
        Literal, token: [no token] value: 0
           Type: int_const 0
           Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint m = _uint + 0"
        VariableDeclaration "m"
           Type: uint256
           Source: "uint m"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "_uint + 0"
          Identifier _uint
             Type: uint256
             Source: "_uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      WhileStatement
         Source: "while (m != 0) {\n             len++;\n             m /= 10;\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "m != 0"
          Identifier m
             Type: uint256
             Source: "m"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             len++;\n             m /= 10;\n         }"
          ExpressionStatement
             Gas costs: 0
             Source: "len++"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "len++"
              Identifier len
                 Type: uint256
                 Source: "len"
          ExpressionStatement
             Gas costs: 0
             Source: "m /= 10"
            Assignment using operator /=
               Type: uint256
               Source: "m /= 10"
              Identifier m
                 Type: uint256
                 Source: "m"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory b = new bytes(len)"
        VariableDeclaration "b"
           Type: bytes memory
           Source: "bytes memory b"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "new bytes(len)"
          NewExpression
             Type: function (uint256) pure returns (bytes memory)
             Source: "new bytes"
            ElementaryTypeName bytes
               Source: "bytes"
          Identifier len
             Type: uint256
             Source: "len"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint i = len - 1"
        VariableDeclaration "i"
           Type: uint256
           Source: "uint i"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "len - 1"
          Identifier len
             Type: uint256
             Source: "len"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      WhileStatement
         Source: "while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 0
           Source: "_uint != 0"
          Identifier _uint
             Type: uint256
             Source: "_uint"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }"
          VariableDeclarationStatement
             Gas costs: 0
             Source: "uint remainder = _uint % 10"
            VariableDeclaration "remainder"
               Type: uint256
               Source: "uint remainder"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator %
               Type: uint256
               Source: "_uint % 10"
              Identifier _uint
                 Type: uint256
                 Source: "_uint"
              Literal, token: [no token] value: 10
                 Type: int_const 10
                 Source: "10"
          ExpressionStatement
             Gas costs: 0
             Source: "_uint = _uint / 10"
            Assignment using operator =
               Type: uint256
               Source: "_uint = _uint / 10"
              Identifier _uint
                 Type: uint256
                 Source: "_uint"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "_uint / 10"
                Identifier _uint
                   Type: uint256
                   Source: "_uint"
                Literal, token: [no token] value: 10
                   Type: int_const 10
                   Source: "10"
          ExpressionStatement
             Gas costs: 0
             Source: "b[i--] = byte(48 + remainder)"
            Assignment using operator =
               Type: bytes1
               Source: "b[i--] = byte(48 + remainder)"
              IndexAccess
                 Type: bytes1
                 Source: "b[i--]"
                Identifier b
                   Type: bytes memory
                   Source: "b"
                UnaryOperation (postfix) --
                   Type: uint256
                   Source: "i--"
                  Identifier i
                     Type: uint256
                     Source: "i"
              FunctionCall
                 Type: bytes1
                 Source: "byte(48 + remainder)"
                ElementaryTypeNameExpression byte
                   Type: type(bytes1)
                   Source: "byte"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "48 + remainder"
                  Literal, token: [no token] value: 48
                     Type: int_const 48
                     Source: "48"
                  Identifier remainder
                     Type: uint256
                     Source: "remainder"
      ExpressionStatement
         Gas costs: 0
         Source: "str = string(b)"
        Assignment using operator =
           Type: string memory
           Source: "str = string(b)"
          Identifier str
             Type: string memory
             Source: "str"
          FunctionCall
             Type: string memory
             Source: "string(b)"
            ElementaryTypeNameExpression string
               Type: type(string storage pointer)
               Source: "string"
            Identifier b
               Type: bytes memory
               Source: "b"
  FunctionDefinition "substring" - public
     Source: "function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(string _str, uint _startIndex, uint _endIndex)"
      VariableDeclaration "_str"
         Type: string memory
         Source: "string _str"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_startIndex"
         Type: uint256
         Source: "uint _startIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "_endIndex"
         Type: uint256
         Source: "uint _endIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(string)"
      VariableDeclaration ""
         Type: string memory
         Source: "string"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory strBytes = bytes(_str)"
        VariableDeclaration "strBytes"
           Type: bytes memory
           Source: "bytes memory strBytes"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "bytes(_str)"
          ElementaryTypeNameExpression bytes
             Type: type(bytes storage pointer)
             Source: "bytes"
          Identifier _str
             Type: string memory
             Source: "_str"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_startIndex <= _endIndex)"
        FunctionCall
           Type: tuple()
           Source: "require(_startIndex <= _endIndex)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_startIndex <= _endIndex"
            Identifier _startIndex
               Type: uint256
               Source: "_startIndex"
            Identifier _endIndex
               Type: uint256
               Source: "_endIndex"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_startIndex >= 0)"
        FunctionCall
           Type: tuple()
           Source: "require(_startIndex >= 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "_startIndex >= 0"
            Identifier _startIndex
               Type: uint256
               Source: "_startIndex"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_endIndex <= strBytes.length)"
        FunctionCall
           Type: tuple()
           Source: "require(_endIndex <= strBytes.length)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_endIndex <= strBytes.length"
            Identifier _endIndex
               Type: uint256
               Source: "_endIndex"
            MemberAccess to member length
               Type: uint256
               Source: "strBytes.length"
              Identifier strBytes
                 Type: bytes memory
                 Source: "strBytes"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "bytes memory result = new bytes(_endIndex - _startIndex)"
        VariableDeclaration "result"
           Type: bytes memory
           Source: "bytes memory result"
          ElementaryTypeName bytes
             Source: "bytes"
        FunctionCall
           Type: bytes memory
           Source: "new bytes(_endIndex - _startIndex)"
          NewExpression
             Type: function (uint256) pure returns (bytes memory)
             Source: "new bytes"
            ElementaryTypeName bytes
               Source: "bytes"
          BinaryOperation using operator -
             Type: uint256
             Source: "_endIndex - _startIndex"
            Identifier _endIndex
               Type: uint256
               Source: "_endIndex"
            Identifier _startIndex
               Type: uint256
               Source: "_startIndex"
      ForStatement
         Source: "for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }"
        VariableDeclarationStatement
           Gas costs: 0
           Source: "uint i = _startIndex"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint i"
            ElementaryTypeName uint
               Source: "uint"
          Identifier _startIndex
             Type: uint256
             Source: "_startIndex"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 0
           Source: "i < _endIndex"
          Identifier i
             Type: uint256
             Source: "i"
          Identifier _endIndex
             Type: uint256
             Source: "_endIndex"
        ExpressionStatement
           Gas costs: 0
           Source: "i++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "i++"
            Identifier i
               Type: uint256
               Source: "i"
        Block
           Source: "{\n             result[i - _startIndex] = strBytes[i];\n         }"
          ExpressionStatement
             Gas costs: 0
             Source: "result[i - _startIndex] = strBytes[i]"
            Assignment using operator =
               Type: bytes1
               Source: "result[i - _startIndex] = strBytes[i]"
              IndexAccess
                 Type: bytes1
                 Source: "result[i - _startIndex]"
                Identifier result
                   Type: bytes memory
                   Source: "result"
                BinaryOperation using operator -
                   Type: uint256
                   Source: "i - _startIndex"
                  Identifier i
                     Type: uint256
                     Source: "i"
                  Identifier _startIndex
                     Type: uint256
                     Source: "_startIndex"
              IndexAccess
                 Type: bytes1
                 Source: "strBytes[i]"
                Identifier strBytes
                   Type: bytes memory
                   Source: "strBytes"
                Identifier i
                   Type: uint256
                   Source: "i"
      Return
         Gas costs: 0
         Source: "return string(result)"
        FunctionCall
           Type: string memory
           Source: "string(result)"
          ElementaryTypeNameExpression string
             Type: type(string storage pointer)
             Source: "string"
          Identifier result
             Type: bytes memory
             Source: "result"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is Token {\n\n     function transfer(address _to, uint256 _value) public returns (bool success) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }\n\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n         //same as above. Replace this line with the following if you want to protect against wrapping uints.\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }\n\n     function balanceOf(address _owner) public constant returns (uint256 balance) {\n         return balances[_owner];\n     }\n\n     function approve(address _spender, uint256 _value) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }\n\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n       return allowed[_owner][_spender];\n     }\n\n     mapping (address => uint256) balances;\n     mapping (address => mapping (address => uint256)) allowed;\n }"
  InheritanceSpecifier
     Gas costs: 0
     Source: "Token"
    UserDefinedTypeName "Token"
       Source: "Token"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) public returns (bool success) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      EmitStatement
         Gas costs: 0
         Source: "emit Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n         //same as above. Replace this line with the following if you want to protect against wrapping uints.\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         //same as above. Replace this line with the following if you want to protect against wrapping uints.\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] += _value"
        Assignment using operator +=
           Type: uint256
           Source: "balances[_to] += _value"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      EmitStatement
         Gas costs: 0
         Source: "emit Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) public constant returns (uint256 balance) {\n         return balances[_owner];\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n         return balances[_owner];\n     }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      EmitStatement
         Gas costs: 0
         Source: "emit Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n       return allowed[_owner][_spender];\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n       return allowed[_owner][_spender];\n     }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
ContractDefinition "HumanStandardToken"
   Source: "contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     /*\n     NOTE:\n     The following variables are OPTIONAL vanities. One does not have to include them.\n     They allow one to customise the token contract & in no way influences the core functionality.\n     Some wallets/interfaces might not even bother to look at this information.\n     */\n     string public name;                   //fancy name: eg Simon Bucks\n     uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public symbol;                 //An identifier: eg SBX\n     string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         ) public {\n         balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n         totalSupply = _initialAmount;                        // Update total supply\n         name = _tokenName;                                   // Set the name for display purposes\n         decimals = _decimalUnits;                            // Amount of decimals for display purposes\n         symbol = _tokenSymbol;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }\n }"
  InheritanceSpecifier
     Gas costs: 0
     Source: "StandardToken"
    UserDefinedTypeName "StandardToken"
       Source: "StandardToken"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: 0
     Source: "string public name"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: 0
     Source: "uint8 public decimals"
    ElementaryTypeName uint8
       Source: "uint8"
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: 0
     Source: "string public symbol"
    ElementaryTypeName string
       Source: "string"
  VariableDeclaration "version"
     Type: string storage ref
     Gas costs: 0
     Source: "string public version = 'H0.1'"
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: H0.1
       Type: literal_string "H0.1"
       Source: "'H0.1'"
  FunctionDefinition "" - public
     Source: "constructor(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         ) public {\n         balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n         totalSupply = _initialAmount;                        // Update total supply\n         name = _tokenName;                                   // Set the name for display purposes\n         decimals = _decimalUnits;                            // Amount of decimals for display purposes\n         symbol = _tokenSymbol;                               // Set the symbol for display purposes\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         )"
      VariableDeclaration "_initialAmount"
         Type: uint256
         Source: "uint256 _initialAmount"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_tokenName"
         Type: string memory
         Source: "string _tokenName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_decimalUnits"
         Type: uint8
         Source: "uint8 _decimalUnits"
        ElementaryTypeName uint8
           Source: "uint8"
      VariableDeclaration "_tokenSymbol"
         Type: string memory
         Source: "string _tokenSymbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n         totalSupply = _initialAmount;                        // Update total supply\n         name = _tokenName;                                   // Set the name for display purposes\n         decimals = _decimalUnits;                            // Amount of decimals for display purposes\n         symbol = _tokenSymbol;                               // Set the symbol for display purposes\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = _initialAmount"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "totalSupply = _initialAmount"
        Assignment using operator =
           Type: uint256
           Source: "totalSupply = _initialAmount"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _initialAmount
             Type: uint256
             Source: "_initialAmount"
      ExpressionStatement
         Gas costs: 0
         Source: "name = _tokenName"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _tokenName"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _tokenName
             Type: string memory
             Source: "_tokenName"
      ExpressionStatement
         Gas costs: 0
         Source: "decimals = _decimalUnits"
        Assignment using operator =
           Type: uint8
           Source: "decimals = _decimalUnits"
          Identifier decimals
             Type: uint8
             Source: "decimals"
          Identifier _decimalUnits
             Type: uint8
             Source: "_decimalUnits"
      ExpressionStatement
         Gas costs: 0
         Source: "symbol = _tokenSymbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _tokenSymbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _tokenSymbol
             Type: string memory
             Source: "_tokenSymbol"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      EmitStatement
         Gas costs: 0
         Source: "emit Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
        FunctionCall
           Type: tuple()
           Source: "require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          FunctionCall
             Type: bool
             Source: "_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)"
            MemberAccess to member call
               Type: function () payable returns (bool)
               Source: "_spender.call"
              Identifier _spender
                 Type: address
                 Source: "_spender"
            FunctionCall
               Type: bytes4
               Source: "bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\")))"
              ElementaryTypeNameExpression bytes4
                 Type: type(bytes4)
                 Source: "bytes4"
              FunctionCall
                 Type: bytes32
                 Source: "bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))"
                ElementaryTypeNameExpression bytes32
                   Type: type(bytes32)
                   Source: "bytes32"
                FunctionCall
                   Type: bytes32
                   Source: "keccak256(\"receiveApproval(address,uint256,address,bytes)\")"
                  Identifier keccak256
                     Type: function () pure returns (bytes32)
                     Source: "keccak256"
                  Literal, token: [no token] value: receiveApproval(address,uint256,address,bytes)
                     Type: literal_string "receiveApproval(address,uint256,address,bytes)"
                     Source: "\"receiveApproval(address,uint256,address,bytes)\""
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
            Identifier this
               Type: contract HumanStandardToken
               Source: "this"
            Identifier _extraData
               Type: bytes memory
               Source: "_extraData"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
ContractDefinition "LedgerChannel"
   Source: "contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public numChannels = 0;\n\n     event DidLCOpen (\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     );\n\n     event DidLCClose (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidVCInit (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     event DidVCSettle (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     );\n\n     event DidVCClose(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] partyAddresses; // 0: partyA 1: partyI\n         uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] initialDeposit; // 0: eth 1: tokens\n         uint256 sequence;\n         uint256 confirmTime;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 updateLCtimeout; // when update LC times out\n         bool isOpen; // true when both parties have joined\n         bool isUpdateLCSettling;\n         uint256 numOpenVC;\n         HumanStandardToken token;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool isClose;\n         bool isInSettlementState;\n         uint256 sequence;\n         address challenger; // Initiator of challenge\n         uint256 updateVCtimeout; // when update VC times out\n         // channel state\n         address partyA; // VC participant A\n         address partyB; // VC participant B\n         address partyI; // LC hub\n         uint256[2] ethBalances;\n         uint256[2] erc20Balances;\n         uint256[2] bond;\n         HumanStandardToken token;\n     }\n\n     mapping(bytes32 => VirtualChannel) public virtualChannels;\n     mapping(bytes32 => Channel) public Channels;\n\n     function createChannel(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _lcID) public {\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_lcID];\n     }\n\n     function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n         // require the channel is not open yet\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n         // no longer allow joining functions to be called\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }\n\n\n     // additive updates of monetary state\n     // TODO check this for attack vectors\n     function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function consensusCloseChannel(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }\n\n     // Byzantine functions\n\n     function updateLCstate(\n         bytes32 _lcID,\n         uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]); // do same as vc sequence check\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         // update LC state\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function initVCstate(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n         // partyB is now Ingrid\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n         // Check the oldState is in the root hash\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA; // VC participant A\n         virtualChannels[_vcID].partyB = _partyB; // VC participant B\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function settleVC(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n         // channel state\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }\n\n     function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_lcID].numOpenVC--;\n         // close vc flags\n         virtualChannels[_vcID].isClose = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }\n\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function byzantineCloseChannel(bytes32 _lcID) public {\n         Channel storage channel = Channels[_lcID];\n\n         // check settlement flag\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         // reentrancy\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }\n\n     function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }\n\n     //Struct Getters\n     function getChannel(bytes32 id) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }\n\n     function getVirtualChannel(bytes32 id) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }\n }"
  VariableDeclaration "NAME"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant NAME = \"Ledger Channel\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: Ledger Channel
       Type: literal_string "Ledger Channel"
       Source: "\"Ledger Channel\""
  VariableDeclaration "VERSION"
     Type: string memory
     Gas costs: [???]
     Source: "string public constant VERSION = \"0.0.1\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: 0.0.1
       Type: literal_string "0.0.1"
       Source: "\"0.0.1\""
  VariableDeclaration "numChannels"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public numChannels = 0"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  EventDefinition "DidLCOpen"
     Gas costs: 0
     Source: "event DidLCOpen (\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     )"
      VariableDeclaration "channelId"
         Type: bytes32
         Source: "bytes32 indexed channelId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "partyA"
         Type: address
         Source: "address indexed partyA"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "partyI"
         Type: address
         Source: "address indexed partyI"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "ethBalanceA"
         Type: uint256
         Source: "uint256 ethBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "token"
         Type: address
         Source: "address token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "tokenBalanceA"
         Type: uint256
         Source: "uint256 tokenBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "LCopenTimeout"
         Type: uint256
         Source: "uint256 LCopenTimeout"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidLCJoin"
     Gas costs: 0
     Source: "event DidLCJoin (\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     )"
      VariableDeclaration "channelId"
         Type: bytes32
         Source: "bytes32 indexed channelId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "ethBalanceI"
         Type: uint256
         Source: "uint256 ethBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenBalanceI"
         Type: uint256
         Source: "uint256 tokenBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidLCDeposit"
     Gas costs: 0
     Source: "event DidLCDeposit (\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     )"
      VariableDeclaration "channelId"
         Type: bytes32
         Source: "bytes32 indexed channelId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "recipient"
         Type: address
         Source: "address indexed recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "deposit"
         Type: uint256
         Source: "uint256 deposit"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "isToken"
         Type: bool
         Source: "bool isToken"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "DidLCUpdateState"
     Gas costs: 0
     Source: "event DidLCUpdateState (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     )"
      VariableDeclaration "channelId"
         Type: bytes32
         Source: "bytes32 indexed channelId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "sequence"
         Type: uint256
         Source: "uint256 sequence"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "numOpenVc"
         Type: uint256
         Source: "uint256 numOpenVc"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "ethBalanceA"
         Type: uint256
         Source: "uint256 ethBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenBalanceA"
         Type: uint256
         Source: "uint256 tokenBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "ethBalanceI"
         Type: uint256
         Source: "uint256 ethBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenBalanceI"
         Type: uint256
         Source: "uint256 tokenBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "vcRoot"
         Type: bytes32
         Source: "bytes32 vcRoot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "updateLCtimeout"
         Type: uint256
         Source: "uint256 updateLCtimeout"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidLCClose"
     Gas costs: 0
     Source: "event DidLCClose (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     )"
      VariableDeclaration "channelId"
         Type: bytes32
         Source: "bytes32 indexed channelId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "sequence"
         Type: uint256
         Source: "uint256 sequence"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "ethBalanceA"
         Type: uint256
         Source: "uint256 ethBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenBalanceA"
         Type: uint256
         Source: "uint256 tokenBalanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "ethBalanceI"
         Type: uint256
         Source: "uint256 ethBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "tokenBalanceI"
         Type: uint256
         Source: "uint256 tokenBalanceI"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidVCInit"
     Gas costs: 0
     Source: "event DidVCInit (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     )"
      VariableDeclaration "lcId"
         Type: bytes32
         Source: "bytes32 indexed lcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "vcId"
         Type: bytes32
         Source: "bytes32 indexed vcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "proof"
         Type: bytes memory
         Source: "bytes proof"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "sequence"
         Type: uint256
         Source: "uint256 sequence"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "partyA"
         Type: address
         Source: "address partyA"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "partyB"
         Type: address
         Source: "address partyB"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "balanceA"
         Type: uint256
         Source: "uint256 balanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "balanceB"
         Type: uint256
         Source: "uint256 balanceB"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidVCSettle"
     Gas costs: 0
     Source: "event DidVCSettle (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     )"
      VariableDeclaration "lcId"
         Type: bytes32
         Source: "bytes32 indexed lcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "vcId"
         Type: bytes32
         Source: "bytes32 indexed vcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "updateSeq"
         Type: uint256
         Source: "uint256 updateSeq"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "updateBalA"
         Type: uint256
         Source: "uint256 updateBalA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "updateBalB"
         Type: uint256
         Source: "uint256 updateBalB"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "challenger"
         Type: address
         Source: "address challenger"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "updateVCtimeout"
         Type: uint256
         Source: "uint256 updateVCtimeout"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "DidVCClose"
     Gas costs: 0
     Source: "event DidVCClose(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     );"
    ParameterList
       Source: "(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     )"
      VariableDeclaration "lcId"
         Type: bytes32
         Source: "bytes32 indexed lcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "vcId"
         Type: bytes32
         Source: "bytes32 indexed vcId"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "balanceA"
         Type: uint256
         Source: "uint256 balanceA"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "balanceB"
         Type: uint256
         Source: "uint256 balanceB"
        ElementaryTypeName uint256
           Source: "uint256"
  StructDefinition "Channel"
     Gas costs: 0
     Source: "struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] partyAddresses; // 0: partyA 1: partyI\n         uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] initialDeposit; // 0: eth 1: tokens\n         uint256 sequence;\n         uint256 confirmTime;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 updateLCtimeout; // when update LC times out\n         bool isOpen; // true when both parties have joined\n         bool isUpdateLCSettling;\n         uint256 numOpenVC;\n         HumanStandardToken token;\n     }"
    VariableDeclaration "partyAddresses"
       Type: address[2] storage pointer
       Source: "address[2] partyAddresses"
      ArrayTypeName
         Source: "address[2]"
        ElementaryTypeName address
           Source: "address"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "ethBalances"
       Type: uint256[4] storage pointer
       Source: "uint256[4] ethBalances"
      ArrayTypeName
         Source: "uint256[4]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 4
           Type unknown.
           Source: "4"
    VariableDeclaration "erc20Balances"
       Type: uint256[4] storage pointer
       Source: "uint256[4] erc20Balances"
      ArrayTypeName
         Source: "uint256[4]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 4
           Type unknown.
           Source: "4"
    VariableDeclaration "initialDeposit"
       Type: uint256[2] storage pointer
       Source: "uint256[2] initialDeposit"
      ArrayTypeName
         Source: "uint256[2]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "sequence"
       Type: uint256
       Source: "uint256 sequence"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "confirmTime"
       Type: uint256
       Source: "uint256 confirmTime"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "VCrootHash"
       Type: bytes32
       Source: "bytes32 VCrootHash"
      ElementaryTypeName bytes32
         Source: "bytes32"
    VariableDeclaration "LCopenTimeout"
       Type: uint256
       Source: "uint256 LCopenTimeout"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "updateLCtimeout"
       Type: uint256
       Source: "uint256 updateLCtimeout"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "isOpen"
       Type: bool
       Source: "bool isOpen"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "isUpdateLCSettling"
       Type: bool
       Source: "bool isUpdateLCSettling"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "numOpenVC"
       Type: uint256
       Source: "uint256 numOpenVC"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "token"
       Type: contract HumanStandardToken
       Source: "HumanStandardToken token"
      UserDefinedTypeName "HumanStandardToken"
         Source: "HumanStandardToken"
  StructDefinition "VirtualChannel"
     Gas costs: 0
     Source: "struct VirtualChannel {\n         bool isClose;\n         bool isInSettlementState;\n         uint256 sequence;\n         address challenger; // Initiator of challenge\n         uint256 updateVCtimeout; // when update VC times out\n         // channel state\n         address partyA; // VC participant A\n         address partyB; // VC participant B\n         address partyI; // LC hub\n         uint256[2] ethBalances;\n         uint256[2] erc20Balances;\n         uint256[2] bond;\n         HumanStandardToken token;\n     }"
    VariableDeclaration "isClose"
       Type: bool
       Source: "bool isClose"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "isInSettlementState"
       Type: bool
       Source: "bool isInSettlementState"
      ElementaryTypeName bool
         Source: "bool"
    VariableDeclaration "sequence"
       Type: uint256
       Source: "uint256 sequence"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "challenger"
       Type: address
       Source: "address challenger"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "updateVCtimeout"
       Type: uint256
       Source: "uint256 updateVCtimeout"
      ElementaryTypeName uint256
         Source: "uint256"
    VariableDeclaration "partyA"
       Type: address
       Source: "address partyA"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "partyB"
       Type: address
       Source: "address partyB"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "partyI"
       Type: address
       Source: "address partyI"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "ethBalances"
       Type: uint256[2] storage pointer
       Source: "uint256[2] ethBalances"
      ArrayTypeName
         Source: "uint256[2]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "erc20Balances"
       Type: uint256[2] storage pointer
       Source: "uint256[2] erc20Balances"
      ArrayTypeName
         Source: "uint256[2]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "bond"
       Type: uint256[2] storage pointer
       Source: "uint256[2] bond"
      ArrayTypeName
         Source: "uint256[2]"
        ElementaryTypeName uint256
           Source: "uint256"
        Literal, token: [no token] value: 2
           Type unknown.
           Source: "2"
    VariableDeclaration "token"
       Type: contract HumanStandardToken
       Source: "HumanStandardToken token"
      UserDefinedTypeName "HumanStandardToken"
         Source: "HumanStandardToken"
  VariableDeclaration "virtualChannels"
     Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
     Gas costs: [???]
     Source: "mapping(bytes32 => VirtualChannel) public virtualChannels"
    Mapping
       Source: "mapping(bytes32 => VirtualChannel)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "VirtualChannel"
         Source: "VirtualChannel"
  VariableDeclaration "Channels"
     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
     Gas costs: [???]
     Source: "mapping(bytes32 => Channel) public Channels"
    Mapping
       Source: "mapping(bytes32 => Channel)"
      ElementaryTypeName bytes32
         Source: "bytes32"
      UserDefinedTypeName "Channel"
         Source: "Channel"
  FunctionDefinition "createChannel" - public
     Source: "function createChannel(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances // [eth, token]\n     )"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_partyI"
         Type: address
         Source: "address _partyI"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_confirmTime"
         Type: uint256
         Source: "uint256 _confirmTime"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_balances"
         Type: uint256[2] memory
         Source: "uint256[2] _balances"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].partyAddresses[0] == address(0)"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: address
               Source: "address(0)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: Channel has already been created.
             Type: literal_string "Channel has already been created."
             Source: "\"Channel has already been created.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_partyI != 0x0, \"No partyI address provided to LC creation\")"
        FunctionCall
           Type: tuple()
           Source: "require(_partyI != 0x0, \"No partyI address provided to LC creation\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator !=
             Type: bool
             Source: "_partyI != 0x0"
            Identifier _partyI
               Type: address
               Source: "_partyI"
            Literal, token: [no token] value: 0x0
               Type: int_const 0
               Source: "0x0"
          Literal, token: [no token] value: No partyI address provided to LC creation
             Type: literal_string "No partyI address provided to LC creation"
             Source: "\"No partyI address provided to LC creation\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\")"
        FunctionCall
           Type: tuple()
           Source: "require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "_balances[0] >= 0 && _balances[1] >= 0"
            BinaryOperation using operator >=
               Type: bool
               Source: "_balances[0] >= 0"
              IndexAccess
                 Type: uint256
                 Source: "_balances[0]"
                Identifier _balances
                   Type: uint256[2] memory
                   Source: "_balances"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator >=
               Type: bool
               Source: "_balances[1] >= 0"
              IndexAccess
                 Type: uint256
                 Source: "_balances[1]"
                Identifier _balances
                   Type: uint256[2] memory
                   Source: "_balances"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Literal, token: [no token] value: Balances cannot be negative
             Type: literal_string "Balances cannot be negative"
             Source: "\"Balances cannot be negative\""
      ExpressionStatement
         Gas costs: 20409
         Source: "Channels[_lcID].partyAddresses[0] = msg.sender"
        Assignment using operator =
           Type: address
           Source: "Channels[_lcID].partyAddresses[0] = msg.sender"
          IndexAccess
             Type: address
             Source: "Channels[_lcID].partyAddresses[0]"
            MemberAccess to member partyAddresses
               Type: address[2] storage ref
               Source: "Channels[_lcID].partyAddresses"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20410
         Source: "Channels[_lcID].partyAddresses[1] = _partyI"
        Assignment using operator =
           Type: address
           Source: "Channels[_lcID].partyAddresses[1] = _partyI"
          IndexAccess
             Type: address
             Source: "Channels[_lcID].partyAddresses[1]"
            MemberAccess to member partyAddresses
               Type: address[2] storage ref
               Source: "Channels[_lcID].partyAddresses"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier _partyI
             Type: address
             Source: "_partyI"
      IfStatement
         Source: "if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "_balances[0] != 0"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(msg.value == _balances[0], \"Eth balance does not match sent value\")"
            FunctionCall
               Type: tuple()
               Source: "require(msg.value == _balances[0], \"Eth balance does not match sent value\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "msg.value == _balances[0]"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                IndexAccess
                   Type: uint256
                   Source: "_balances[0]"
                  Identifier _balances
                     Type: uint256[2] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Literal, token: [no token] value: Eth balance does not match sent value
                 Type: literal_string "Eth balance does not match sent value"
                 Source: "\"Eth balance does not match sent value\""
          ExpressionStatement
             Gas costs: 20156
             Source: "Channels[_lcID].ethBalances[0] = msg.value"
            Assignment using operator =
               Type: uint256
               Source: "Channels[_lcID].ethBalances[0] = msg.value"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
      IfStatement
         Source: "if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "_balances[1] != 0"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }"
          ExpressionStatement
             Gas costs: 20375
             Source: "Channels[_lcID].token = HumanStandardToken(_token)"
            Assignment using operator =
               Type: contract HumanStandardToken
               Source: "Channels[_lcID].token = HumanStandardToken(_token)"
              MemberAccess to member token
                 Type: contract HumanStandardToken
                 Source: "Channels[_lcID].token"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              FunctionCall
                 Type: contract HumanStandardToken
                 Source: "HumanStandardToken(_token)"
                Identifier HumanStandardToken
                   Type: type(contract HumanStandardToken)
                   Source: "HumanStandardToken"
                Identifier _token
                   Type: address
                   Source: "_token"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\")"
            FunctionCall
               Type: tuple()
               Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1])"
                MemberAccess to member transferFrom
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "Channels[_lcID].token.transferFrom"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "Channels[_lcID].token"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier this
                   Type: contract LedgerChannel
                   Source: "this"
                IndexAccess
                   Type: uint256
                   Source: "_balances[1]"
                  Identifier _balances
                     Type: uint256[2] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Literal, token: [no token] value: CreateChannel: token transfer failure
                 Type: literal_string "CreateChannel: token transfer failure"
                 Source: "\"CreateChannel: token transfer failure\""
          ExpressionStatement
             Gas costs: [???]
             Source: "Channels[_lcID].erc20Balances[0] = _balances[1]"
            Assignment using operator =
               Type: uint256
               Source: "Channels[_lcID].erc20Balances[0] = _balances[1]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[0]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "_balances[1]"
                Identifier _balances
                   Type: uint256[2] memory
                   Source: "_balances"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: 5122
         Source: "Channels[_lcID].sequence = 0"
        Assignment using operator =
           Type: uint256
           Source: "Channels[_lcID].sequence = 0"
          MemberAccess to member sequence
             Type: uint256
             Source: "Channels[_lcID].sequence"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20116
         Source: "Channels[_lcID].confirmTime = _confirmTime"
        Assignment using operator =
           Type: uint256
           Source: "Channels[_lcID].confirmTime = _confirmTime"
          MemberAccess to member confirmTime
             Type: uint256
             Source: "Channels[_lcID].confirmTime"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Identifier _confirmTime
             Type: uint256
             Source: "_confirmTime"
      ExpressionStatement
         Gas costs: 20121
         Source: "Channels[_lcID].LCopenTimeout = now + _confirmTime"
        Assignment using operator =
           Type: uint256
           Source: "Channels[_lcID].LCopenTimeout = now + _confirmTime"
          MemberAccess to member LCopenTimeout
             Type: uint256
             Source: "Channels[_lcID].LCopenTimeout"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + _confirmTime"
            Identifier now
               Type: uint256
               Source: "now"
            Identifier _confirmTime
               Type: uint256
               Source: "_confirmTime"
      ExpressionStatement
         Gas costs: 129
         Source: "Channels[_lcID].initialDeposit = _balances"
        Assignment using operator =
           Type: uint256[2] storage ref
           Source: "Channels[_lcID].initialDeposit = _balances"
          MemberAccess to member initialDeposit
             Type: uint256[2] storage ref
             Source: "Channels[_lcID].initialDeposit"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Identifier _balances
             Type: uint256[2] memory
             Source: "_balances"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout)"
        FunctionCall
           Type: tuple()
           Source: "DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout)"
          Identifier DidLCOpen
             Type: function (bytes32,address,address,uint256,address,uint256,uint256)
             Source: "DidLCOpen"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _partyI
             Type: address
             Source: "_partyI"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier _token
             Type: address
             Source: "_token"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          MemberAccess to member LCopenTimeout
             Type: uint256
             Source: "Channels[_lcID].LCopenTimeout"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
  FunctionDefinition "LCOpenTimeout" - public
     Source: "function LCOpenTimeout(bytes32 _lcID) public {\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_lcID];\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _lcID)"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_lcID];\n     }"
      ExpressionStatement
         Gas costs: 812
         Source: "require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false"
            BinaryOperation using operator ==
               Type: bool
               Source: "msg.sender == Channels[_lcID].partyAddresses[0]"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              IndexAccess
                 Type: address
                 Source: "Channels[_lcID].partyAddresses[0]"
                MemberAccess to member partyAddresses
                   Type: address[2] storage ref
                   Source: "Channels[_lcID].partyAddresses"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "Channels[_lcID].isOpen == false"
              MemberAccess to member isOpen
                 Type: bool
                 Source: "Channels[_lcID].isOpen"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: false value: false
                 Type: bool
                 Source: "false"
      ExpressionStatement
         Gas costs: 342
         Source: "require(now > Channels[_lcID].LCopenTimeout)"
        FunctionCall
           Type: tuple()
           Source: "require(now > Channels[_lcID].LCopenTimeout)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >
             Type: bool
             Source: "now > Channels[_lcID].LCopenTimeout"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member LCopenTimeout
               Type: uint256
               Source: "Channels[_lcID].LCopenTimeout"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
      IfStatement
         Source: "if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 355
           Source: "Channels[_lcID].initialDeposit[0] != 0"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[0]"
            MemberAccess to member initialDeposit
               Type: uint256[2] storage ref
               Source: "Channels[_lcID].initialDeposit"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0])"
            FunctionCall
               Type: tuple()
               Source: "Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0])"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "Channels[_lcID].partyAddresses[0].transfer"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
      IfStatement
         Source: "if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 355
           Source: "Channels[_lcID].initialDeposit[1] != 0"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[1]"
            MemberAccess to member initialDeposit
               Type: uint256[2] storage ref
               Source: "Channels[_lcID].initialDeposit"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\")"
            FunctionCall
               Type: tuple()
               Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0])"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "Channels[_lcID].token.transfer"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "Channels[_lcID].token"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "Channels[_lcID].erc20Balances[0]"
                  MemberAccess to member erc20Balances
                     Type: uint256[4] storage ref
                     Source: "Channels[_lcID].erc20Balances"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Literal, token: [no token] value: CreateChannel: token transfer failure
                 Type: literal_string "CreateChannel: token transfer failure"
                 Source: "\"CreateChannel: token transfer failure\""
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0)"
        FunctionCall
           Type: tuple()
           Source: "DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0)"
          Identifier DidLCClose
             Type: function (bytes32,uint256,uint256,uint256,uint256,uint256)
             Source: "DidLCClose"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "Channels[_lcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "Channels[_lcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 91089
         Source: "delete Channels[_lcID]"
        UnaryOperation (prefix) delete
           Type: tuple()
           Source: "delete Channels[_lcID]"
          IndexAccess
             Type: struct LedgerChannel.Channel storage ref
             Source: "Channels[_lcID]"
            Identifier Channels
               Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
               Source: "Channels"
            Identifier _lcID
               Type: bytes32
               Source: "_lcID"
  FunctionDefinition "joinChannel" - public
     Source: "function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n         // require the channel is not open yet\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n         // no longer allow joining functions to be called\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _lcID, uint256[2] _balances)"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_balances"
         Type: uint256[2] memory
         Source: "uint256[2] _balances"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         // require the channel is not open yet\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n         // no longer allow joining functions to be called\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }"
      ExpressionStatement
         Gas costs: 391
         Source: "require(Channels[_lcID].isOpen == false)"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen == false)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].isOpen == false"
            MemberAccess to member isOpen
               Type: bool
               Source: "Channels[_lcID].isOpen"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: false value: false
               Type: bool
               Source: "false"
      ExpressionStatement
         Gas costs: 425
         Source: "require(msg.sender == Channels[_lcID].partyAddresses[1])"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == Channels[_lcID].partyAddresses[1])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == Channels[_lcID].partyAddresses[1]"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[1]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      IfStatement
         Source: "if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "_balances[0] != 0"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(msg.value == _balances[0], \"state balance does not match sent value\")"
            FunctionCall
               Type: tuple()
               Source: "require(msg.value == _balances[0], \"state balance does not match sent value\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "msg.value == _balances[0]"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                IndexAccess
                   Type: uint256
                   Source: "_balances[0]"
                  Identifier _balances
                     Type: uint256[2] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Literal, token: [no token] value: state balance does not match sent value
                 Type: literal_string "state balance does not match sent value"
                 Source: "\"state balance does not match sent value\""
          ExpressionStatement
             Gas costs: 20156
             Source: "Channels[_lcID].ethBalances[1] = msg.value"
            Assignment using operator =
               Type: uint256
               Source: "Channels[_lcID].ethBalances[1] = msg.value"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
      IfStatement
         Source: "if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: [???]
           Source: "_balances[1] != 0"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\")"
            FunctionCall
               Type: tuple()
               Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1])"
                MemberAccess to member transferFrom
                   Type: function (address,address,uint256) external returns (bool)
                   Source: "Channels[_lcID].token.transferFrom"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "Channels[_lcID].token"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier this
                   Type: contract LedgerChannel
                   Source: "this"
                IndexAccess
                   Type: uint256
                   Source: "_balances[1]"
                  Identifier _balances
                     Type: uint256[2] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Literal, token: [no token] value: joinChannel: token transfer failure
                 Type: literal_string "joinChannel: token transfer failure"
                 Source: "\"joinChannel: token transfer failure\""
          ExpressionStatement
             Gas costs: [???]
             Source: "Channels[_lcID].erc20Balances[1] = _balances[1]"
            Assignment using operator =
               Type: uint256
               Source: "Channels[_lcID].erc20Balances[1] = _balances[1]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "_balances[1]"
                Identifier _balances
                   Type: uint256[2] memory
                   Source: "_balances"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "Channels[_lcID].initialDeposit[0]+=_balances[0]"
        Assignment using operator +=
           Type: uint256
           Source: "Channels[_lcID].initialDeposit[0]+=_balances[0]"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[0]"
            MemberAccess to member initialDeposit
               Type: uint256[2] storage ref
               Source: "Channels[_lcID].initialDeposit"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "Channels[_lcID].initialDeposit[1]+=_balances[1]"
        Assignment using operator +=
           Type: uint256
           Source: "Channels[_lcID].initialDeposit[1]+=_balances[1]"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[1]"
            MemberAccess to member initialDeposit
               Type: uint256[2] storage ref
               Source: "Channels[_lcID].initialDeposit"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: 20375
         Source: "Channels[_lcID].isOpen = true"
        Assignment using operator =
           Type: bool
           Source: "Channels[_lcID].isOpen = true"
          MemberAccess to member isOpen
             Type: bool
             Source: "Channels[_lcID].isOpen"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20237
         Source: "numChannels++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "numChannels++"
          Identifier numChannels
             Type: uint256
             Source: "numChannels"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCJoin(_lcID, _balances[0], _balances[1])"
        FunctionCall
           Type: tuple()
           Source: "DidLCJoin(_lcID, _balances[0], _balances[1])"
          Identifier DidLCJoin
             Type: function (bytes32,uint256,uint256)
             Source: "DidLCJoin"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[2] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "deposit" - public
     Source: "function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _lcID, address recipient, uint256 _balance, bool isToken)"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_balance"
         Type: uint256
         Source: "uint256 _balance"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "isToken"
         Type: bool
         Source: "bool isToken"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].isOpen == true"
            MemberAccess to member isOpen
               Type: bool
               Source: "Channels[_lcID].isOpen"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: true value: true
               Type: bool
               Source: "true"
          Literal, token: [no token] value: Tried adding funds to a closed channel
             Type: literal_string "Tried adding funds to a closed channel"
             Source: "\"Tried adding funds to a closed channel\""
      ExpressionStatement
         Gas costs: 845
         Source: "require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1])"
        FunctionCall
           Type: tuple()
           Source: "require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ||
             Type: bool
             Source: "recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]"
            BinaryOperation using operator ==
               Type: bool
               Source: "recipient == Channels[_lcID].partyAddresses[0]"
              Identifier recipient
                 Type: address
                 Source: "recipient"
              IndexAccess
                 Type: address
                 Source: "Channels[_lcID].partyAddresses[0]"
                MemberAccess to member partyAddresses
                   Type: address[2] storage ref
                   Source: "Channels[_lcID].partyAddresses"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "recipient == Channels[_lcID].partyAddresses[1]"
              Identifier recipient
                 Type: address
                 Source: "recipient"
              IndexAccess
                 Type: address
                 Source: "Channels[_lcID].partyAddresses[1]"
                MemberAccess to member partyAddresses
                   Type: address[2] storage ref
                   Source: "Channels[_lcID].partyAddresses"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      IfStatement
         Source: "if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 400
           Source: "Channels[_lcID].partyAddresses[0] == recipient"
          IndexAccess
             Type: address
             Source: "Channels[_lcID].partyAddresses[0]"
            MemberAccess to member partyAddresses
               Type: address[2] storage ref
               Source: "Channels[_lcID].partyAddresses"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier recipient
             Type: address
             Source: "recipient"
        Block
           Source: "{\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }"
          IfStatement
             Source: "if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }"
            Identifier isToken
               Type: bool
               Gas costs: 3
               Source: "isToken"
            Block
               Source: "{\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\")"
                FunctionCall
                   Type: tuple()
                   Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\")"
                  Identifier require
                     Type: function (bool,string memory) pure
                     Source: "require"
                  FunctionCall
                     Type: bool
                     Source: "Channels[_lcID].token.transferFrom(msg.sender, this, _balance)"
                    MemberAccess to member transferFrom
                       Type: function (address,address,uint256) external returns (bool)
                       Source: "Channels[_lcID].token.transferFrom"
                      MemberAccess to member token
                         Type: contract HumanStandardToken
                         Source: "Channels[_lcID].token"
                        IndexAccess
                           Type: struct LedgerChannel.Channel storage ref
                           Source: "Channels[_lcID]"
                          Identifier Channels
                             Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                             Source: "Channels"
                          Identifier _lcID
                             Type: bytes32
                             Source: "_lcID"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier this
                       Type: contract LedgerChannel
                       Source: "this"
                    Identifier _balance
                       Type: uint256
                       Source: "_balance"
                  Literal, token: [no token] value: deposit: token transfer failure
                     Type: literal_string "deposit: token transfer failure"
                     Source: "\"deposit: token transfer failure\""
              ExpressionStatement
                 Gas costs: 20376
                 Source: "Channels[_lcID].erc20Balances[2] += _balance"
                Assignment using operator +=
                   Type: uint256
                   Source: "Channels[_lcID].erc20Balances[2] += _balance"
                  IndexAccess
                     Type: uint256
                     Source: "Channels[_lcID].erc20Balances[2]"
                    MemberAccess to member erc20Balances
                       Type: uint256[4] storage ref
                       Source: "Channels[_lcID].erc20Balances"
                      IndexAccess
                         Type: struct LedgerChannel.Channel storage ref
                         Source: "Channels[_lcID]"
                        Identifier Channels
                           Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                           Source: "Channels"
                        Identifier _lcID
                           Type: bytes32
                           Source: "_lcID"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                  Identifier _balance
                     Type: uint256
                     Source: "_balance"
            Block
               Source: "{\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(msg.value == _balance, \"state balance does not match sent value\")"
                FunctionCall
                   Type: tuple()
                   Source: "require(msg.value == _balance, \"state balance does not match sent value\")"
                  Identifier require
                     Type: function (bool,string memory) pure
                     Source: "require"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "msg.value == _balance"
                    MemberAccess to member value
                       Type: uint256
                       Source: "msg.value"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier _balance
                       Type: uint256
                       Source: "_balance"
                  Literal, token: [no token] value: state balance does not match sent value
                     Type: literal_string "state balance does not match sent value"
                     Source: "\"state balance does not match sent value\""
              ExpressionStatement
                 Gas costs: 20375
                 Source: "Channels[_lcID].ethBalances[2] += msg.value"
                Assignment using operator +=
                   Type: uint256
                   Source: "Channels[_lcID].ethBalances[2] += msg.value"
                  IndexAccess
                     Type: uint256
                     Source: "Channels[_lcID].ethBalances[2]"
                    MemberAccess to member ethBalances
                       Type: uint256[4] storage ref
                       Source: "Channels[_lcID].ethBalances"
                      IndexAccess
                         Type: struct LedgerChannel.Channel storage ref
                         Source: "Channels[_lcID]"
                        Identifier Channels
                           Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                           Source: "Channels"
                        Identifier _lcID
                           Type: bytes32
                           Source: "_lcID"
                    Literal, token: [no token] value: 2
                       Type: int_const 2
                       Source: "2"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
      IfStatement
         Source: "if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 400
           Source: "Channels[_lcID].partyAddresses[1] == recipient"
          IndexAccess
             Type: address
             Source: "Channels[_lcID].partyAddresses[1]"
            MemberAccess to member partyAddresses
               Type: address[2] storage ref
               Source: "Channels[_lcID].partyAddresses"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Identifier recipient
             Type: address
             Source: "recipient"
        Block
           Source: "{\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }"
          IfStatement
             Source: "if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }"
            Identifier isToken
               Type: bool
               Gas costs: 3
               Source: "isToken"
            Block
               Source: "{\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\")"
                FunctionCall
                   Type: tuple()
                   Source: "require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\")"
                  Identifier require
                     Type: function (bool,string memory) pure
                     Source: "require"
                  FunctionCall
                     Type: bool
                     Source: "Channels[_lcID].token.transferFrom(msg.sender, this, _balance)"
                    MemberAccess to member transferFrom
                       Type: function (address,address,uint256) external returns (bool)
                       Source: "Channels[_lcID].token.transferFrom"
                      MemberAccess to member token
                         Type: contract HumanStandardToken
                         Source: "Channels[_lcID].token"
                        IndexAccess
                           Type: struct LedgerChannel.Channel storage ref
                           Source: "Channels[_lcID]"
                          Identifier Channels
                             Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                             Source: "Channels"
                          Identifier _lcID
                             Type: bytes32
                             Source: "_lcID"
                    MemberAccess to member sender
                       Type: address
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier this
                       Type: contract LedgerChannel
                       Source: "this"
                    Identifier _balance
                       Type: uint256
                       Source: "_balance"
                  Literal, token: [no token] value: deposit: token transfer failure
                     Type: literal_string "deposit: token transfer failure"
                     Source: "\"deposit: token transfer failure\""
              ExpressionStatement
                 Gas costs: 20376
                 Source: "Channels[_lcID].erc20Balances[3] += _balance"
                Assignment using operator +=
                   Type: uint256
                   Source: "Channels[_lcID].erc20Balances[3] += _balance"
                  IndexAccess
                     Type: uint256
                     Source: "Channels[_lcID].erc20Balances[3]"
                    MemberAccess to member erc20Balances
                       Type: uint256[4] storage ref
                       Source: "Channels[_lcID].erc20Balances"
                      IndexAccess
                         Type: struct LedgerChannel.Channel storage ref
                         Source: "Channels[_lcID]"
                        Identifier Channels
                           Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                           Source: "Channels"
                        Identifier _lcID
                           Type: bytes32
                           Source: "_lcID"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
                  Identifier _balance
                     Type: uint256
                     Source: "_balance"
            Block
               Source: "{\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "require(msg.value == _balance, \"state balance does not match sent value\")"
                FunctionCall
                   Type: tuple()
                   Source: "require(msg.value == _balance, \"state balance does not match sent value\")"
                  Identifier require
                     Type: function (bool,string memory) pure
                     Source: "require"
                  BinaryOperation using operator ==
                     Type: bool
                     Source: "msg.value == _balance"
                    MemberAccess to member value
                       Type: uint256
                       Source: "msg.value"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                    Identifier _balance
                       Type: uint256
                       Source: "_balance"
                  Literal, token: [no token] value: state balance does not match sent value
                     Type: literal_string "state balance does not match sent value"
                     Source: "\"state balance does not match sent value\""
              ExpressionStatement
                 Gas costs: 20375
                 Source: "Channels[_lcID].ethBalances[3] += msg.value"
                Assignment using operator +=
                   Type: uint256
                   Source: "Channels[_lcID].ethBalances[3] += msg.value"
                  IndexAccess
                     Type: uint256
                     Source: "Channels[_lcID].ethBalances[3]"
                    MemberAccess to member ethBalances
                       Type: uint256[4] storage ref
                       Source: "Channels[_lcID].ethBalances"
                      IndexAccess
                         Type: struct LedgerChannel.Channel storage ref
                         Source: "Channels[_lcID]"
                        Identifier Channels
                           Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                           Source: "Channels"
                        Identifier _lcID
                           Type: bytes32
                           Source: "_lcID"
                    Literal, token: [no token] value: 3
                       Type: int_const 3
                       Source: "3"
                  MemberAccess to member value
                     Type: uint256
                     Source: "msg.value"
                    Identifier msg
                       Type: msg
                       Source: "msg"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCDeposit(_lcID, recipient, _balance, isToken)"
        FunctionCall
           Type: tuple()
           Source: "DidLCDeposit(_lcID, recipient, _balance, isToken)"
          Identifier DidLCDeposit
             Type: function (bytes32,address,uint256,bool)
             Source: "DidLCDeposit"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Identifier recipient
             Type: address
             Source: "recipient"
          Identifier _balance
             Type: uint256
             Source: "_balance"
          Identifier isToken
             Type: bool
             Source: "isToken"
  FunctionDefinition "consensusCloseChannel" - public
     Source: "function consensusCloseChannel(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _sigA,\n         string _sigI\n     )"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_sequence"
         Type: uint256
         Source: "uint256 _sequence"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_balances"
         Type: uint256[4] memory
         Source: "uint256[4] _balances"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration "_sigA"
         Type: string memory
         Source: "string _sigA"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_sigI"
         Type: string memory
         Source: "string _sigI"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }"
      ExpressionStatement
         Gas costs: 391
         Source: "require(Channels[_lcID].isOpen == true)"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].isOpen == true"
            MemberAccess to member isOpen
               Type: bool
               Source: "Channels[_lcID].isOpen"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      VariableDeclarationStatement
         Gas costs: 1052
         Source: "uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3]"
        VariableDeclaration "totalEthDeposit"
           Type: uint256
           Source: "uint256 totalEthDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3]"
          BinaryOperation using operator +
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2]"
            IndexAccess
               Type: uint256
               Source: "Channels[_lcID].initialDeposit[0]"
              MemberAccess to member initialDeposit
                 Type: uint256[2] storage ref
                 Source: "Channels[_lcID].initialDeposit"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "Channels[_lcID].ethBalances[2]"
              MemberAccess to member ethBalances
                 Type: uint256[4] storage ref
                 Source: "Channels[_lcID].ethBalances"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].ethBalances[3]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "Channels[_lcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      VariableDeclarationStatement
         Gas costs: 1052
         Source: "uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3]"
        VariableDeclaration "totalTokenDeposit"
           Type: uint256
           Source: "uint256 totalTokenDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3]"
          BinaryOperation using operator +
             Type: uint256
             Source: "Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2]"
            IndexAccess
               Type: uint256
               Source: "Channels[_lcID].initialDeposit[1]"
              MemberAccess to member initialDeposit
                 Type: uint256[2] storage ref
                 Source: "Channels[_lcID].initialDeposit"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "Channels[_lcID].erc20Balances[2]"
              MemberAccess to member erc20Balances
                 Type: uint256[4] storage ref
                 Source: "Channels[_lcID].erc20Balances"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IndexAccess
             Type: uint256
             Source: "Channels[_lcID].erc20Balances[3]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "Channels[_lcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(totalEthDeposit == _balances[0] + _balances[1])"
        FunctionCall
           Type: tuple()
           Source: "require(totalEthDeposit == _balances[0] + _balances[1])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "totalEthDeposit == _balances[0] + _balances[1]"
            Identifier totalEthDeposit
               Type: uint256
               Source: "totalEthDeposit"
            BinaryOperation using operator +
               Type: uint256
               Source: "_balances[0] + _balances[1]"
              IndexAccess
                 Type: uint256
                 Source: "_balances[0]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "_balances[1]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(totalTokenDeposit == _balances[2] + _balances[3])"
        FunctionCall
           Type: tuple()
           Source: "require(totalTokenDeposit == _balances[2] + _balances[3])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "totalTokenDeposit == _balances[2] + _balances[3]"
            Identifier totalTokenDeposit
               Type: uint256
               Source: "totalTokenDeposit"
            BinaryOperation using operator +
               Type: uint256
               Source: "_balances[2] + _balances[3]"
              IndexAccess
                 Type: uint256
                 Source: "_balances[2]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "_balances[3]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         )"
        VariableDeclaration "_state"
           Type: bytes32
           Source: "bytes32 _state"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier _lcID
               Type: bytes32
               Source: "_lcID"
            Literal, token: true value: true
               Type: bool
               Source: "true"
            Identifier _sequence
               Type: uint256
               Source: "_sequence"
            FunctionCall
               Type: uint256
               Source: "uint256(0)"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: bytes32
               Source: "bytes32(0x0)"
              ElementaryTypeNameExpression bytes32
                 Type: type(bytes32)
                 Source: "bytes32"
              Literal, token: [no token] value: 0x0
                 Type: int_const 0
                 Source: "0x0"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[1]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "_balances[0]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "_balances[1]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "_balances[2]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            IndexAccess
               Type: uint256
               Source: "_balances[3]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA))"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA)"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_state, _sigA)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _state
                 Type: bytes32
                 Source: "_state"
              Identifier _sigA
                 Type: string memory
                 Source: "_sigA"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI))"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI)"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[1]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_state, _sigI)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _state
                 Type: bytes32
                 Source: "_state"
              Identifier _sigI
                 Type: string memory
                 Source: "_sigI"
      ExpressionStatement
         Gas costs: 20375
         Source: "Channels[_lcID].isOpen = false"
        Assignment using operator =
           Type: bool
           Source: "Channels[_lcID].isOpen = false"
          MemberAccess to member isOpen
             Type: bool
             Source: "Channels[_lcID].isOpen"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      IfStatement
         Source: "if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "_balances[0] != 0 || _balances[1] != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_balances[0] != 0"
            IndexAccess
               Type: uint256
               Source: "_balances[0]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_balances[1] != 0"
            IndexAccess
               Type: uint256
               Source: "_balances[1]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "Channels[_lcID].partyAddresses[0].transfer(_balances[0])"
            FunctionCall
               Type: tuple()
               Source: "Channels[_lcID].partyAddresses[0].transfer(_balances[0])"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "Channels[_lcID].partyAddresses[0].transfer"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "_balances[0]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "Channels[_lcID].partyAddresses[1].transfer(_balances[1])"
            FunctionCall
               Type: tuple()
               Source: "Channels[_lcID].partyAddresses[1].transfer(_balances[1])"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "Channels[_lcID].partyAddresses[1].transfer"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[1]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "_balances[1]"
                Identifier _balances
                   Type: uint256[4] memory
                   Source: "_balances"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
      IfStatement
         Source: "if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: [???]
           Source: "_balances[2] != 0 || _balances[3] != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_balances[2] != 0"
            IndexAccess
               Type: uint256
               Source: "_balances[2]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "_balances[3] != 0"
            IndexAccess
               Type: uint256
               Source: "_balances[3]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\")"
            FunctionCall
               Type: tuple()
               Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2])"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "Channels[_lcID].token.transfer"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "Channels[_lcID].token"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "_balances[2]"
                  Identifier _balances
                     Type: uint256[4] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
              Literal, token: [no token] value: happyCloseChannel: token transfer failure
                 Type: literal_string "happyCloseChannel: token transfer failure"
                 Source: "\"happyCloseChannel: token transfer failure\""
          ExpressionStatement
             Gas costs: [???]
             Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\")"
            FunctionCall
               Type: tuple()
               Source: "require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\")"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3])"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "Channels[_lcID].token.transfer"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "Channels[_lcID].token"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                IndexAccess
                   Type: address
                   Source: "Channels[_lcID].partyAddresses[1]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "Channels[_lcID].partyAddresses"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                IndexAccess
                   Type: uint256
                   Source: "_balances[3]"
                  Identifier _balances
                     Type: uint256[4] memory
                     Source: "_balances"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
              Literal, token: [no token] value: happyCloseChannel: token transfer failure
                 Type: literal_string "happyCloseChannel: token transfer failure"
                 Source: "\"happyCloseChannel: token transfer failure\""
      ExpressionStatement
         Gas costs: 20240
         Source: "numChannels--"
        UnaryOperation (postfix) --
           Type: uint256
           Source: "numChannels--"
          Identifier numChannels
             Type: uint256
             Source: "numChannels"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3])"
        FunctionCall
           Type: tuple()
           Source: "DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3])"
          Identifier DidLCClose
             Type: function (bytes32,uint256,uint256,uint256,uint256,uint256)
             Source: "DidLCClose"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Identifier _sequence
             Type: uint256
             Source: "_sequence"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "_balances[2]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          IndexAccess
             Type: uint256
             Source: "_balances[3]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
  FunctionDefinition "updateLCstate" - public
     Source: "function updateLCstate(\n         bytes32 _lcID,\n         uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]); // do same as vc sequence check\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         // update LC state\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         bytes32 _lcID,\n         uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "updateParams"
         Type: uint256[6] memory
         Source: "uint256[6] updateParams"
        ArrayTypeName
           Source: "uint256[6]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 6
             Type unknown.
             Source: "6"
      VariableDeclaration "_VCroot"
         Type: bytes32
         Source: "bytes32 _VCroot"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_sigA"
         Type: string memory
         Source: "string _sigA"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_sigI"
         Type: string memory
         Source: "string _sigI"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]); // do same as vc sequence check\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         // update LC state\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "Channel storage channel = Channels[_lcID]"
        VariableDeclaration "channel"
           Type: struct LedgerChannel.Channel storage pointer
           Source: "Channel storage channel"
          UserDefinedTypeName "Channel"
             Source: "Channel"
        IndexAccess
           Type: struct LedgerChannel.Channel storage ref
           Source: "Channels[_lcID]"
          Identifier Channels
             Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
             Source: "Channels"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
      ExpressionStatement
         Gas costs: 271
         Source: "require(channel.isOpen)"
        FunctionCall
           Type: tuple()
           Source: "require(channel.isOpen)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          MemberAccess to member isOpen
             Type: bool
             Source: "channel.isOpen"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.sequence < updateParams[0])"
        FunctionCall
           Type: tuple()
           Source: "require(channel.sequence < updateParams[0])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "channel.sequence < updateParams[0]"
            MemberAccess to member sequence
               Type: uint256
               Source: "channel.sequence"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            IndexAccess
               Type: uint256
               Source: "updateParams[0]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3])"
        FunctionCall
           Type: tuple()
           Source: "require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]"
            BinaryOperation using operator +
               Type: uint256
               Source: "channel.ethBalances[0] + channel.ethBalances[1]"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            BinaryOperation using operator +
               Type: uint256
               Source: "updateParams[2] + updateParams[3]"
              IndexAccess
                 Type: uint256
                 Source: "updateParams[2]"
                Identifier updateParams
                   Type: uint256[6] memory
                   Source: "updateParams"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
              IndexAccess
                 Type: uint256
                 Source: "updateParams[3]"
                Identifier updateParams
                   Type: uint256[6] memory
                   Source: "updateParams"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5])"
        FunctionCall
           Type: tuple()
           Source: "require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]"
            BinaryOperation using operator +
               Type: uint256
               Source: "channel.erc20Balances[0] + channel.erc20Balances[1]"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[0]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            BinaryOperation using operator +
               Type: uint256
               Source: "updateParams[4] + updateParams[5]"
              IndexAccess
                 Type: uint256
                 Source: "updateParams[4]"
                Identifier updateParams
                   Type: uint256[6] memory
                   Source: "updateParams"
                Literal, token: [no token] value: 4
                   Type: int_const 4
                   Source: "4"
              IndexAccess
                 Type: uint256
                 Source: "updateParams[5]"
                Identifier updateParams
                   Type: uint256[6] memory
                   Source: "updateParams"
                Literal, token: [no token] value: 5
                   Type: int_const 5
                   Source: "5"
      IfStatement
         Source: "if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 313
           Source: "channel.isUpdateLCSettling == true"
          MemberAccess to member isUpdateLCSettling
             Type: bool
             Source: "channel.isUpdateLCSettling"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Block
           Source: "{\n             require(channel.updateLCtimeout > now);\n         }"
          ExpressionStatement
             Gas costs: 240
             Source: "require(channel.updateLCtimeout > now)"
            FunctionCall
               Type: tuple()
               Source: "require(channel.updateLCtimeout > now)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator >
                 Type: bool
                 Source: "channel.updateLCtimeout > now"
                MemberAccess to member updateLCtimeout
                   Type: uint256
                   Source: "channel.updateLCtimeout"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Identifier now
                   Type: uint256
                   Source: "now"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         )"
        VariableDeclaration "_state"
           Type: bytes32
           Source: "bytes32 _state"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier _lcID
               Type: bytes32
               Source: "_lcID"
            Literal, token: false value: false
               Type: bool
               Source: "false"
            IndexAccess
               Type: uint256
               Source: "updateParams[0]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "updateParams[1]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            Identifier _VCroot
               Type: bytes32
               Source: "_VCroot"
            IndexAccess
               Type: address
               Source: "channel.partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "channel.partyAddresses"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: address
               Source: "channel.partyAddresses[1]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "channel.partyAddresses"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "updateParams[2]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            IndexAccess
               Type: uint256
               Source: "updateParams[3]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
            IndexAccess
               Type: uint256
               Source: "updateParams[4]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 4
                 Type: int_const 4
                 Source: "4"
            IndexAccess
               Type: uint256
               Source: "updateParams[5]"
              Identifier updateParams
                 Type: uint256[6] memory
                 Source: "updateParams"
              Literal, token: [no token] value: 5
                 Type: int_const 5
                 Source: "5"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA))"
        FunctionCall
           Type: tuple()
           Source: "require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA)"
            IndexAccess
               Type: address
               Source: "channel.partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "channel.partyAddresses"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_state, _sigA)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _state
                 Type: bytes32
                 Source: "_state"
              Identifier _sigA
                 Type: string memory
                 Source: "_sigA"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI))"
        FunctionCall
           Type: tuple()
           Source: "require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI)"
            IndexAccess
               Type: address
               Source: "channel.partyAddresses[1]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "channel.partyAddresses"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_state, _sigI)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _state
                 Type: bytes32
                 Source: "_state"
              Identifier _sigI
                 Type: string memory
                 Source: "_sigI"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.sequence = updateParams[0]"
        Assignment using operator =
           Type: uint256
           Source: "channel.sequence = updateParams[0]"
          MemberAccess to member sequence
             Type: uint256
             Source: "channel.sequence"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          IndexAccess
             Type: uint256
             Source: "updateParams[0]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.numOpenVC = updateParams[1]"
        Assignment using operator =
           Type: uint256
           Source: "channel.numOpenVC = updateParams[1]"
          MemberAccess to member numOpenVC
             Type: uint256
             Source: "channel.numOpenVC"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          IndexAccess
             Type: uint256
             Source: "updateParams[1]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.ethBalances[0] = updateParams[2]"
        Assignment using operator =
           Type: uint256
           Source: "channel.ethBalances[0] = updateParams[2]"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateParams[2]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.ethBalances[1] = updateParams[3]"
        Assignment using operator =
           Type: uint256
           Source: "channel.ethBalances[1] = updateParams[3]"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[1]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "updateParams[3]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.erc20Balances[0] = updateParams[4]"
        Assignment using operator =
           Type: uint256
           Source: "channel.erc20Balances[0] = updateParams[4]"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateParams[4]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
      ExpressionStatement
         Gas costs: [???]
         Source: "channel.erc20Balances[1] = updateParams[5]"
        Assignment using operator =
           Type: uint256
           Source: "channel.erc20Balances[1] = updateParams[5]"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "updateParams[5]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 5
               Type: int_const 5
               Source: "5"
      ExpressionStatement
         Gas costs: 20029
         Source: "channel.VCrootHash = _VCroot"
        Assignment using operator =
           Type: bytes32
           Source: "channel.VCrootHash = _VCroot"
          MemberAccess to member VCrootHash
             Type: bytes32
             Source: "channel.VCrootHash"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Identifier _VCroot
             Type: bytes32
             Source: "_VCroot"
      ExpressionStatement
         Gas costs: 20323
         Source: "channel.isUpdateLCSettling = true"
        Assignment using operator =
           Type: bool
           Source: "channel.isUpdateLCSettling = true"
          MemberAccess to member isUpdateLCSettling
             Type: bool
             Source: "channel.isUpdateLCSettling"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20231
         Source: "channel.updateLCtimeout = now + channel.confirmTime"
        Assignment using operator =
           Type: uint256
           Source: "channel.updateLCtimeout = now + channel.confirmTime"
          MemberAccess to member updateLCtimeout
             Type: uint256
             Source: "channel.updateLCtimeout"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + channel.confirmTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member confirmTime
               Type: uint256
               Source: "channel.confirmTime"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         )"
        FunctionCall
           Type: tuple()
           Source: "DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         )"
          Identifier DidLCUpdateState
             Type: function (bytes32,uint256,uint256,uint256,uint256,uint256,uint256,bytes32,uint256)
             Source: "DidLCUpdateState"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          IndexAccess
             Type: uint256
             Source: "updateParams[0]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateParams[1]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "updateParams[2]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
          IndexAccess
             Type: uint256
             Source: "updateParams[3]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
          IndexAccess
             Type: uint256
             Source: "updateParams[4]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 4
               Type: int_const 4
               Source: "4"
          IndexAccess
             Type: uint256
             Source: "updateParams[5]"
            Identifier updateParams
               Type: uint256[6] memory
               Source: "updateParams"
            Literal, token: [no token] value: 5
               Type: int_const 5
               Source: "5"
          Identifier _VCroot
             Type: bytes32
             Source: "_VCroot"
          MemberAccess to member updateLCtimeout
             Type: uint256
             Source: "channel.updateLCtimeout"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
  FunctionDefinition "initVCstate" - public
     Source: "function initVCstate(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n         // partyB is now Ingrid\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n         // Check the oldState is in the root hash\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA; // VC participant A\n         virtualChannels[_vcID].partyB = _partyB; // VC participant B\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string sigA\n     )"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_vcID"
         Type: bytes32
         Source: "bytes32 _vcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_proof"
         Type: bytes memory
         Source: "bytes _proof"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "_partyA"
         Type: address
         Source: "address _partyA"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_partyB"
         Type: address
         Source: "address _partyB"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_bond"
         Type: uint256[2] memory
         Source: "uint256[2] _bond"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration "_balances"
         Type: uint256[4] memory
         Source: "uint256[4] _balances"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration "sigA"
         Type: string memory
         Source: "string sigA"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n         // partyB is now Ingrid\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n         // Check the oldState is in the root hash\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA; // VC participant A\n         virtualChannels[_vcID].partyB = _partyB; // VC participant B\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          MemberAccess to member isOpen
             Type: bool
             Source: "Channels[_lcID].isOpen"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: [no token] value: LC is closed.
             Type: literal_string "LC is closed."
             Source: "\"LC is closed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(!virtualChannels[_vcID].isClose, \"VC is closed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(!virtualChannels[_vcID].isClose, \"VC is closed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!virtualChannels[_vcID].isClose"
            MemberAccess to member isClose
               Type: bool
               Source: "virtualChannels[_vcID].isClose"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
          Literal, token: [no token] value: VC is closed.
             Type: literal_string "VC is closed."
             Source: "\"VC is closed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "Channels[_lcID].updateLCtimeout < now"
            MemberAccess to member updateLCtimeout
               Type: uint256
               Source: "Channels[_lcID].updateLCtimeout"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Identifier now
               Type: uint256
               Source: "now"
          Literal, token: [no token] value: LC timeout not over.
             Type: literal_string "LC timeout not over."
             Source: "\"LC timeout not over.\""
      ExpressionStatement
         Gas costs: 343
         Source: "require(virtualChannels[_vcID].updateVCtimeout == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(virtualChannels[_vcID].updateVCtimeout == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "virtualChannels[_vcID].updateVCtimeout == 0"
            MemberAccess to member updateVCtimeout
               Type: uint256
               Source: "virtualChannels[_vcID].updateVCtimeout"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         )"
        VariableDeclaration "_initState"
           Type: bytes32
           Source: "bytes32 _initState"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier _vcID
               Type: bytes32
               Source: "_vcID"
            FunctionCall
               Type: uint256
               Source: "uint256(0)"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            Identifier _partyA
               Type: address
               Source: "_partyA"
            Identifier _partyB
               Type: address
               Source: "_partyB"
            IndexAccess
               Type: uint256
               Source: "_bond[0]"
              Identifier _bond
                 Type: uint256[2] memory
                 Source: "_bond"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "_bond[1]"
              Identifier _bond
                 Type: uint256[2] memory
                 Source: "_bond"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "_balances[0]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "_balances[1]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "_balances[2]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            IndexAccess
               Type: uint256
               Source: "_balances[3]"
              Identifier _balances
                 Type: uint256[4] memory
                 Source: "_balances"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(_partyA == ECTools.recoverSigner(_initState, sigA))"
        FunctionCall
           Type: tuple()
           Source: "require(_partyA == ECTools.recoverSigner(_initState, sigA))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "_partyA == ECTools.recoverSigner(_initState, sigA)"
            Identifier _partyA
               Type: address
               Source: "_partyA"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_initState, sigA)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _initState
                 Type: bytes32
                 Source: "_initState"
              Identifier sigA
                 Type: string memory
                 Source: "sigA"
      ExpressionStatement
         Gas costs: 365
         Source: "require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true)"
        FunctionCall
           Type: tuple()
           Source: "require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true"
            FunctionCall
               Type: bool
               Source: "_isContained(_initState, _proof, Channels[_lcID].VCrootHash)"
              Identifier _isContained
                 Type: function (bytes32,bytes memory,bytes32) pure returns (bool)
                 Source: "_isContained"
              Identifier _initState
                 Type: bytes32
                 Source: "_initState"
              Identifier _proof
                 Type: bytes memory
                 Source: "_proof"
              MemberAccess to member VCrootHash
                 Type: bytes32
                 Source: "Channels[_lcID].VCrootHash"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      ExpressionStatement
         Gas costs: 20375
         Source: "virtualChannels[_vcID].partyA = _partyA"
        Assignment using operator =
           Type: address
           Source: "virtualChannels[_vcID].partyA = _partyA"
          MemberAccess to member partyA
             Type: address
             Source: "virtualChannels[_vcID].partyA"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Identifier _partyA
             Type: address
             Source: "_partyA"
      ExpressionStatement
         Gas costs: 20369
         Source: "virtualChannels[_vcID].partyB = _partyB"
        Assignment using operator =
           Type: address
           Source: "virtualChannels[_vcID].partyB = _partyB"
          MemberAccess to member partyB
             Type: address
             Source: "virtualChannels[_vcID].partyB"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Identifier _partyB
             Type: address
             Source: "_partyB"
      ExpressionStatement
         Gas costs: 5116
         Source: "virtualChannels[_vcID].sequence = uint256(0)"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].sequence = uint256(0)"
          MemberAccess to member sequence
             Type: uint256
             Source: "virtualChannels[_vcID].sequence"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          FunctionCall
             Type: uint256
             Source: "uint256(0)"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].ethBalances[0] = _balances[0]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].ethBalances[0] = _balances[0]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].ethBalances[1] = _balances[1]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].ethBalances[1] = _balances[1]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].ethBalances[1]"
            MemberAccess to member ethBalances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].erc20Balances[0] = _balances[2]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].erc20Balances[0] = _balances[2]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[2]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].erc20Balances[1] = _balances[3]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].erc20Balances[1] = _balances[3]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "_balances[3]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      ExpressionStatement
         Gas costs: 146
         Source: "virtualChannels[_vcID].bond = _bond"
        Assignment using operator =
           Type: uint256[2] storage ref
           Source: "virtualChannels[_vcID].bond = _bond"
          MemberAccess to member bond
             Type: uint256[2] storage ref
             Source: "virtualChannels[_vcID].bond"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Identifier _bond
             Type: uint256[2] memory
             Source: "_bond"
      ExpressionStatement
         Gas costs: 20429
         Source: "virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime"
          MemberAccess to member updateVCtimeout
             Type: uint256
             Source: "virtualChannels[_vcID].updateVCtimeout"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + Channels[_lcID].confirmTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member confirmTime
               Type: uint256
               Source: "Channels[_lcID].confirmTime"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
      ExpressionStatement
         Gas costs: 20419
         Source: "virtualChannels[_vcID].isInSettlementState = true"
        Assignment using operator =
           Type: bool
           Source: "virtualChannels[_vcID].isInSettlementState = true"
          MemberAccess to member isInSettlementState
             Type: bool
             Source: "virtualChannels[_vcID].isInSettlementState"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1])"
        FunctionCall
           Type: tuple()
           Source: "DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1])"
          Identifier DidVCInit
             Type: function (bytes32,bytes32,bytes memory,uint256,address,address,uint256,uint256)
             Source: "DidVCInit"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Identifier _vcID
             Type: bytes32
             Source: "_vcID"
          Identifier _proof
             Type: bytes memory
             Source: "_proof"
          FunctionCall
             Type: uint256
             Source: "uint256(0)"
            ElementaryTypeNameExpression uint256
               Type: type(uint256)
               Source: "uint256"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Identifier _partyA
             Type: address
             Source: "_partyA"
          Identifier _partyB
             Type: address
             Source: "_partyB"
          IndexAccess
             Type: uint256
             Source: "_balances[0]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "_balances[1]"
            Identifier _balances
               Type: uint256[4] memory
               Source: "_balances"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "settleVC" - public
     Source: "function settleVC(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n         // channel state\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string sigA\n     )"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_vcID"
         Type: bytes32
         Source: "bytes32 _vcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "updateSeq"
         Type: uint256
         Source: "uint256 updateSeq"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_partyA"
         Type: address
         Source: "address _partyA"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_partyB"
         Type: address
         Source: "address _partyB"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "updateBal"
         Type: uint256[4] memory
         Source: "uint256[4] updateBal"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration "sigA"
         Type: string memory
         Source: "string sigA"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n         // channel state\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          MemberAccess to member isOpen
             Type: bool
             Source: "Channels[_lcID].isOpen"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: [no token] value: LC is closed.
             Type: literal_string "LC is closed."
             Source: "\"LC is closed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(!virtualChannels[_vcID].isClose, \"VC is closed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(!virtualChannels[_vcID].isClose, \"VC is closed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!virtualChannels[_vcID].isClose"
            MemberAccess to member isClose
               Type: bool
               Source: "virtualChannels[_vcID].isClose"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
          Literal, token: [no token] value: VC is closed.
             Type: literal_string "VC is closed."
             Source: "\"VC is closed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\")"
        FunctionCall
           Type: tuple()
           Source: "require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "virtualChannels[_vcID].sequence < updateSeq"
            MemberAccess to member sequence
               Type: uint256
               Source: "virtualChannels[_vcID].sequence"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Identifier updateSeq
               Type: uint256
               Source: "updateSeq"
          Literal, token: [no token] value: VC sequence is higher than update sequence.
             Type: literal_string "VC sequence is higher than update sequence."
             Source: "\"VC sequence is higher than update sequence.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         )"
        FunctionCall
           Type: tuple()
           Source: "require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         )"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3]"
            BinaryOperation using operator <
               Type: bool
               Source: "virtualChannels[_vcID].ethBalances[1] < updateBal[1]"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "updateBal[1]"
                Identifier updateBal
                   Type: uint256[4] memory
                   Source: "updateBal"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
            BinaryOperation using operator <
               Type: bool
               Source: "virtualChannels[_vcID].erc20Balances[1] < updateBal[3]"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "updateBal[3]"
                Identifier updateBal
                   Type: uint256[4] memory
                   Source: "updateBal"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
          Literal, token: [no token] value: State updates may only increase recipient balance.
             Type: literal_string "State updates may only increase recipient balance."
             Source: "\"State updates may only increase recipient balance.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\")"
        FunctionCall
           Type: tuple()
           Source: "require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator &&
             Type: bool
             Source: "virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3]"
            BinaryOperation using operator ==
               Type: bool
               Source: "virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1]"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].bond[0]"
                MemberAccess to member bond
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].bond"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "updateBal[0] + updateBal[1]"
                IndexAccess
                   Type: uint256
                   Source: "updateBal[0]"
                  Identifier updateBal
                     Type: uint256[4] memory
                     Source: "updateBal"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "updateBal[1]"
                  Identifier updateBal
                     Type: uint256[4] memory
                     Source: "updateBal"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            BinaryOperation using operator ==
               Type: bool
               Source: "virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3]"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].bond[1]"
                MemberAccess to member bond
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].bond"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "updateBal[2] + updateBal[3]"
                IndexAccess
                   Type: uint256
                   Source: "updateBal[2]"
                  Identifier updateBal
                     Type: uint256[4] memory
                     Source: "updateBal"
                  Literal, token: [no token] value: 2
                     Type: int_const 2
                     Source: "2"
                IndexAccess
                   Type: uint256
                   Source: "updateBal[3]"
                  Identifier updateBal
                     Type: uint256[4] memory
                     Source: "updateBal"
                  Literal, token: [no token] value: 3
                     Type: int_const 3
                     Source: "3"
          Literal, token: [no token] value: Incorrect balances for bonded amount
             Type: literal_string "Incorrect balances for bonded amount"
             Source: "\"Incorrect balances for bonded amount\""
      ExpressionStatement
         Gas costs: 342
         Source: "require(Channels[_lcID].updateLCtimeout < now)"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].updateLCtimeout < now)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "Channels[_lcID].updateLCtimeout < now"
            MemberAccess to member updateLCtimeout
               Type: uint256
               Source: "Channels[_lcID].updateLCtimeout"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Identifier now
               Type: uint256
               Source: "now"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         )"
        VariableDeclaration "_updateState"
           Type: bytes32
           Source: "bytes32 _updateState"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         )"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes memory
             Source: "abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )"
            MemberAccess to member encodePacked
               Type: function () pure returns (bytes memory)
               Source: "abi.encodePacked"
              Identifier abi
                 Type: abi
                 Source: "abi"
            Identifier _vcID
               Type: bytes32
               Source: "_vcID"
            Identifier updateSeq
               Type: uint256
               Source: "updateSeq"
            Identifier _partyA
               Type: address
               Source: "_partyA"
            Identifier _partyB
               Type: address
               Source: "_partyB"
            IndexAccess
               Type: uint256
               Source: "virtualChannels[_vcID].bond[0]"
              MemberAccess to member bond
                 Type: uint256[2] storage ref
                 Source: "virtualChannels[_vcID].bond"
                IndexAccess
                   Type: struct LedgerChannel.VirtualChannel storage ref
                   Source: "virtualChannels[_vcID]"
                  Identifier virtualChannels
                     Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                     Source: "virtualChannels"
                  Identifier _vcID
                     Type: bytes32
                     Source: "_vcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "virtualChannels[_vcID].bond[1]"
              MemberAccess to member bond
                 Type: uint256[2] storage ref
                 Source: "virtualChannels[_vcID].bond"
                IndexAccess
                   Type: struct LedgerChannel.VirtualChannel storage ref
                   Source: "virtualChannels[_vcID]"
                  Identifier virtualChannels
                     Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                     Source: "virtualChannels"
                  Identifier _vcID
                     Type: bytes32
                     Source: "_vcID"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "updateBal[0]"
              Identifier updateBal
                 Type: uint256[4] memory
                 Source: "updateBal"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "updateBal[1]"
              Identifier updateBal
                 Type: uint256[4] memory
                 Source: "updateBal"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "updateBal[2]"
              Identifier updateBal
                 Type: uint256[4] memory
                 Source: "updateBal"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
            IndexAccess
               Type: uint256
               Source: "updateBal[3]"
              Identifier updateBal
                 Type: uint256[4] memory
                 Source: "updateBal"
              Literal, token: [no token] value: 3
                 Type: int_const 3
                 Source: "3"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA))"
        FunctionCall
           Type: tuple()
           Source: "require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA))"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA)"
            MemberAccess to member partyA
               Type: address
               Source: "virtualChannels[_vcID].partyA"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            FunctionCall
               Type: address
               Source: "ECTools.recoverSigner(_updateState, sigA)"
              MemberAccess to member recoverSigner
                 Type: function (bytes32,string memory) pure returns (address)
                 Source: "ECTools.recoverSigner"
                Identifier ECTools
                   Type: type(library ECTools)
                   Source: "ECTools"
              Identifier _updateState
                 Type: bytes32
                 Source: "_updateState"
              Identifier sigA
                 Type: string memory
                 Source: "sigA"
      ExpressionStatement
         Gas costs: 20374
         Source: "virtualChannels[_vcID].challenger = msg.sender"
        Assignment using operator =
           Type: address
           Source: "virtualChannels[_vcID].challenger = msg.sender"
          MemberAccess to member challenger
             Type: address
             Source: "virtualChannels[_vcID].challenger"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20116
         Source: "virtualChannels[_vcID].sequence = updateSeq"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].sequence = updateSeq"
          MemberAccess to member sequence
             Type: uint256
             Source: "virtualChannels[_vcID].sequence"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Identifier updateSeq
             Type: uint256
             Source: "updateSeq"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].ethBalances[0] = updateBal[0]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].ethBalances[0] = updateBal[0]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateBal[0]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].ethBalances[1] = updateBal[1]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].ethBalances[1] = updateBal[1]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].ethBalances[1]"
            MemberAccess to member ethBalances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].ethBalances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "updateBal[1]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].erc20Balances[0] = updateBal[2]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].erc20Balances[0] = updateBal[2]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateBal[2]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 2
               Type: int_const 2
               Source: "2"
      ExpressionStatement
         Gas costs: [???]
         Source: "virtualChannels[_vcID].erc20Balances[1] = updateBal[3]"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].erc20Balances[1] = updateBal[3]"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          IndexAccess
             Type: uint256
             Source: "updateBal[3]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      ExpressionStatement
         Gas costs: 20429
         Source: "virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime"
        Assignment using operator =
           Type: uint256
           Source: "virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime"
          MemberAccess to member updateVCtimeout
             Type: uint256
             Source: "virtualChannels[_vcID].updateVCtimeout"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          BinaryOperation using operator +
             Type: uint256
             Source: "now + Channels[_lcID].confirmTime"
            Identifier now
               Type: uint256
               Source: "now"
            MemberAccess to member confirmTime
               Type: uint256
               Source: "Channels[_lcID].confirmTime"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout)"
        FunctionCall
           Type: tuple()
           Source: "DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout)"
          Identifier DidVCSettle
             Type: function (bytes32,bytes32,uint256,uint256,uint256,address,uint256)
             Source: "DidVCSettle"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Identifier _vcID
             Type: bytes32
             Source: "_vcID"
          Identifier updateSeq
             Type: uint256
             Source: "updateSeq"
          IndexAccess
             Type: uint256
             Source: "updateBal[0]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "updateBal[1]"
            Identifier updateBal
               Type: uint256[4] memory
               Source: "updateBal"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          MemberAccess to member updateVCtimeout
             Type: uint256
             Source: "virtualChannels[_vcID].updateVCtimeout"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
  FunctionDefinition "closeVirtualChannel" - public
     Source: "function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_lcID].numOpenVC--;\n         // close vc flags\n         virtualChannels[_vcID].isClose = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _lcID, bytes32 _vcID)"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_vcID"
         Type: bytes32
         Source: "bytes32 _vcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         // require(updateLCtimeout > now)\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_lcID].numOpenVC--;\n         // close vc flags\n         virtualChannels[_vcID].isClose = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(Channels[_lcID].isOpen, \"LC is closed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          MemberAccess to member isOpen
             Type: bool
             Source: "Channels[_lcID].isOpen"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
          Literal, token: [no token] value: LC is closed.
             Type: literal_string "LC is closed."
             Source: "\"LC is closed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\")"
        FunctionCall
           Type: tuple()
           Source: "require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          MemberAccess to member isInSettlementState
             Type: bool
             Source: "virtualChannels[_vcID].isInSettlementState"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Literal, token: [no token] value: VC is not in settlement state.
             Type: literal_string "VC is not in settlement state."
             Source: "\"VC is not in settlement state.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\")"
        FunctionCall
           Type: tuple()
           Source: "require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "virtualChannels[_vcID].updateVCtimeout < now"
            MemberAccess to member updateVCtimeout
               Type: uint256
               Source: "virtualChannels[_vcID].updateVCtimeout"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Identifier now
               Type: uint256
               Source: "now"
          Literal, token: [no token] value: Update vc timeout has not elapsed.
             Type: literal_string "Update vc timeout has not elapsed."
             Source: "\"Update vc timeout has not elapsed.\""
      ExpressionStatement
         Gas costs: [???]
         Source: "require(!virtualChannels[_vcID].isClose, \"VC is already closed\")"
        FunctionCall
           Type: tuple()
           Source: "require(!virtualChannels[_vcID].isClose, \"VC is already closed\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!virtualChannels[_vcID].isClose"
            MemberAccess to member isClose
               Type: bool
               Source: "virtualChannels[_vcID].isClose"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
          Literal, token: [no token] value: VC is already closed
             Type: literal_string "VC is already closed"
             Source: "\"VC is already closed\""
      ExpressionStatement
         Gas costs: 20348
         Source: "Channels[_lcID].numOpenVC--"
        UnaryOperation (postfix) --
           Type: uint256
           Source: "Channels[_lcID].numOpenVC--"
          MemberAccess to member numOpenVC
             Type: uint256
             Source: "Channels[_lcID].numOpenVC"
            IndexAccess
               Type: struct LedgerChannel.Channel storage ref
               Source: "Channels[_lcID]"
              Identifier Channels
                 Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                 Source: "Channels"
              Identifier _lcID
                 Type: bytes32
                 Source: "_lcID"
      ExpressionStatement
         Gas costs: 20369
         Source: "virtualChannels[_vcID].isClose = true"
        Assignment using operator =
           Type: bool
           Source: "virtualChannels[_vcID].isClose = true"
          MemberAccess to member isClose
             Type: bool
             Source: "virtualChannels[_vcID].isClose"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      IfStatement
         Source: "if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 738
           Source: "virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]"
          MemberAccess to member partyA
             Type: address
             Source: "virtualChannels[_vcID].partyA"
            IndexAccess
               Type: struct LedgerChannel.VirtualChannel storage ref
               Source: "virtualChannels[_vcID]"
              Identifier virtualChannels
                 Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                 Source: "virtualChannels"
              Identifier _vcID
                 Type: bytes32
                 Source: "_vcID"
          IndexAccess
             Type: address
             Source: "Channels[_lcID].partyAddresses[0]"
            MemberAccess to member partyAddresses
               Type: address[2] storage ref
               Source: "Channels[_lcID].partyAddresses"
              IndexAccess
                 Type: struct LedgerChannel.Channel storage ref
                 Source: "Channels[_lcID]"
                Identifier Channels
                   Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                   Source: "Channels"
                Identifier _lcID
                   Type: bytes32
                   Source: "_lcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         }"
          ExpressionStatement
             Gas costs: 20719
             Source: "Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0]"
            Assignment using operator +=
               Type: uint256
               Source: "Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Gas costs: 20719
             Source: "Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1]"
            Assignment using operator +=
               Type: uint256
               Source: "Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].ethBalances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
          ExpressionStatement
             Gas costs: 20719
             Source: "Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0]"
            Assignment using operator +=
               Type: uint256
               Source: "Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[0]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].erc20Balances[0]"
                MemberAccess to member erc20Balances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
          ExpressionStatement
             Gas costs: 20719
             Source: "Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1]"
            Assignment using operator +=
               Type: uint256
               Source: "Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1]"
              IndexAccess
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "Channels[_lcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.Channel storage ref
                     Source: "Channels[_lcID]"
                    Identifier Channels
                       Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                       Source: "Channels"
                    Identifier _lcID
                       Type: bytes32
                       Source: "_lcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "virtualChannels[_vcID].erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[2] storage ref
                   Source: "virtualChannels[_vcID].erc20Balances"
                  IndexAccess
                     Type: struct LedgerChannel.VirtualChannel storage ref
                     Source: "virtualChannels[_vcID]"
                    Identifier virtualChannels
                       Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                       Source: "virtualChannels"
                    Identifier _vcID
                       Type: bytes32
                       Source: "_vcID"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
        IfStatement
           Source: "if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }"
          BinaryOperation using operator ==
             Type: bool
             Gas costs: 744
             Source: "virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]"
            MemberAccess to member partyB
               Type: address
               Source: "virtualChannels[_vcID].partyB"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            IndexAccess
               Type: address
               Source: "Channels[_lcID].partyAddresses[0]"
              MemberAccess to member partyAddresses
                 Type: address[2] storage ref
                 Source: "Channels[_lcID].partyAddresses"
                IndexAccess
                   Type: struct LedgerChannel.Channel storage ref
                   Source: "Channels[_lcID]"
                  Identifier Channels
                     Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                     Source: "Channels"
                  Identifier _lcID
                     Type: bytes32
                     Source: "_lcID"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          Block
             Source: "{\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }"
            ExpressionStatement
               Gas costs: 20719
               Source: "Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1]"
              Assignment using operator +=
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1]"
                IndexAccess
                   Type: uint256
                   Source: "Channels[_lcID].ethBalances[0]"
                  MemberAccess to member ethBalances
                     Type: uint256[4] storage ref
                     Source: "Channels[_lcID].ethBalances"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "virtualChannels[_vcID].ethBalances[1]"
                  MemberAccess to member ethBalances
                     Type: uint256[2] storage ref
                     Source: "virtualChannels[_vcID].ethBalances"
                    IndexAccess
                       Type: struct LedgerChannel.VirtualChannel storage ref
                       Source: "virtualChannels[_vcID]"
                      Identifier virtualChannels
                         Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                         Source: "virtualChannels"
                      Identifier _vcID
                         Type: bytes32
                         Source: "_vcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            ExpressionStatement
               Gas costs: 20719
               Source: "Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0]"
              Assignment using operator +=
                 Type: uint256
                 Source: "Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0]"
                IndexAccess
                   Type: uint256
                   Source: "Channels[_lcID].ethBalances[1]"
                  MemberAccess to member ethBalances
                     Type: uint256[4] storage ref
                     Source: "Channels[_lcID].ethBalances"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                IndexAccess
                   Type: uint256
                   Source: "virtualChannels[_vcID].ethBalances[0]"
                  MemberAccess to member ethBalances
                     Type: uint256[2] storage ref
                     Source: "virtualChannels[_vcID].ethBalances"
                    IndexAccess
                       Type: struct LedgerChannel.VirtualChannel storage ref
                       Source: "virtualChannels[_vcID]"
                      Identifier virtualChannels
                         Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                         Source: "virtualChannels"
                      Identifier _vcID
                         Type: bytes32
                         Source: "_vcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
            ExpressionStatement
               Gas costs: 20719
               Source: "Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1]"
              Assignment using operator +=
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1]"
                IndexAccess
                   Type: uint256
                   Source: "Channels[_lcID].erc20Balances[0]"
                  MemberAccess to member erc20Balances
                     Type: uint256[4] storage ref
                     Source: "Channels[_lcID].erc20Balances"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "virtualChannels[_vcID].erc20Balances[1]"
                  MemberAccess to member erc20Balances
                     Type: uint256[2] storage ref
                     Source: "virtualChannels[_vcID].erc20Balances"
                    IndexAccess
                       Type: struct LedgerChannel.VirtualChannel storage ref
                       Source: "virtualChannels[_vcID]"
                      Identifier virtualChannels
                         Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                         Source: "virtualChannels"
                      Identifier _vcID
                         Type: bytes32
                         Source: "_vcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
            ExpressionStatement
               Gas costs: 20719
               Source: "Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0]"
              Assignment using operator +=
                 Type: uint256
                 Source: "Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0]"
                IndexAccess
                   Type: uint256
                   Source: "Channels[_lcID].erc20Balances[1]"
                  MemberAccess to member erc20Balances
                     Type: uint256[4] storage ref
                     Source: "Channels[_lcID].erc20Balances"
                    IndexAccess
                       Type: struct LedgerChannel.Channel storage ref
                       Source: "Channels[_lcID]"
                      Identifier Channels
                         Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
                         Source: "Channels"
                      Identifier _lcID
                         Type: bytes32
                         Source: "_lcID"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                IndexAccess
                   Type: uint256
                   Source: "virtualChannels[_vcID].erc20Balances[0]"
                  MemberAccess to member erc20Balances
                     Type: uint256[2] storage ref
                     Source: "virtualChannels[_vcID].erc20Balances"
                    IndexAccess
                       Type: struct LedgerChannel.VirtualChannel storage ref
                       Source: "virtualChannels[_vcID]"
                      Identifier virtualChannels
                         Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                         Source: "virtualChannels"
                      Identifier _vcID
                         Type: bytes32
                         Source: "_vcID"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1])"
        FunctionCall
           Type: tuple()
           Source: "DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1])"
          Identifier DidVCClose
             Type: function (bytes32,bytes32,uint256,uint256)
             Source: "DidVCClose"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          Identifier _vcID
             Type: bytes32
             Source: "_vcID"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "virtualChannels[_vcID].erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[2] storage ref
               Source: "virtualChannels[_vcID].erc20Balances"
              IndexAccess
                 Type: struct LedgerChannel.VirtualChannel storage ref
                 Source: "virtualChannels[_vcID]"
                Identifier virtualChannels
                   Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
                   Source: "virtualChannels"
                Identifier _vcID
                   Type: bytes32
                   Source: "_vcID"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
  FunctionDefinition "byzantineCloseChannel" - public
     Source: "function byzantineCloseChannel(bytes32 _lcID) public {\n         Channel storage channel = Channels[_lcID];\n\n         // check settlement flag\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         // reentrancy\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _lcID)"
      VariableDeclaration "_lcID"
         Type: bytes32
         Source: "bytes32 _lcID"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         Channel storage channel = Channels[_lcID];\n\n         // check settlement flag\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         // reentrancy\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }"
      VariableDeclarationStatement
         Gas costs: 113
         Source: "Channel storage channel = Channels[_lcID]"
        VariableDeclaration "channel"
           Type: struct LedgerChannel.Channel storage pointer
           Source: "Channel storage channel"
          UserDefinedTypeName "Channel"
             Source: "Channel"
        IndexAccess
           Type: struct LedgerChannel.Channel storage ref
           Source: "Channels[_lcID]"
          Identifier Channels
             Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
             Source: "Channels"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.isOpen, \"Channel is not open\")"
        FunctionCall
           Type: tuple()
           Source: "require(channel.isOpen, \"Channel is not open\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          MemberAccess to member isOpen
             Type: bool
             Source: "channel.isOpen"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: [no token] value: Channel is not open
             Type: literal_string "Channel is not open"
             Source: "\"Channel is not open\""
      ExpressionStatement
         Gas costs: 339
         Source: "require(channel.isUpdateLCSettling == true)"
        FunctionCall
           Type: tuple()
           Source: "require(channel.isUpdateLCSettling == true)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "channel.isUpdateLCSettling == true"
            MemberAccess to member isUpdateLCSettling
               Type: bool
               Source: "channel.isUpdateLCSettling"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: true value: true
               Type: bool
               Source: "true"
      ExpressionStatement
         Gas costs: 241
         Source: "require(channel.numOpenVC == 0)"
        FunctionCall
           Type: tuple()
           Source: "require(channel.numOpenVC == 0)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "channel.numOpenVC == 0"
            MemberAccess to member numOpenVC
               Type: uint256
               Source: "channel.numOpenVC"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      ExpressionStatement
         Gas costs: [???]
         Source: "require(channel.updateLCtimeout < now, \"LC timeout over.\")"
        FunctionCall
           Type: tuple()
           Source: "require(channel.updateLCtimeout < now, \"LC timeout over.\")"
          Identifier require
             Type: function (bool,string memory) pure
             Source: "require"
          BinaryOperation using operator <
             Type: bool
             Source: "channel.updateLCtimeout < now"
            MemberAccess to member updateLCtimeout
               Type: uint256
               Source: "channel.updateLCtimeout"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Identifier now
               Type: uint256
               Source: "now"
          Literal, token: [no token] value: LC timeout over.
             Type: literal_string "LC timeout over."
             Source: "\"LC timeout over.\""
      VariableDeclarationStatement
         Gas costs: 746
         Source: "uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3]"
        VariableDeclaration "totalEthDeposit"
           Type: uint256
           Source: "uint256 totalEthDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3]"
          BinaryOperation using operator +
             Type: uint256
             Source: "channel.initialDeposit[0] + channel.ethBalances[2]"
            IndexAccess
               Type: uint256
               Source: "channel.initialDeposit[0]"
              MemberAccess to member initialDeposit
                 Type: uint256[2] storage ref
                 Source: "channel.initialDeposit"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            IndexAccess
               Type: uint256
               Source: "channel.ethBalances[2]"
              MemberAccess to member ethBalances
                 Type: uint256[4] storage ref
                 Source: "channel.ethBalances"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[3]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      VariableDeclarationStatement
         Gas costs: 746
         Source: "uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3]"
        VariableDeclaration "totalTokenDeposit"
           Type: uint256
           Source: "uint256 totalTokenDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3]"
          BinaryOperation using operator +
             Type: uint256
             Source: "channel.initialDeposit[1] + channel.erc20Balances[2]"
            IndexAccess
               Type: uint256
               Source: "channel.initialDeposit[1]"
              MemberAccess to member initialDeposit
                 Type: uint256[2] storage ref
                 Source: "channel.initialDeposit"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
            IndexAccess
               Type: uint256
               Source: "channel.erc20Balances[2]"
              MemberAccess to member erc20Balances
                 Type: uint256[4] storage ref
                 Source: "channel.erc20Balances"
                Identifier channel
                   Type: struct LedgerChannel.Channel storage pointer
                   Source: "channel"
              Literal, token: [no token] value: 2
                 Type: int_const 2
                 Source: "2"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[3]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 3
               Type: int_const 3
               Source: "3"
      VariableDeclarationStatement
         Gas costs: 499
         Source: "uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1]"
        VariableDeclaration "possibleTotalEthBeforeDeposit"
           Type: uint256
           Source: "uint256 possibleTotalEthBeforeDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "channel.ethBalances[0] + channel.ethBalances[1]"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[1]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      VariableDeclarationStatement
         Gas costs: 499
         Source: "uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1]"
        VariableDeclaration "possibleTotalTokenBeforeDeposit"
           Type: uint256
           Source: "uint256 possibleTotalTokenBeforeDeposit"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator +
           Type: uint256
           Source: "channel.erc20Balances[0] + channel.erc20Balances[1]"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
      IfStatement
         Source: "if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "possibleTotalEthBeforeDeposit < totalEthDeposit"
          Identifier possibleTotalEthBeforeDeposit
             Type: uint256
             Source: "possibleTotalEthBeforeDeposit"
          Identifier totalEthDeposit
             Type: uint256
             Source: "totalEthDeposit"
        Block
           Source: "{\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         }"
          ExpressionStatement
             Gas costs: 20515
             Source: "channel.ethBalances[0]+=channel.ethBalances[2]"
            Assignment using operator +=
               Type: uint256
               Source: "channel.ethBalances[0]+=channel.ethBalances[2]"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[0]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[2]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
          ExpressionStatement
             Gas costs: 20515
             Source: "channel.ethBalances[1]+=channel.ethBalances[3]"
            Assignment using operator +=
               Type: uint256
               Source: "channel.ethBalances[1]+=channel.ethBalances[3]"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[1]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "channel.ethBalances[3]"
                MemberAccess to member ethBalances
                   Type: uint256[4] storage ref
                   Source: "channel.ethBalances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
        Block
           Source: "{\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }"
          ExpressionStatement
             Gas costs: 35
             Source: "require(possibleTotalEthBeforeDeposit == totalEthDeposit)"
            FunctionCall
               Type: tuple()
               Source: "require(possibleTotalEthBeforeDeposit == totalEthDeposit)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "possibleTotalEthBeforeDeposit == totalEthDeposit"
                Identifier possibleTotalEthBeforeDeposit
                   Type: uint256
                   Source: "possibleTotalEthBeforeDeposit"
                Identifier totalEthDeposit
                   Type: uint256
                   Source: "totalEthDeposit"
      IfStatement
         Source: "if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "possibleTotalTokenBeforeDeposit < totalTokenDeposit"
          Identifier possibleTotalTokenBeforeDeposit
             Type: uint256
             Source: "possibleTotalTokenBeforeDeposit"
          Identifier totalTokenDeposit
             Type: uint256
             Source: "totalTokenDeposit"
        Block
           Source: "{\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         }"
          ExpressionStatement
             Gas costs: 20515
             Source: "channel.erc20Balances[0]+=channel.erc20Balances[2]"
            Assignment using operator +=
               Type: uint256
               Source: "channel.erc20Balances[0]+=channel.erc20Balances[2]"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[0]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 0
                   Type: int_const 0
                   Source: "0"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[2]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 2
                   Type: int_const 2
                   Source: "2"
          ExpressionStatement
             Gas costs: 20515
             Source: "channel.erc20Balances[1]+=channel.erc20Balances[3]"
            Assignment using operator +=
               Type: uint256
               Source: "channel.erc20Balances[1]+=channel.erc20Balances[3]"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[1]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 1
                   Type: int_const 1
                   Source: "1"
              IndexAccess
                 Type: uint256
                 Source: "channel.erc20Balances[3]"
                MemberAccess to member erc20Balances
                   Type: uint256[4] storage ref
                   Source: "channel.erc20Balances"
                  Identifier channel
                     Type: struct LedgerChannel.Channel storage pointer
                     Source: "channel"
                Literal, token: [no token] value: 3
                   Type: int_const 3
                   Source: "3"
        Block
           Source: "{\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }"
          ExpressionStatement
             Gas costs: 35
             Source: "require(possibleTotalTokenBeforeDeposit == totalTokenDeposit)"
            FunctionCall
               Type: tuple()
               Source: "require(possibleTotalTokenBeforeDeposit == totalTokenDeposit)"
              Identifier require
                 Type: function (bool) pure
                 Source: "require"
              BinaryOperation using operator ==
                 Type: bool
                 Source: "possibleTotalTokenBeforeDeposit == totalTokenDeposit"
                Identifier possibleTotalTokenBeforeDeposit
                   Type: uint256
                   Source: "possibleTotalTokenBeforeDeposit"
                Identifier totalTokenDeposit
                   Type: uint256
                   Source: "totalTokenDeposit"
      VariableDeclarationStatement
         Gas costs: 252
         Source: "uint256 ethbalanceA = channel.ethBalances[0]"
        VariableDeclaration "ethbalanceA"
           Type: uint256
           Source: "uint256 ethbalanceA"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "channel.ethBalances[0]"
          MemberAccess to member ethBalances
             Type: uint256[4] storage ref
             Source: "channel.ethBalances"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 252
         Source: "uint256 ethbalanceI = channel.ethBalances[1]"
        VariableDeclaration "ethbalanceI"
           Type: uint256
           Source: "uint256 ethbalanceI"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "channel.ethBalances[1]"
          MemberAccess to member ethBalances
             Type: uint256[4] storage ref
             Source: "channel.ethBalances"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      VariableDeclarationStatement
         Gas costs: 252
         Source: "uint256 tokenbalanceA = channel.erc20Balances[0]"
        VariableDeclaration "tokenbalanceA"
           Type: uint256
           Source: "uint256 tokenbalanceA"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "channel.erc20Balances[0]"
          MemberAccess to member erc20Balances
             Type: uint256[4] storage ref
             Source: "channel.erc20Balances"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: 252
         Source: "uint256 tokenbalanceI = channel.erc20Balances[1]"
        VariableDeclaration "tokenbalanceI"
           Type: uint256
           Source: "uint256 tokenbalanceI"
          ElementaryTypeName uint256
             Source: "uint256"
        IndexAccess
           Type: uint256
           Source: "channel.erc20Balances[1]"
          MemberAccess to member erc20Balances
             Type: uint256[4] storage ref
             Source: "channel.erc20Balances"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
      ExpressionStatement
         Gas costs: 20055
         Source: "channel.ethBalances[0] = 0"
        Assignment using operator =
           Type: uint256
           Source: "channel.ethBalances[0] = 0"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[0]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20055
         Source: "channel.ethBalances[1] = 0"
        Assignment using operator =
           Type: uint256
           Source: "channel.ethBalances[1] = 0"
          IndexAccess
             Type: uint256
             Source: "channel.ethBalances[1]"
            MemberAccess to member ethBalances
               Type: uint256[4] storage ref
               Source: "channel.ethBalances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20055
         Source: "channel.erc20Balances[0] = 0"
        Assignment using operator =
           Type: uint256
           Source: "channel.erc20Balances[0] = 0"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[0]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20055
         Source: "channel.erc20Balances[1] = 0"
        Assignment using operator =
           Type: uint256
           Source: "channel.erc20Balances[1] = 0"
          IndexAccess
             Type: uint256
             Source: "channel.erc20Balances[1]"
            MemberAccess to member erc20Balances
               Type: uint256[4] storage ref
               Source: "channel.erc20Balances"
              Identifier channel
                 Type: struct LedgerChannel.Channel storage pointer
                 Source: "channel"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      IfStatement
         Source: "if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 43
           Source: "ethbalanceA != 0 || ethbalanceI != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "ethbalanceA != 0"
            Identifier ethbalanceA
               Type: uint256
               Source: "ethbalanceA"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "ethbalanceI != 0"
            Identifier ethbalanceI
               Type: uint256
               Source: "ethbalanceI"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "channel.partyAddresses[0].transfer(ethbalanceA)"
            FunctionCall
               Type: tuple()
               Source: "channel.partyAddresses[0].transfer(ethbalanceA)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "channel.partyAddresses[0].transfer"
                IndexAccess
                   Type: address
                   Source: "channel.partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "channel.partyAddresses"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
              Identifier ethbalanceA
                 Type: uint256
                 Source: "ethbalanceA"
          ExpressionStatement
             Gas costs: [???]
             Source: "channel.partyAddresses[1].transfer(ethbalanceI)"
            FunctionCall
               Type: tuple()
               Source: "channel.partyAddresses[1].transfer(ethbalanceI)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "channel.partyAddresses[1].transfer"
                IndexAccess
                   Type: address
                   Source: "channel.partyAddresses[1]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "channel.partyAddresses"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier ethbalanceI
                 Type: uint256
                 Source: "ethbalanceI"
      IfStatement
         Source: "if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 43
           Source: "tokenbalanceA != 0 || tokenbalanceI != 0"
          BinaryOperation using operator !=
             Type: bool
             Source: "tokenbalanceA != 0"
            Identifier tokenbalanceA
               Type: uint256
               Source: "tokenbalanceA"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator !=
             Type: bool
             Source: "tokenbalanceI != 0"
            Identifier tokenbalanceI
               Type: uint256
               Source: "tokenbalanceI"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             )"
            FunctionCall
               Type: tuple()
               Source: "require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             )"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "channel.token.transfer(channel.partyAddresses[0], tokenbalanceA)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "channel.token.transfer"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "channel.token"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                IndexAccess
                   Type: address
                   Source: "channel.partyAddresses[0]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "channel.partyAddresses"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                Identifier tokenbalanceA
                   Type: uint256
                   Source: "tokenbalanceA"
              Literal, token: [no token] value: byzantineCloseChannel: token transfer failure
                 Type: literal_string "byzantineCloseChannel: token transfer failure"
                 Source: "\"byzantineCloseChannel: token transfer failure\""
          ExpressionStatement
             Gas costs: [???]
             Source: "require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             )"
            FunctionCall
               Type: tuple()
               Source: "require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             )"
              Identifier require
                 Type: function (bool,string memory) pure
                 Source: "require"
              FunctionCall
                 Type: bool
                 Source: "channel.token.transfer(channel.partyAddresses[1], tokenbalanceI)"
                MemberAccess to member transfer
                   Type: function (address,uint256) external returns (bool)
                   Source: "channel.token.transfer"
                  MemberAccess to member token
                     Type: contract HumanStandardToken
                     Source: "channel.token"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                IndexAccess
                   Type: address
                   Source: "channel.partyAddresses[1]"
                  MemberAccess to member partyAddresses
                     Type: address[2] storage ref
                     Source: "channel.partyAddresses"
                    Identifier channel
                       Type: struct LedgerChannel.Channel storage pointer
                       Source: "channel"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
                Identifier tokenbalanceI
                   Type: uint256
                   Source: "tokenbalanceI"
              Literal, token: [no token] value: byzantineCloseChannel: token transfer failure
                 Type: literal_string "byzantineCloseChannel: token transfer failure"
                 Source: "\"byzantineCloseChannel: token transfer failure\""
      ExpressionStatement
         Gas costs: 20273
         Source: "channel.isOpen = false"
        Assignment using operator =
           Type: bool
           Source: "channel.isOpen = false"
          MemberAccess to member isOpen
             Type: bool
             Source: "channel.isOpen"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20240
         Source: "numChannels--"
        UnaryOperation (postfix) --
           Type: uint256
           Source: "numChannels--"
          Identifier numChannels
             Type: uint256
             Source: "numChannels"
      EmitStatement
         Gas costs: [???]
         Source: "emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI)"
        FunctionCall
           Type: tuple()
           Source: "DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI)"
          Identifier DidLCClose
             Type: function (bytes32,uint256,uint256,uint256,uint256,uint256)
             Source: "DidLCClose"
          Identifier _lcID
             Type: bytes32
             Source: "_lcID"
          MemberAccess to member sequence
             Type: uint256
             Source: "channel.sequence"
            Identifier channel
               Type: struct LedgerChannel.Channel storage pointer
               Source: "channel"
          Identifier ethbalanceA
             Type: uint256
             Source: "ethbalanceA"
          Identifier ethbalanceI
             Type: uint256
             Source: "ethbalanceI"
          Identifier tokenbalanceA
             Type: uint256
             Source: "tokenbalanceA"
          Identifier tokenbalanceI
             Type: uint256
             Source: "tokenbalanceI"
  FunctionDefinition "_isContained"
     Source: "function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 _hash, bytes _proof, bytes32 _root)"
      VariableDeclaration "_hash"
         Type: bytes32
         Source: "bytes32 _hash"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration "_proof"
         Type: bytes memory
         Source: "bytes _proof"
        ElementaryTypeName bytes
           Source: "bytes"
      VariableDeclaration "_root"
         Type: bytes32
         Source: "bytes32 _root"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "bytes32 cursor = _hash"
        VariableDeclaration "cursor"
           Type: bytes32
           Source: "bytes32 cursor"
          ElementaryTypeName bytes32
             Source: "bytes32"
        Identifier _hash
           Type: bytes32
           Source: "_hash"
      VariableDeclarationStatement
         Gas costs: 3
         Source: "bytes32 proofElem"
        VariableDeclaration "proofElem"
           Type: bytes32
           Source: "bytes32 proofElem"
          ElementaryTypeName bytes32
             Source: "bytes32"
      ForStatement
         Source: "for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "uint256 i = 64"
          VariableDeclaration "i"
             Type: uint256
             Source: "uint256 i"
            ElementaryTypeName uint256
               Source: "uint256"
          Literal, token: [no token] value: 64
             Type: int_const 64
             Source: "64"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: [???]
           Source: "i <= _proof.length"
          Identifier i
             Type: uint256
             Source: "i"
          MemberAccess to member length
             Type: uint256
             Source: "_proof.length"
            Identifier _proof
               Type: bytes memory
               Source: "_proof"
        ExpressionStatement
           Gas costs: 14
           Source: "i += 32"
          Assignment using operator +=
             Type: uint256
             Source: "i += 32"
            Identifier i
               Type: uint256
               Source: "i"
            Literal, token: [no token] value: 32
               Type: int_const 32
               Source: "32"
        Block
           Source: "{\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }"
          InlineAssembly
             Gas costs: 0
             Source: "assembly { proofElem := mload(add(_proof, i)) }\n\n             if"
          IfStatement
             Source: "if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 27
               Source: "cursor < proofElem"
              Identifier cursor
                 Type: bytes32
                 Source: "cursor"
              Identifier proofElem
                 Type: bytes32
                 Source: "proofElem"
            Block
               Source: "{\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "cursor = keccak256(abi.encodePacked(cursor, proofElem))"
                Assignment using operator =
                   Type: bytes32
                   Source: "cursor = keccak256(abi.encodePacked(cursor, proofElem))"
                  Identifier cursor
                     Type: bytes32
                     Source: "cursor"
                  FunctionCall
                     Type: bytes32
                     Source: "keccak256(abi.encodePacked(cursor, proofElem))"
                    Identifier keccak256
                       Type: function () pure returns (bytes32)
                       Source: "keccak256"
                    FunctionCall
                       Type: bytes memory
                       Source: "abi.encodePacked(cursor, proofElem)"
                      MemberAccess to member encodePacked
                         Type: function () pure returns (bytes memory)
                         Source: "abi.encodePacked"
                        Identifier abi
                           Type: abi
                           Source: "abi"
                      Identifier cursor
                         Type: bytes32
                         Source: "cursor"
                      Identifier proofElem
                         Type: bytes32
                         Source: "proofElem"
            Block
               Source: "{\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }"
              ExpressionStatement
                 Gas costs: [???]
                 Source: "cursor = keccak256(abi.encodePacked(proofElem, cursor))"
                Assignment using operator =
                   Type: bytes32
                   Source: "cursor = keccak256(abi.encodePacked(proofElem, cursor))"
                  Identifier cursor
                     Type: bytes32
                     Source: "cursor"
                  FunctionCall
                     Type: bytes32
                     Source: "keccak256(abi.encodePacked(proofElem, cursor))"
                    Identifier keccak256
                       Type: function () pure returns (bytes32)
                       Source: "keccak256"
                    FunctionCall
                       Type: bytes memory
                       Source: "abi.encodePacked(proofElem, cursor)"
                      MemberAccess to member encodePacked
                         Type: function () pure returns (bytes memory)
                         Source: "abi.encodePacked"
                        Identifier abi
                           Type: abi
                           Source: "abi"
                      Identifier proofElem
                         Type: bytes32
                         Source: "proofElem"
                      Identifier cursor
                         Type: bytes32
                         Source: "cursor"
      Return
         Gas costs: 32
         Source: "return cursor == _root"
        BinaryOperation using operator ==
           Type: bool
           Source: "cursor == _root"
          Identifier cursor
             Type: bytes32
             Source: "cursor"
          Identifier _root
             Type: bytes32
             Source: "_root"
  FunctionDefinition "getChannel" - public - const
     Source: "function getChannel(bytes32 id) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 62
       Source: "(\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     )"
      VariableDeclaration ""
         Type: address[2] memory
         Source: "address[2]"
        ArrayTypeName
           Source: "address[2]"
          ElementaryTypeName address
             Source: "address"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration ""
         Type: uint256[4] memory
         Source: "uint256[4]"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration ""
         Type: uint256[4] memory
         Source: "uint256[4]"
        ArrayTypeName
           Source: "uint256[4]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 4
             Type unknown.
             Source: "4"
      VariableDeclaration ""
         Type: uint256[2] memory
         Source: "uint256[2]"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: bytes32
         Source: "bytes32"
        ElementaryTypeName bytes32
           Source: "bytes32"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "Channel memory channel = Channels[id]"
        VariableDeclaration "channel"
           Type: struct LedgerChannel.Channel memory
           Source: "Channel memory channel"
          UserDefinedTypeName "Channel"
             Source: "Channel"
        IndexAccess
           Type: struct LedgerChannel.Channel storage ref
           Source: "Channels[id]"
          Identifier Channels
             Type: mapping(bytes32 => struct LedgerChannel.Channel storage ref)
             Source: "Channels"
          Identifier id
             Type: bytes32
             Source: "id"
      Return
         Gas costs: [???]
         Source: "return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         )"
        TupleExpression
           Type: tuple(address[2] memory,uint256[4] memory,uint256[4] memory,uint256[2] memory,uint256,uint256,bytes32,uint256,uint256,bool,bool,uint256)
           Source: "(\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         )"
          MemberAccess to member partyAddresses
             Type: address[2] memory
             Source: "channel.partyAddresses"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member ethBalances
             Type: uint256[4] memory
             Source: "channel.ethBalances"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member erc20Balances
             Type: uint256[4] memory
             Source: "channel.erc20Balances"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member initialDeposit
             Type: uint256[2] memory
             Source: "channel.initialDeposit"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member sequence
             Type: uint256
             Source: "channel.sequence"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member confirmTime
             Type: uint256
             Source: "channel.confirmTime"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member VCrootHash
             Type: bytes32
             Source: "channel.VCrootHash"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member LCopenTimeout
             Type: uint256
             Source: "channel.LCopenTimeout"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member updateLCtimeout
             Type: uint256
             Source: "channel.updateLCtimeout"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member isOpen
             Type: bool
             Source: "channel.isOpen"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member isUpdateLCSettling
             Type: bool
             Source: "channel.isUpdateLCSettling"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
          MemberAccess to member numOpenVC
             Type: uint256
             Source: "channel.numOpenVC"
            Identifier channel
               Type: struct LedgerChannel.Channel memory
               Source: "channel"
  FunctionDefinition "getVirtualChannel" - public - const
     Source: "function getVirtualChannel(bytes32 id) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }"
    ParameterList
       Gas costs: 0
       Source: "(bytes32 id)"
      VariableDeclaration "id"
         Type: bytes32
         Source: "bytes32 id"
        ElementaryTypeName bytes32
           Source: "bytes32"
    ParameterList
       Gas costs: 58
       Source: "(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     )"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration ""
         Type: uint256[2] memory
         Source: "uint256[2]"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration ""
         Type: uint256[2] memory
         Source: "uint256[2]"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
      VariableDeclaration ""
         Type: uint256[2] memory
         Source: "uint256[2]"
        ArrayTypeName
           Source: "uint256[2]"
          ElementaryTypeName uint256
             Source: "uint256"
          Literal, token: [no token] value: 2
             Type unknown.
             Source: "2"
    Block
       Source: "{\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "VirtualChannel memory virtualChannel = virtualChannels[id]"
        VariableDeclaration "virtualChannel"
           Type: struct LedgerChannel.VirtualChannel memory
           Source: "VirtualChannel memory virtualChannel"
          UserDefinedTypeName "VirtualChannel"
             Source: "VirtualChannel"
        IndexAccess
           Type: struct LedgerChannel.VirtualChannel storage ref
           Source: "virtualChannels[id]"
          Identifier virtualChannels
             Type: mapping(bytes32 => struct LedgerChannel.VirtualChannel storage ref)
             Source: "virtualChannels"
          Identifier id
             Type: bytes32
             Source: "id"
      Return
         Gas costs: [???]
         Source: "return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         )"
        TupleExpression
           Type: tuple(bool,bool,uint256,address,uint256,address,address,address,uint256[2] memory,uint256[2] memory,uint256[2] memory)
           Source: "(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         )"
          MemberAccess to member isClose
             Type: bool
             Source: "virtualChannel.isClose"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member isInSettlementState
             Type: bool
             Source: "virtualChannel.isInSettlementState"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member sequence
             Type: uint256
             Source: "virtualChannel.sequence"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member challenger
             Type: address
             Source: "virtualChannel.challenger"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member updateVCtimeout
             Type: uint256
             Source: "virtualChannel.updateVCtimeout"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member partyA
             Type: address
             Source: "virtualChannel.partyA"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member partyB
             Type: address
             Source: "virtualChannel.partyB"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member partyI
             Type: address
             Source: "virtualChannel.partyI"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member ethBalances
             Type: uint256[2] memory
             Source: "virtualChannel.ethBalances"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member erc20Balances
             Type: uint256[2] memory
             Source: "virtualChannel.erc20Balances"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
          MemberAccess to member bond
             Type: uint256[2] memory
             Source: "virtualChannel.bond"
            Identifier virtualChannel
               Type: struct LedgerChannel.VirtualChannel memory
               Source: "virtualChannel"
