Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/smartbugs-21-7-13/reentrancy31/reentrancy_bonus.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "Reentrancy_bonus"
   Source: "contract Reentrancy_bonus{\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n    mapping (address => bool) private claimedBonus;\n    mapping (address => uint) private rewardsForA;\n\n    function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }\n\n    function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n        rewardsForA[recipient] += 100;\n        // <yes> <report> REENTRANCY\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }\n}"
  VariableDeclaration "userBalances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) private userBalances"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "claimedBonus"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping (address => bool) private claimedBonus"
    Mapping
       Source: "mapping (address => bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "rewardsForA"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) private rewardsForA"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  FunctionDefinition "withdrawReward" - public
     Source: "function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address recipient)"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }"
      VariableDeclarationStatement
         Gas costs: 307
         Source: "uint amountToWithdraw = rewardsForA[recipient]"
        VariableDeclaration "amountToWithdraw"
           Type: uint256
           Source: "uint amountToWithdraw"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "rewardsForA[recipient]"
          Identifier rewardsForA
             Type: mapping(address => uint256)
             Source: "rewardsForA"
          Identifier recipient
             Type: address
             Source: "recipient"
      ExpressionStatement
         Gas costs: 5104
         Source: "rewardsForA[recipient] = 0"
        Assignment using operator =
           Type: uint256
           Source: "rewardsForA[recipient] = 0"
          IndexAccess
             Type: uint256
             Source: "rewardsForA[recipient]"
            Identifier rewardsForA
               Type: mapping(address => uint256)
               Source: "rewardsForA"
            Identifier recipient
               Type: address
               Source: "recipient"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      VariableDeclarationStatement
         Gas costs: [???]
         Source: "(bool success, ) = recipient.call.value(amountToWithdraw)(\"\")"
        VariableDeclaration "success"
           Type: bool
           Source: "bool success"
          ElementaryTypeName bool
             Source: "bool"
        FunctionCall
           Type: bool
           Source: "recipient.call.value(amountToWithdraw)(\"\")"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "recipient.call.value(amountToWithdraw)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "recipient.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "recipient.call"
                Identifier recipient
                   Type: address
                   Source: "recipient"
            Identifier amountToWithdraw
               Type: uint256
               Source: "amountToWithdraw"
          Literal, token: [no token] value: 
             Type: literal_string ""
             Source: "\"\""
      ExpressionStatement
         Gas costs: 29
         Source: "require(success)"
        FunctionCall
           Type: tuple()
           Source: "require(success)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          Identifier success
             Type: bool
             Source: "success"
  FunctionDefinition "getFirstWithdrawalBonus" - public
     Source: "function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n        rewardsForA[recipient] += 100;\n        // <yes> <report> REENTRANCY\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address recipient)"
      VariableDeclaration "recipient"
         Type: address
         Source: "address recipient"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n        rewardsForA[recipient] += 100;\n        // <yes> <report> REENTRANCY\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }"
      ExpressionStatement
         Gas costs: 364
         Source: "require(!claimedBonus[recipient])"
        FunctionCall
           Type: tuple()
           Source: "require(!claimedBonus[recipient])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!claimedBonus[recipient]"
            IndexAccess
               Type: bool
               Source: "claimedBonus[recipient]"
              Identifier claimedBonus
                 Type: mapping(address => bool)
                 Source: "claimedBonus"
              Identifier recipient
                 Type: address
                 Source: "recipient"
      ExpressionStatement
         Gas costs: 20329
         Source: "rewardsForA[recipient] += 100"
        Assignment using operator +=
           Type: uint256
           Source: "rewardsForA[recipient] += 100"
          IndexAccess
             Type: uint256
             Source: "rewardsForA[recipient]"
            Identifier rewardsForA
               Type: mapping(address => uint256)
               Source: "rewardsForA"
            Identifier recipient
               Type: address
               Source: "recipient"
          Literal, token: [no token] value: 100
             Type: int_const 100
             Source: "100"
      ExpressionStatement
         Gas costs: 18
         Source: "withdrawReward(recipient)"
        FunctionCall
           Type: tuple()
           Source: "withdrawReward(recipient)"
          Identifier withdrawReward
             Type: function (address)
             Source: "withdrawReward"
          Identifier recipient
             Type: address
             Source: "recipient"
      ExpressionStatement
         Gas costs: 20363
         Source: "claimedBonus[recipient] = true"
        Assignment using operator =
           Type: bool
           Source: "claimedBonus[recipient] = true"
          IndexAccess
             Type: bool
             Source: "claimedBonus[recipient]"
            Identifier claimedBonus
               Type: mapping(address => bool)
               Source: "claimedBonus"
            Identifier recipient
               Type: address
               Source: "recipient"
          Literal, token: true value: true
             Type: bool
             Source: "true"
