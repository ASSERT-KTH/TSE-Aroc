Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/smartbugs-21-7-13/unAnalyzedUlls/king_of_the_ether_throne.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "KingOfTheEtherThrone"
   Source: "contract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}"
  StructDefinition "Monarch"
     Gas costs: 0
     Source: "struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }"
    VariableDeclaration "etherAddress"
       Type: address
       Source: "address etherAddress"
      ElementaryTypeName address
         Source: "address"
    VariableDeclaration "name"
       Type: string storage pointer
       Source: "string name"
      ElementaryTypeName string
         Source: "string"
    VariableDeclaration "claimPrice"
       Type: uint256
       Source: "uint claimPrice"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "coronationTimestamp"
       Type: uint256
       Source: "uint coronationTimestamp"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "wizardAddress"
     Type: address
     Gas costs: 0
     Source: "address wizardAddress"
    ElementaryTypeName address
       Source: "address"
  ModifierDefinition "onlywizard"
     Source: "modifier onlywizard { if (msg.sender == wizardAddress) _; }"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{ if (msg.sender == wizardAddress) _; }"
      IfStatement
         Source: "if (msg.sender == wizardAddress) _"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 512
           Source: "msg.sender == wizardAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier wizardAddress
             Type: address
             Source: "wizardAddress"
        PlaceholderStatement
           Gas costs: 0
           Source: "_"
  VariableDeclaration "startingClaimPrice"
     Type: uint256
     Gas costs: 0
     Source: "uint constant startingClaimPrice = 100 finney"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100000000000000000
       Source: "100 finney"
  VariableDeclaration "claimPriceAdjustNum"
     Type: uint256
     Gas costs: 3
     Source: "uint constant claimPriceAdjustNum = 3"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 3
       Type: int_const 3
       Source: "3"
  VariableDeclaration "claimPriceAdjustDen"
     Type: uint256
     Gas costs: 3
     Source: "uint constant claimPriceAdjustDen = 2"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 2
       Type: int_const 2
       Source: "2"
  VariableDeclaration "wizardCommissionFractionNum"
     Type: uint256
     Gas costs: 3
     Source: "uint constant wizardCommissionFractionNum = 1"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1
       Type: int_const 1
       Source: "1"
  VariableDeclaration "wizardCommissionFractionDen"
     Type: uint256
     Gas costs: 3
     Source: "uint constant wizardCommissionFractionDen = 100"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100
       Type: int_const 100
       Source: "100"
  VariableDeclaration "currentClaimPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint public currentClaimPrice"
    ElementaryTypeName uint
       Source: "uint"
  VariableDeclaration "currentMonarch"
     Type: struct KingOfTheEtherThrone.Monarch storage ref
     Gas costs: [???]
     Source: "Monarch public currentMonarch"
    UserDefinedTypeName "Monarch"
       Source: "Monarch"
  VariableDeclaration "pastMonarchs"
     Type: struct KingOfTheEtherThrone.Monarch storage ref[] storage ref
     Gas costs: [???]
     Source: "Monarch[] public pastMonarchs"
    ArrayTypeName
       Source: "Monarch[]"
      UserDefinedTypeName "Monarch"
         Source: "Monarch"
  FunctionDefinition "KingOfTheEtherThrone" - public
     Source: "function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "wizardAddress = msg.sender"
        Assignment using operator =
           Type: address
           Source: "wizardAddress = msg.sender"
          Identifier wizardAddress
             Type: address
             Source: "wizardAddress"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "currentClaimPrice = startingClaimPrice"
        Assignment using operator =
           Type: uint256
           Source: "currentClaimPrice = startingClaimPrice"
          Identifier currentClaimPrice
             Type: uint256
             Source: "currentClaimPrice"
          Identifier startingClaimPrice
             Type: uint256
             Source: "startingClaimPrice"
      ExpressionStatement
         Gas costs: 0
         Source: "currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        )"
        Assignment using operator =
           Type: struct KingOfTheEtherThrone.Monarch storage ref
           Source: "currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        )"
          Identifier currentMonarch
             Type: struct KingOfTheEtherThrone.Monarch storage ref
             Source: "currentMonarch"
          FunctionCall
             Type: struct KingOfTheEtherThrone.Monarch memory
             Source: "Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        )"
            Identifier Monarch
               Type: type(struct KingOfTheEtherThrone.Monarch storage pointer)
               Source: "Monarch"
            Identifier wizardAddress
               Type: address
               Source: "wizardAddress"
            Literal, token: [no token] value: [Vacant]
               Type: literal_string "[Vacant]"
               Source: "\"[Vacant]\""
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
            MemberAccess to member timestamp
               Type: uint256
               Source: "block.timestamp"
              Identifier block
                 Type: block
                 Source: "block"
  FunctionDefinition "numberOfMonarchs" - public - const
     Source: "function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint n)"
      VariableDeclaration "n"
         Type: uint256
         Source: "uint n"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n        return pastMonarchs.length;\n    }"
      Return
         Gas costs: 216
         Source: "return pastMonarchs.length"
        MemberAccess to member length
           Type: uint256
           Source: "pastMonarchs.length"
          Identifier pastMonarchs
             Type: struct KingOfTheEtherThrone.Monarch storage ref[] storage ref
             Source: "pastMonarchs"
  EventDefinition "ThroneClaimed"
     Gas costs: 0
     Source: "event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );"
    ParameterList
       Source: "(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    )"
      VariableDeclaration "usurperEtherAddress"
         Type: address
         Source: "address usurperEtherAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "usurperName"
         Type: string memory
         Source: "string usurperName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "newClaimPrice"
         Type: uint256
         Source: "uint newClaimPrice"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "" - public
     Source: "function() {\n        claimThrone(string(msg.data));\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        claimThrone(string(msg.data));\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "claimThrone(string(msg.data))"
        FunctionCall
           Type: tuple()
           Source: "claimThrone(string(msg.data))"
          Identifier claimThrone
             Type: function (string memory)
             Source: "claimThrone"
          FunctionCall
             Type: string calldata
             Source: "string(msg.data)"
            ElementaryTypeNameExpression string
               Type: type(string storage pointer)
               Source: "string"
            MemberAccess to member data
               Type: bytes calldata
               Source: "msg.data"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "claimThrone" - public
     Source: "function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(string name)"
      VariableDeclaration "name"
         Type: string memory
         Source: "string name"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "uint valuePaid = msg.value"
        VariableDeclaration "valuePaid"
           Type: uint256
           Source: "uint valuePaid"
          ElementaryTypeName uint
             Source: "uint"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      IfStatement
         Source: "if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 209
           Source: "valuePaid < currentClaimPrice"
          Identifier valuePaid
             Type: uint256
             Source: "valuePaid"
          Identifier currentClaimPrice
             Type: uint256
             Source: "currentClaimPrice"
        Block
           Source: "{\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.send(valuePaid)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(valuePaid)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier valuePaid
                 Type: uint256
                 Source: "valuePaid"
          Return
             Gas costs: 11
             Source: "return;"
      IfStatement
         Source: "if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 209
           Source: "valuePaid > currentClaimPrice"
          Identifier valuePaid
             Type: uint256
             Source: "valuePaid"
          Identifier currentClaimPrice
             Type: uint256
             Source: "currentClaimPrice"
        Block
           Source: "{\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }"
          VariableDeclarationStatement
             Gas costs: 217
             Source: "uint excessPaid = valuePaid - currentClaimPrice"
            VariableDeclaration "excessPaid"
               Type: uint256
               Source: "uint excessPaid"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator -
               Type: uint256
               Source: "valuePaid - currentClaimPrice"
              Identifier valuePaid
                 Type: uint256
                 Source: "valuePaid"
              Identifier currentClaimPrice
                 Type: uint256
                 Source: "currentClaimPrice"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.send(excessPaid)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(excessPaid)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier excessPaid
                 Type: uint256
                 Source: "excessPaid"
          ExpressionStatement
             Gas costs: 14
             Source: "valuePaid = valuePaid - excessPaid"
            Assignment using operator =
               Type: uint256
               Source: "valuePaid = valuePaid - excessPaid"
              Identifier valuePaid
                 Type: uint256
                 Source: "valuePaid"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "valuePaid - excessPaid"
                Identifier valuePaid
                   Type: uint256
                   Source: "valuePaid"
                Identifier excessPaid
                   Type: uint256
                   Source: "excessPaid"
      VariableDeclarationStatement
         Gas costs: 44
         Source: "uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen"
        VariableDeclaration "wizardCommission"
           Type: uint256
           Source: "uint wizardCommission"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "(valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen"
          TupleExpression
             Type: uint256
             Source: "(valuePaid * wizardCommissionFractionNum)"
            BinaryOperation using operator *
               Type: uint256
               Source: "valuePaid * wizardCommissionFractionNum"
              Identifier valuePaid
                 Type: uint256
                 Source: "valuePaid"
              Identifier wizardCommissionFractionNum
                 Type: uint256
                 Source: "wizardCommissionFractionNum"
          Identifier wizardCommissionFractionDen
             Type: uint256
             Source: "wizardCommissionFractionDen"
      VariableDeclarationStatement
         Gas costs: 17
         Source: "uint compensation = valuePaid - wizardCommission"
        VariableDeclaration "compensation"
           Type: uint256
           Source: "uint compensation"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "valuePaid - wizardCommission"
          Identifier valuePaid
             Type: uint256
             Source: "valuePaid"
          Identifier wizardCommission
             Type: uint256
             Source: "wizardCommission"
      IfStatement
         Source: "if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 502
           Source: "currentMonarch.etherAddress != wizardAddress"
          MemberAccess to member etherAddress
             Type: address
             Source: "currentMonarch.etherAddress"
            Identifier currentMonarch
               Type: struct KingOfTheEtherThrone.Monarch storage ref
               Source: "currentMonarch"
          Identifier wizardAddress
             Type: address
             Source: "wizardAddress"
        Block
           Source: "{\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "currentMonarch.etherAddress.send(compensation)"
            FunctionCall
               Type: bool
               Source: "currentMonarch.etherAddress.send(compensation)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "currentMonarch.etherAddress.send"
                MemberAccess to member etherAddress
                   Type: address
                   Source: "currentMonarch.etherAddress"
                  Identifier currentMonarch
                     Type: struct KingOfTheEtherThrone.Monarch storage ref
                     Source: "currentMonarch"
              Identifier compensation
                 Type: uint256
                 Source: "compensation"
        Block
           Gas costs: 0
           Source: "{\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }"
      ExpressionStatement
         Gas costs: 61354
         Source: "pastMonarchs.push(currentMonarch)"
        FunctionCall
           Type: uint256
           Source: "pastMonarchs.push(currentMonarch)"
          MemberAccess to member push
             Type: function (struct KingOfTheEtherThrone.Monarch storage ref) returns (uint256)
             Source: "pastMonarchs.push"
            Identifier pastMonarchs
               Type: struct KingOfTheEtherThrone.Monarch storage ref[] storage ref
               Source: "pastMonarchs"
          Identifier currentMonarch
             Type: struct KingOfTheEtherThrone.Monarch storage ref
             Source: "currentMonarch"
      ExpressionStatement
         Gas costs: [???]
         Source: "currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        )"
        Assignment using operator =
           Type: struct KingOfTheEtherThrone.Monarch storage ref
           Source: "currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        )"
          Identifier currentMonarch
             Type: struct KingOfTheEtherThrone.Monarch storage ref
             Source: "currentMonarch"
          FunctionCall
             Type: struct KingOfTheEtherThrone.Monarch memory
             Source: "Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        )"
            Identifier Monarch
               Type: type(struct KingOfTheEtherThrone.Monarch storage pointer)
               Source: "Monarch"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier name
               Type: string memory
               Source: "name"
            Identifier valuePaid
               Type: uint256
               Source: "valuePaid"
            MemberAccess to member timestamp
               Type: uint256
               Source: "block.timestamp"
              Identifier block
                 Type: block
                 Source: "block"
      VariableDeclarationStatement
         Gas costs: 244
         Source: "uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen"
        VariableDeclaration "rawNewClaimPrice"
           Type: uint256
           Source: "uint rawNewClaimPrice"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen"
          BinaryOperation using operator *
             Type: uint256
             Source: "currentClaimPrice * claimPriceAdjustNum"
            Identifier currentClaimPrice
               Type: uint256
               Source: "currentClaimPrice"
            Identifier claimPriceAdjustNum
               Type: uint256
               Source: "claimPriceAdjustNum"
          Identifier claimPriceAdjustDen
             Type: uint256
             Source: "claimPriceAdjustDen"
      IfStatement
         Source: "if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 9
           Source: "rawNewClaimPrice < 10 finney"
          Identifier rawNewClaimPrice
             Type: uint256
             Source: "rawNewClaimPrice"
          Literal, token: [no token] value: 10
             Type: int_const 10000000000000000
             Source: "10 finney"
        Block
           Source: "{\n            currentClaimPrice = rawNewClaimPrice;\n        }"
          ExpressionStatement
             Gas costs: 20014
             Source: "currentClaimPrice = rawNewClaimPrice"
            Assignment using operator =
               Type: uint256
               Source: "currentClaimPrice = rawNewClaimPrice"
              Identifier currentClaimPrice
                 Type: uint256
                 Source: "currentClaimPrice"
              Identifier rawNewClaimPrice
                 Type: uint256
                 Source: "rawNewClaimPrice"
        IfStatement
           Source: "if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
          BinaryOperation using operator <
             Type: bool
             Gas costs: 9
             Source: "rawNewClaimPrice < 100 finney"
            Identifier rawNewClaimPrice
               Type: uint256
               Source: "rawNewClaimPrice"
            Literal, token: [no token] value: 100
               Type: int_const 100000000000000000
               Source: "100 finney"
          Block
             Source: "{\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        }"
            ExpressionStatement
               Gas costs: 20053
               Source: "currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo)"
              Assignment using operator =
                 Type: uint256
                 Source: "currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo)"
                Identifier currentClaimPrice
                   Type: uint256
                   Source: "currentClaimPrice"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "100 szabo * (rawNewClaimPrice / 100 szabo)"
                  Literal, token: [no token] value: 100
                     Type: int_const 100000000000000
                     Source: "100 szabo"
                  TupleExpression
                     Type: uint256
                     Source: "(rawNewClaimPrice / 100 szabo)"
                    BinaryOperation using operator /
                       Type: uint256
                       Source: "rawNewClaimPrice / 100 szabo"
                      Identifier rawNewClaimPrice
                         Type: uint256
                         Source: "rawNewClaimPrice"
                      Literal, token: [no token] value: 100
                         Type: int_const 100000000000000
                         Source: "100 szabo"
          IfStatement
             Source: "if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
            BinaryOperation using operator <
               Type: bool
               Gas costs: 9
               Source: "rawNewClaimPrice < 1 ether"
              Identifier rawNewClaimPrice
                 Type: uint256
                 Source: "rawNewClaimPrice"
              Literal, token: [no token] value: 1
                 Type: int_const 1000000000000000000
                 Source: "1 ether"
            Block
               Source: "{\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        }"
              ExpressionStatement
                 Gas costs: 20053
                 Source: "currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney)"
                Assignment using operator =
                   Type: uint256
                   Source: "currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney)"
                  Identifier currentClaimPrice
                     Type: uint256
                     Source: "currentClaimPrice"
                  BinaryOperation using operator *
                     Type: uint256
                     Source: "1 finney * (rawNewClaimPrice / 1 finney)"
                    Literal, token: [no token] value: 1
                       Type: int_const 1000000000000000
                       Source: "1 finney"
                    TupleExpression
                       Type: uint256
                       Source: "(rawNewClaimPrice / 1 finney)"
                      BinaryOperation using operator /
                         Type: uint256
                         Source: "rawNewClaimPrice / 1 finney"
                        Identifier rawNewClaimPrice
                           Type: uint256
                           Source: "rawNewClaimPrice"
                        Literal, token: [no token] value: 1
                           Type: int_const 1000000000000000
                           Source: "1 finney"
            IfStatement
               Source: "if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
              BinaryOperation using operator <
                 Type: bool
                 Gas costs: 9
                 Source: "rawNewClaimPrice < 10 ether"
                Identifier rawNewClaimPrice
                   Type: uint256
                   Source: "rawNewClaimPrice"
                Literal, token: [no token] value: 10
                   Type: int_const 10000000000000000000
                   Source: "10 ether"
              Block
                 Source: "{\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        }"
                ExpressionStatement
                   Gas costs: 20053
                   Source: "currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney)"
                  Assignment using operator =
                     Type: uint256
                     Source: "currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney)"
                    Identifier currentClaimPrice
                       Type: uint256
                       Source: "currentClaimPrice"
                    BinaryOperation using operator *
                       Type: uint256
                       Source: "10 finney * (rawNewClaimPrice / 10 finney)"
                      Literal, token: [no token] value: 10
                         Type: int_const 10000000000000000
                         Source: "10 finney"
                      TupleExpression
                         Type: uint256
                         Source: "(rawNewClaimPrice / 10 finney)"
                        BinaryOperation using operator /
                           Type: uint256
                           Source: "rawNewClaimPrice / 10 finney"
                          Identifier rawNewClaimPrice
                             Type: uint256
                             Source: "rawNewClaimPrice"
                          Literal, token: [no token] value: 10
                             Type: int_const 10000000000000000
                             Source: "10 finney"
              IfStatement
                 Source: "if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
                BinaryOperation using operator <
                   Type: bool
                   Gas costs: 9
                   Source: "rawNewClaimPrice < 100 ether"
                  Identifier rawNewClaimPrice
                     Type: uint256
                     Source: "rawNewClaimPrice"
                  Literal, token: [no token] value: 100
                     Type: int_const 100000000000000000000
                     Source: "100 ether"
                Block
                   Source: "{\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        }"
                  ExpressionStatement
                     Gas costs: 20053
                     Source: "currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney)"
                    Assignment using operator =
                       Type: uint256
                       Source: "currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney)"
                      Identifier currentClaimPrice
                         Type: uint256
                         Source: "currentClaimPrice"
                      BinaryOperation using operator *
                         Type: uint256
                         Source: "100 finney * (rawNewClaimPrice / 100 finney)"
                        Literal, token: [no token] value: 100
                           Type: int_const 100000000000000000
                           Source: "100 finney"
                        TupleExpression
                           Type: uint256
                           Source: "(rawNewClaimPrice / 100 finney)"
                          BinaryOperation using operator /
                             Type: uint256
                             Source: "rawNewClaimPrice / 100 finney"
                            Identifier rawNewClaimPrice
                               Type: uint256
                               Source: "rawNewClaimPrice"
                            Literal, token: [no token] value: 100
                               Type: int_const 100000000000000000
                               Source: "100 finney"
                IfStatement
                   Source: "if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
                  BinaryOperation using operator <
                     Type: bool
                     Gas costs: 9
                     Source: "rawNewClaimPrice < 1000 ether"
                    Identifier rawNewClaimPrice
                       Type: uint256
                       Source: "rawNewClaimPrice"
                    Literal, token: [no token] value: 1000
                       Type: int_const 1000000000000000000000
                       Source: "1000 ether"
                  Block
                     Source: "{\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        }"
                    ExpressionStatement
                       Gas costs: 20053
                       Source: "currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether)"
                      Assignment using operator =
                         Type: uint256
                         Source: "currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether)"
                        Identifier currentClaimPrice
                           Type: uint256
                           Source: "currentClaimPrice"
                        BinaryOperation using operator *
                           Type: uint256
                           Source: "1 ether * (rawNewClaimPrice / 1 ether)"
                          Literal, token: [no token] value: 1
                             Type: int_const 1000000000000000000
                             Source: "1 ether"
                          TupleExpression
                             Type: uint256
                             Source: "(rawNewClaimPrice / 1 ether)"
                            BinaryOperation using operator /
                               Type: uint256
                               Source: "rawNewClaimPrice / 1 ether"
                              Identifier rawNewClaimPrice
                                 Type: uint256
                                 Source: "rawNewClaimPrice"
                              Literal, token: [no token] value: 1
                                 Type: int_const 1000000000000000000
                                 Source: "1 ether"
                  IfStatement
                     Source: "if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }"
                    BinaryOperation using operator <
                       Type: bool
                       Gas costs: 9
                       Source: "rawNewClaimPrice < 10000 ether"
                      Identifier rawNewClaimPrice
                         Type: uint256
                         Source: "rawNewClaimPrice"
                      Literal, token: [no token] value: 10000
                         Type: int_const 10000000000000000000000
                         Source: "10000 ether"
                    Block
                       Source: "{\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        }"
                      ExpressionStatement
                         Gas costs: 20053
                         Source: "currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether)"
                        Assignment using operator =
                           Type: uint256
                           Source: "currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether)"
                          Identifier currentClaimPrice
                             Type: uint256
                             Source: "currentClaimPrice"
                          BinaryOperation using operator *
                             Type: uint256
                             Source: "10 ether * (rawNewClaimPrice / 10 ether)"
                            Literal, token: [no token] value: 10
                               Type: int_const 10000000000000000000
                               Source: "10 ether"
                            TupleExpression
                               Type: uint256
                               Source: "(rawNewClaimPrice / 10 ether)"
                              BinaryOperation using operator /
                                 Type: uint256
                                 Source: "rawNewClaimPrice / 10 ether"
                                Identifier rawNewClaimPrice
                                   Type: uint256
                                   Source: "rawNewClaimPrice"
                                Literal, token: [no token] value: 10
                                   Type: int_const 10000000000000000000
                                   Source: "10 ether"
                    Block
                       Source: "{\n            currentClaimPrice = rawNewClaimPrice;\n        }"
                      ExpressionStatement
                         Gas costs: 20014
                         Source: "currentClaimPrice = rawNewClaimPrice"
                        Assignment using operator =
                           Type: uint256
                           Source: "currentClaimPrice = rawNewClaimPrice"
                          Identifier currentClaimPrice
                             Type: uint256
                             Source: "currentClaimPrice"
                          Identifier rawNewClaimPrice
                             Type: uint256
                             Source: "rawNewClaimPrice"
      ExpressionStatement
         Gas costs: [???]
         Source: "ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice)"
        FunctionCall
           Type: tuple()
           Source: "ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice)"
          Identifier ThroneClaimed
             Type: function (address,string memory,uint256)
             Source: "ThroneClaimed"
          MemberAccess to member etherAddress
             Type: address
             Source: "currentMonarch.etherAddress"
            Identifier currentMonarch
               Type: struct KingOfTheEtherThrone.Monarch storage ref
               Source: "currentMonarch"
          MemberAccess to member name
             Type: string storage ref
             Source: "currentMonarch.name"
            Identifier currentMonarch
               Type: struct KingOfTheEtherThrone.Monarch storage ref
               Source: "currentMonarch"
          Identifier currentClaimPrice
             Type: uint256
             Source: "currentClaimPrice"
  FunctionDefinition "sweepCommission" - public
     Source: "function sweepCommission(uint amount) onlywizard {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlywizard"
       Gas costs: 0
       Source: "onlywizard"
      Identifier onlywizard
         Type: modifier ()
         Source: "onlywizard"
    Block
       Source: "{\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "wizardAddress.send(amount)"
        FunctionCall
           Type: bool
           Source: "wizardAddress.send(amount)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "wizardAddress.send"
            Identifier wizardAddress
               Type: address
               Source: "wizardAddress"
          Identifier amount
             Type: uint256
             Source: "amount"
  FunctionDefinition "transferOwnership" - public
     Source: "function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address newOwner)"
      VariableDeclaration "newOwner"
         Type: address
         Source: "address newOwner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlywizard"
       Gas costs: 0
       Source: "onlywizard"
      Identifier onlywizard
         Type: modifier ()
         Source: "onlywizard"
    Block
       Source: "{\n        wizardAddress = newOwner;\n    }"
      ExpressionStatement
         Gas costs: 20267
         Source: "wizardAddress = newOwner"
        Assignment using operator =
           Type: address
           Source: "wizardAddress = newOwner"
          Identifier wizardAddress
             Type: address
             Source: "wizardAddress"
          Identifier newOwner
             Type: address
             Source: "newOwner"
