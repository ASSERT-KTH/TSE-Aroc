Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/smartbugs-21-7-13/unAnalyzedUlls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.11;"
ContractDefinition "tokenRecipient"
   Gas costs: 0
   Source: "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }"
  FunctionDefinition "receiveApproval" - public
     Source: "function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public;"
    ParameterList
       Source: "(address _from, uint256 _value, address _token, bytes _extraData)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_token"
         Type: address
         Source: "address _token"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Source: ""
ContractDefinition "MigrationAgent"
   Gas costs: 0
   Source: "contract MigrationAgent {\r\n    function migrateFrom(address _from, uint256 _value);\r\n}"
  FunctionDefinition "migrateFrom" - public
     Source: "function migrateFrom(address _from, uint256 _value);"
    ParameterList
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Source: ""
ContractDefinition "ERC20"
   Gas costs: 0
   Source: "contract ERC20 {\r\n  uint public totalSupply;\r\n  function balanceOf(address who) constant returns (uint);\r\n  function allowance(address owner, address spender) constant returns (uint);\r\n\r\n  function transfer(address to, uint value) returns (bool ok);\r\n  function transferFrom(address from, address to, uint value) returns (bool ok);\r\n  function approve(address spender, uint value) returns (bool ok);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n}"
  VariableDeclaration "totalSupply"
     Type: uint256
     Source: "uint public totalSupply"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address who) constant returns (uint);"
    ParameterList
       Source: "(address who)"
      VariableDeclaration "who"
         Type: address
         Source: "address who"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address owner, address spender) constant returns (uint);"
    ParameterList
       Source: "(address owner, address spender)"
      VariableDeclaration "owner"
         Type: address
         Source: "address owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address to, uint value)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address from, address to, uint value) returns (bool ok);"
    ParameterList
       Source: "(address from, address to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  FunctionDefinition "approve" - public
     Source: "function approve(address spender, uint value) returns (bool ok);"
    ParameterList
       Source: "(address spender, uint value)"
      VariableDeclaration "spender"
         Type: address
         Source: "address spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Source: "(bool ok)"
      VariableDeclaration "ok"
         Type: bool
         Source: "bool ok"
        ElementaryTypeName bool
           Source: "bool"
  EventDefinition "Transfer"
     Source: "event Transfer(address indexed from, address indexed to, uint value);"
    ParameterList
       Source: "(address indexed from, address indexed to, uint value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "to"
         Type: address
         Source: "address indexed to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
  EventDefinition "Approval"
     Source: "event Approval(address indexed owner, address indexed spender, uint value);"
    ParameterList
       Source: "(address indexed owner, address indexed spender, uint value)"
      VariableDeclaration "owner"
         Type: address
         Source: "address indexed owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "spender"
         Type: address
         Source: "address indexed spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint value"
        ElementaryTypeName uint
           Source: "uint"
ContractDefinition "SafeMath"
   Source: "contract SafeMath {\r\n  function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}"
  FunctionDefinition "safeMul"
     Source: "function safeMul(uint a, uint b) internal returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a * b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator *
           Type: uint256
           Source: "a * b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == 0 || c / a == b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == 0 || c / a == b)"
          Identifier assert
             Type: function (bool)
             Source: "assert"
          BinaryOperation using operator ||
             Type: bool
             Source: "a == 0 || c / a == b"
            BinaryOperation using operator ==
               Type: bool
               Source: "a == 0"
              Identifier a
                 Type: uint256
                 Source: "a"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
            BinaryOperation using operator ==
               Type: bool
               Source: "c / a == b"
              BinaryOperation using operator /
                 Type: uint256
                 Source: "c / a"
                Identifier c
                   Type: uint256
                   Source: "c"
                Identifier a
                   Type: uint256
                   Source: "a"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeDiv"
     Source: "function safeDiv(uint a, uint b) internal returns (uint) {\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b > 0);\r\n    uint c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b > 0)"
        FunctionCall
           Type: tuple()
           Source: "assert(b > 0)"
          Identifier assert
             Type: function (bool)
             Source: "assert"
          BinaryOperation using operator >
             Type: bool
             Source: "b > 0"
            Identifier b
               Type: uint256
               Source: "b"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a / b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator /
           Type: uint256
           Source: "a / b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(a == b * c + a % b)"
        FunctionCall
           Type: tuple()
           Source: "assert(a == b * c + a % b)"
          Identifier assert
             Type: function (bool)
             Source: "assert"
          BinaryOperation using operator ==
             Type: bool
             Source: "a == b * c + a % b"
            Identifier a
               Type: uint256
               Source: "a"
            BinaryOperation using operator +
               Type: uint256
               Source: "b * c + a % b"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "b * c"
                Identifier b
                   Type: uint256
                   Source: "b"
                Identifier c
                   Type: uint256
                   Source: "c"
              BinaryOperation using operator %
                 Type: uint256
                 Source: "a % b"
                Identifier a
                   Type: uint256
                   Source: "a"
                Identifier b
                   Type: uint256
                   Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "safeSub"
     Source: "function safeSub(uint a, uint b) internal returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    assert(b <= a);\r\n    return a - b;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(b <= a)"
        FunctionCall
           Type: tuple()
           Source: "assert(b <= a)"
          Identifier assert
             Type: function (bool)
             Source: "assert"
          BinaryOperation using operator <=
             Type: bool
             Source: "b <= a"
            Identifier b
               Type: uint256
               Source: "b"
            Identifier a
               Type: uint256
               Source: "a"
      Return
         Gas costs: 0
         Source: "return a - b"
        BinaryOperation using operator -
           Type: uint256
           Source: "a - b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "safeAdd"
     Source: "function safeAdd(uint a, uint b) internal returns (uint) {\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint a, uint b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint a"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint b"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    uint c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint c = a + b"
        VariableDeclaration "c"
           Type: uint256
           Source: "uint c"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator +
           Type: uint256
           Source: "a + b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
      ExpressionStatement
         Gas costs: 0
         Source: "assert(c>=a && c>=b)"
        FunctionCall
           Type: tuple()
           Source: "assert(c>=a && c>=b)"
          Identifier assert
             Type: function (bool)
             Source: "assert"
          BinaryOperation using operator &&
             Type: bool
             Source: "c>=a && c>=b"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=a"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier a
                 Type: uint256
                 Source: "a"
            BinaryOperation using operator >=
               Type: bool
               Source: "c>=b"
              Identifier c
                 Type: uint256
                 Source: "c"
              Identifier b
                 Type: uint256
                 Source: "b"
      Return
         Gas costs: 0
         Source: "return c"
        Identifier c
           Type: uint256
           Source: "c"
  FunctionDefinition "max64" - const
     Source: "function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint64
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "min64" - const
     Source: "function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint64 a, uint64 b)"
      VariableDeclaration "a"
         Type: uint64
         Source: "uint64 a"
        ElementaryTypeName uint64
           Source: "uint64"
      VariableDeclaration "b"
         Type: uint64
         Source: "uint64 b"
        ElementaryTypeName uint64
           Source: "uint64"
    ParameterList
       Gas costs: 0
       Source: "(uint64)"
      VariableDeclaration ""
         Type: uint64
         Source: "uint64"
        ElementaryTypeName uint64
           Source: "uint64"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint64
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint64
               Source: "a"
            Identifier b
               Type: uint64
               Source: "b"
          Identifier a
             Type: uint64
             Source: "a"
          Identifier b
             Type: uint64
             Source: "b"
  FunctionDefinition "max256" - const
     Source: "function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a >= b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a >= b ? a : b"
        Conditional
           Type: uint256
           Source: "a >= b ? a : b"
          BinaryOperation using operator >=
             Type: bool
             Source: "a >= b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "min256" - const
     Source: "function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    return a < b ? a : b;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 a, uint256 b)"
      VariableDeclaration "a"
         Type: uint256
         Source: "uint256 a"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "b"
         Type: uint256
         Source: "uint256 b"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return a < b ? a : b;\r\n  }"
      Return
         Gas costs: 0
         Source: "return a < b ? a : b"
        Conditional
           Type: uint256
           Source: "a < b ? a : b"
          BinaryOperation using operator <
             Type: bool
             Source: "a < b"
            Identifier a
               Type: uint256
               Source: "a"
            Identifier b
               Type: uint256
               Source: "b"
          Identifier a
             Type: uint256
             Source: "a"
          Identifier b
             Type: uint256
             Source: "b"
  FunctionDefinition "assert"
     Source: "function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(bool assertion)"
      VariableDeclaration "assertion"
         Type: bool
         Source: "bool assertion"
        ElementaryTypeName bool
           Source: "bool"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }"
      IfStatement
         Source: "if (!assertion) {\r\n      throw;\r\n    }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 0
           Source: "!assertion"
          Identifier assertion
             Type: bool
             Source: "assertion"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 0
             Source: "throw"
ContractDefinition "StandardToken"
   Source: "contract StandardToken is ERC20, SafeMath {\r\n\r\n  /* Token supply got increased and a new owner received these tokens */\r\n  event Minted(address receiver, uint amount);\r\n\r\n  /* Actual balances of token holders */\r\n  mapping(address => uint) balances;\r\n  // what exaclt ether was sent\r\n  mapping(address => uint) balancesRAW;\r\n  /* approve() allowances */\r\n  mapping (address => mapping (address => uint)) allowed;\r\n\r\n  /* Interface declaration */\r\n  function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }\r\n\r\n  function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  \r\n  \r\n}"
  InheritanceSpecifier
     Gas costs: 0
     Source: "ERC20"
    UserDefinedTypeName "ERC20"
       Source: "ERC20"
  InheritanceSpecifier
     Gas costs: 0
     Source: "SafeMath"
    UserDefinedTypeName "SafeMath"
       Source: "SafeMath"
  EventDefinition "Minted"
     Gas costs: 0
     Source: "event Minted(address receiver, uint amount);"
    ParameterList
       Source: "(address receiver, uint amount)"
      VariableDeclaration "receiver"
         Type: address
         Source: "address receiver"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) balances"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "balancesRAW"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping(address => uint) balancesRAW"
    Mapping
       Source: "mapping(address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  FunctionDefinition "isToken" - public - const
     Source: "function isToken() public constant returns (bool weAre) {\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: "(bool weAre)"
      VariableDeclaration "weAre"
         Type: bool
         Source: "bool weAre"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    return true;\r\n  }"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint _value) returns (bool success) {\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[msg.sender] = safeSub(balances[msg.sender], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[msg.sender], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = safeAdd(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to], _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(msg.sender, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(msg.sender, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint _value) returns (bool success) {\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    uint _allowance = allowed[_from][msg.sender];\r\n\r\n    balances[_to] = safeAdd(balances[_to], _value);\r\n    balances[_from] = safeSub(balances[_from], _value);\r\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }"
      VariableDeclarationStatement
         Gas costs: 0
         Source: "uint _allowance = allowed[_from][msg.sender]"
        VariableDeclaration "_allowance"
           Type: uint256
           Source: "uint _allowance"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "allowed[_from][msg.sender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_from]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _from
               Type: address
               Source: "_from"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_to] = safeAdd(balances[_to], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_to] = safeAdd(balances[_to], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_to]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _to
               Type: address
               Source: "_to"
          FunctionCall
             Type: uint256
             Source: "safeAdd(balances[_to], _value)"
            Identifier safeAdd
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeAdd"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "balances[_from] = safeSub(balances[_from], _value)"
        Assignment using operator =
           Type: uint256
           Source: "balances[_from] = safeSub(balances[_from], _value)"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          FunctionCall
             Type: uint256
             Source: "safeSub(balances[_from], _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[_from][msg.sender] = safeSub(_allowance, _value)"
        Assignment using operator =
           Type: uint256
           Source: "allowed[_from][msg.sender] = safeSub(_allowance, _value)"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          FunctionCall
             Type: uint256
             Source: "safeSub(_allowance, _value)"
            Identifier safeSub
               Type: function (uint256,uint256) returns (uint256)
               Source: "safeSub"
            Identifier _allowance
               Type: uint256
               Source: "_allowance"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Transfer(_from, _to, _value)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(_from, _to, _value)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _to
             Type: address
             Source: "_to"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint balance"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 0
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint _value) returns (bool success) {\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint _value"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n\r\n    // To change the approve amount you first have to reduce the addresses`\r\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n    //  already 0 to mitigate the race condition described here:\r\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\r\n\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      IfStatement
         Source: "if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 0
           Source: "(_value != 0) && (allowed[msg.sender][_spender] != 0)"
          TupleExpression
             Type: bool
             Source: "(_value != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "_value != 0"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          TupleExpression
             Type: bool
             Source: "(allowed[msg.sender][_spender] != 0)"
            BinaryOperation using operator !=
               Type: bool
               Source: "allowed[msg.sender][_spender] != 0"
              IndexAccess
                 Type: uint256
                 Source: "allowed[msg.sender][_spender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[msg.sender]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                Identifier _spender
                   Type: address
                   Source: "_spender"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
        Throw
           Gas costs: 0
           Source: "throw"
      ExpressionStatement
         Gas costs: 0
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 0
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 0
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: "(uint remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint remaining"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 0
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
ContractDefinition "daoPOLSKAtokens"
   Source: "contract daoPOLSKAtokens{\r\n\r\n    string public name = \"DAO POLSKA TOKEN version 1\";\r\n    string public symbol = \"DPL\";\r\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\r\n\r\n    // Receives \r\n    address public owner;\r\n    address public migrationMaster;\t\r\n    // The current total token supply.\r\n\r\n    uint256 public otherchainstotalsupply =1.0 ether;\r\n    uint256 public supplylimit      = 10000.0 ether;\r\n\t//totalSupply   \r\n   uint256 public  totalSupply      = 0.0 ether;\r\n\t//chains:\r\n\taddress public Chain1 = 0x0;\r\n\taddress public Chain2 = 0x0;\r\n\taddress public Chain3 = 0x0;\r\n\taddress public Chain4 = 0x0;\r\n\r\n\taddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\r\n    uint256 public totalMigrated;\r\n\r\n\r\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\r\n    event Refund(address indexed _from, uint256 _value);\r\n\r\n\t\r\n\tstruct sendTokenAway{\r\n\t\tStandardToken coinContract;\r\n\t\tuint amount;\r\n\t\taddress recipient;\r\n\t}\r\n\tmapping(uint => sendTokenAway) transfers;\r\n\tuint numTransfers=0;\r\n\t\r\n  mapping (address => uint256) balances;\r\nmapping (address => uint256) balancesRAW;\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n\tevent UpdatedTokenInformation(string newName, string newSymbol);\t\r\n \r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent receivedEther(address indexed _from,uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n      // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n  //tokenCreationCap\r\n  bool public supplylimitset = false;\r\n  bool public otherchainstotalset = false;\r\n   \r\n  function daoPOLSKAtokens() {\r\nowner=msg.sender;\r\nmigrationMaster=msg.sender;\r\n}\r\n\r\nfunction  setSupply(uint256 supplyLOCKER) public {\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\tsupplylimitset = true;\r\n  \r\n\tsupplylimit = supplyLOCKER ** uint256(decimals);\r\n//balances[owner]=supplylimit;\r\n  } \r\nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\r\n\totherchainstotalset = true;\r\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\r\n\t\r\n  } \r\n    /**\r\n     * Set allowance for other address and notify\r\n     *\r\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\r\n     *\r\n     * @param _spender The address authorized to spend\r\n     * @param _value the max amount they can spend\r\n     * @param _extraData some extra information to send to the approved contract\r\n     */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens from other account\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\r\n     *\r\n     * @param _from the address of the sender\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }\r\n  \r\n  function transfer(address _to, uint256 _value) returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }\r\n\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n\r\n\t\r\n\t    function () payable  public {\r\n\t\t if(funding){ \r\n        receivedEther(msg.sender, msg.value);\r\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\r\n\t\t} else throw;\r\n\t\t\r\n    }\r\n   \r\n\r\n\r\n\r\n\t\r\n  function setTokenInformation(string _name, string _symbol) {\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tname = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }\r\n\r\nfunction setChainsAddresses(address chainAd, int chainnumber) {\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tif(chainnumber==1){Chain1=chainAd;}\r\n\tif(chainnumber==2){Chain2=chainAd;}\r\n\tif(chainnumber==3){Chain3=chainAd;}\r\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\r\n  } \r\n\r\n  function DAOPolskaTokenICOregulations() external returns(string wow) {\r\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\r\n}\r\n// if accidentally other token was donated to Project Dev\r\n\r\n\r\n\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\r\n\t\tif (msg.sender != owner) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\tsendTokenAway t = transfers[numTransfers];\r\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\r\n\t\tt.amount = amount;\r\n\t\tt.recipient = receiver;\r\n\t\tt.coinContract.transfer(receiver, amount);\r\n\t\tnumTransfers++;\r\n\t}\r\n\r\n     // Crowdfunding:\r\nuint public tokenCreationRate=1000;\r\nuint public bonusCreationRate=1000;\r\nuint public CreationRate=1761;\r\n   uint256 public constant oneweek = 36000;\r\nuint256 public fundingEndBlock = 5433616;\r\nbool public funding = true;\r\nbool public refundstate = false;\r\nbool public migratestate= false;\r\n        function createDaoPOLSKAtokens(address holder) payable {\r\n\r\n        if (!funding) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n\t\t// check the maximum token creation cap\r\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\r\n          throw;\r\n\t\t\r\n\t\t//bonus structure\r\n// in early stage there is about 100% more details in ico regulations on website\r\n// price and converstion rate in tabled to PLN not ether, and is updated daily\r\n\r\n\r\n\r\n\t var numTokensRAW = msg.value;\r\n\r\n        var numTokens = msg.value * CreationRate;\r\n        totalSupply += numTokens;\r\n\r\n        // Assign new tokens to the sender\r\n        balances[holder] += numTokens;\r\n        balancesRAW[holder] += numTokensRAW;\r\n        // Log token creation event\r\n        Transfer(0, holder, numTokens);\r\n\t\t\r\n\t\t// Create additional Dao Tokens for the community and developers around 12%\r\n        uint256 percentOfTotal = 12;\r\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\r\n\r\n        totalSupply += additionalTokens;\r\n\r\n        balances[migrationMaster] += additionalTokens;\r\n        Transfer(0, migrationMaster, additionalTokens);\r\n\t\r\n\t}\r\n\tfunction setBonusCreationRate(uint newRate){\r\n\tif(msg.sender == owner) {\r\n\tbonusCreationRate=newRate;\r\n\tCreationRate=tokenCreationRate+bonusCreationRate;\r\n\t}\r\n\t}\r\n\r\n    function FundsTransfer() external {\r\n\tif(funding==true) throw;\r\n\t\t \tif (!owner.send(this.balance)) throw;\r\n    }\r\n\t\r\n    function PartialFundsTransfer(uint SubX) external {\r\n\t      if (msg.sender != owner) throw;\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n        owner.send(this.balance - SubX);\r\n\t}\r\n\tfunction turnrefund() external {\r\n\t      if (msg.sender != owner) throw;\r\n\trefundstate=!refundstate;\r\n        }\r\n\t\t\r\n\t\t\tfunction fundingState() external {\r\n\t      if (msg.sender != owner) throw;\r\n\tfunding=!funding;\r\n        }\r\n    function turnmigrate() external {\r\n\t      if (msg.sender != migrationMaster) throw;\r\n\tmigratestate=!migratestate;\r\n}\r\n\r\n    // notice Finalize crowdfunding clossing funding options\r\n\t\r\nfunction finalize() external {\r\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\r\n        // Switch to Operational state. This is the only place this can happen.\r\n        funding = false;\t\r\n\t\trefundstate=!refundstate;\r\n        // Transfer ETH to theDAO Polska Token network Storage address.\r\n        if (msg.sender==owner)\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n\t\towner.send(this.balance);\r\n    }\r\n    function migrate(uint256 _value) external {\r\n        // Abort if not in Operational Migration state.\r\n        if (migratestate) throw;\r\n\r\n\r\n        // Validate input value.\r\n        if (_value == 0) throw;\r\n        if (_value > balances[msg.sender]) throw;\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }\r\n\t\r\nfunction refundTRA() external {\r\n        // Abort if not in Funding Failure state.\r\n        if (funding) throw;\r\n        if (!refundstate) throw;\r\n\r\n        var DAOPLTokenValue = balances[msg.sender];\r\n        var ETHValue = balancesRAW[msg.sender];\r\n        if (ETHValue == 0) throw;\r\n        balancesRAW[msg.sender] = 0;\r\n        totalSupply -= DAOPLTokenValue;\r\n         \r\n        Refund(msg.sender, ETHValue);\r\n        msg.sender.transfer(ETHValue);\r\n}\r\n\r\nfunction preICOregulations() external returns(string wow) {\r\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\r\n}\r\n\r\n\r\n}"
  VariableDeclaration "name"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public name = \"DAO POLSKA TOKEN version 1\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: DAO POLSKA TOKEN version 1
       Type: literal_string "DAO POLSKA TOKEN version 1"
       Source: "\"DAO POLSKA TOKEN version 1\""
  VariableDeclaration "symbol"
     Type: string storage ref
     Gas costs: [???]
     Source: "string public symbol = \"DPL\""
    ElementaryTypeName string
       Source: "string"
    Literal, token: [no token] value: DPL
       Type: literal_string "DPL"
       Source: "\"DPL\""
  VariableDeclaration "decimals"
     Type: uint8
     Gas costs: [???]
     Source: "uint8 public constant decimals = 18"
    ElementaryTypeName uint8
       Source: "uint8"
    Literal, token: [no token] value: 18
       Type: int_const 18
       Source: "18"
  VariableDeclaration "owner"
     Type: address
     Gas costs: [???]
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "migrationMaster"
     Type: address
     Gas costs: [???]
     Source: "address public migrationMaster"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "otherchainstotalsupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public otherchainstotalsupply =1.0 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1.0
       Type: int_const 1000000000000000000
       Source: "1.0 ether"
  VariableDeclaration "supplylimit"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public supplylimit      = 10000.0 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 10000.0
       Type: int_const 10000000000000000000000
       Source: "10000.0 ether"
  VariableDeclaration "totalSupply"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public  totalSupply      = 0.0 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 0.0
       Type: int_const 0
       Source: "0.0 ether"
  VariableDeclaration "Chain1"
     Type: address
     Gas costs: [???]
     Source: "address public Chain1 = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "Chain2"
     Type: address
     Gas costs: [???]
     Source: "address public Chain2 = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "Chain3"
     Type: address
     Gas costs: [???]
     Source: "address public Chain3 = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "Chain4"
     Type: address
     Gas costs: [???]
     Source: "address public Chain4 = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "migrationAgent"
     Type: address
     Gas costs: [???]
     Source: "address public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2
       Type: address
       Source: "0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2"
  VariableDeclaration "totalMigrated"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public totalMigrated"
    ElementaryTypeName uint256
       Source: "uint256"
  EventDefinition "Migrate"
     Gas costs: 0
     Source: "event Migrate(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Refund"
     Gas costs: 0
     Source: "event Refund(address indexed _from, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  StructDefinition "sendTokenAway"
     Gas costs: 0
     Source: "struct sendTokenAway{\r\n\t\tStandardToken coinContract;\r\n\t\tuint amount;\r\n\t\taddress recipient;\r\n\t}"
    VariableDeclaration "coinContract"
       Type: contract StandardToken
       Source: "StandardToken coinContract"
      UserDefinedTypeName "StandardToken"
         Source: "StandardToken"
    VariableDeclaration "amount"
       Type: uint256
       Source: "uint amount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "recipient"
       Type: address
       Source: "address recipient"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "transfers"
     Type: mapping(uint256 => struct daoPOLSKAtokens.sendTokenAway storage ref)
     Gas costs: 0
     Source: "mapping(uint => sendTokenAway) transfers"
    Mapping
       Source: "mapping(uint => sendTokenAway)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "sendTokenAway"
         Source: "sendTokenAway"
  VariableDeclaration "numTransfers"
     Type: uint256
     Gas costs: 0
     Source: "uint numTransfers=0"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 0
       Type: int_const 0
       Source: "0"
  VariableDeclaration "balances"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balances"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "balancesRAW"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint256) balancesRAW"
    Mapping
       Source: "mapping (address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "allowed"
     Type: mapping(address => mapping(address => uint256))
     Gas costs: 0
     Source: "mapping (address => mapping (address => uint256)) allowed"
    Mapping
       Source: "mapping (address => mapping (address => uint256))"
      ElementaryTypeName address
         Source: "address"
      Mapping
         Source: "mapping (address => uint256)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "UpdatedTokenInformation"
     Gas costs: 0
     Source: "event UpdatedTokenInformation(string newName, string newSymbol);"
    ParameterList
       Source: "(string newName, string newSymbol)"
      VariableDeclaration "newName"
         Type: string memory
         Source: "string newName"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "newSymbol"
         Type: string memory
         Source: "string newSymbol"
        ElementaryTypeName string
           Source: "string"
  EventDefinition "Transfer"
     Gas costs: 0
     Source: "event Transfer(address indexed _from, address indexed _to, uint256 _value);"
    ParameterList
       Source: "(address indexed _from, address indexed _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address indexed _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "receivedEther"
     Gas costs: 0
     Source: "event receivedEther(address indexed _from,uint256 _value);"
    ParameterList
       Source: "(address indexed _from,uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address indexed _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Approval"
     Gas costs: 0
     Source: "event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
    ParameterList
       Source: "(address indexed _owner, address indexed _spender, uint256 _value)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address indexed _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address indexed _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
  EventDefinition "Burn"
     Gas costs: 0
     Source: "event Burn(address indexed from, uint256 value);"
    ParameterList
       Source: "(address indexed from, uint256 value)"
      VariableDeclaration "from"
         Type: address
         Source: "address indexed from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "value"
         Type: uint256
         Source: "uint256 value"
        ElementaryTypeName uint256
           Source: "uint256"
  VariableDeclaration "supplylimitset"
     Type: bool
     Gas costs: [???]
     Source: "bool public supplylimitset = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "otherchainstotalset"
     Type: bool
     Gas costs: [???]
     Source: "bool public otherchainstotalset = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  FunctionDefinition "daoPOLSKAtokens" - public
     Source: "function daoPOLSKAtokens() {\r\nowner=msg.sender;\r\nmigrationMaster=msg.sender;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\nowner=msg.sender;\r\nmigrationMaster=msg.sender;\r\n}"
      ExpressionStatement
         Gas costs: 0
         Source: "owner=msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner=msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 0
         Source: "migrationMaster=msg.sender"
        Assignment using operator =
           Type: address
           Source: "migrationMaster=msg.sender"
          Identifier migrationMaster
             Type: address
             Source: "migrationMaster"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "setSupply" - public
     Source: "function  setSupply(uint256 supplyLOCKER) public {\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\tsupplylimitset = true;\r\n  \r\n\tsupplylimit = supplyLOCKER ** uint256(decimals);\r\n//balances[owner]=supplylimit;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 supplyLOCKER)"
      VariableDeclaration "supplyLOCKER"
         Type: uint256
         Source: "uint256 supplyLOCKER"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\tsupplylimitset = true;\r\n  \r\n\tsupplylimit = supplyLOCKER ** uint256(decimals);\r\n//balances[owner]=supplylimit;\r\n  }"
      IfStatement
         Source: "if (msg.sender != owner) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if (supplylimitset != false) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 260
           Source: "supplylimitset != false"
          Identifier supplylimitset
             Type: bool
             Source: "supplylimitset"
          Literal, token: false value: false
             Type: bool
             Source: "false"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      ExpressionStatement
         Gas costs: 20267
         Source: "supplylimitset = true"
        Assignment using operator =
           Type: bool
           Source: "supplylimitset = true"
          Identifier supplylimitset
             Type: bool
             Source: "supplylimitset"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20080
         Source: "supplylimit = supplyLOCKER ** uint256(decimals)"
        Assignment using operator =
           Type: uint256
           Source: "supplylimit = supplyLOCKER ** uint256(decimals)"
          Identifier supplylimit
             Type: uint256
             Source: "supplylimit"
          BinaryOperation using operator **
             Type: uint256
             Source: "supplyLOCKER ** uint256(decimals)"
            Identifier supplyLOCKER
               Type: uint256
               Source: "supplyLOCKER"
            FunctionCall
               Type: uint256
               Source: "uint256(decimals)"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              Identifier decimals
                 Type: uint8
                 Source: "decimals"
  FunctionDefinition "setotherchainstotalsupply" - public
     Source: "function setotherchainstotalsupply(uint256 supplyLOCKER) public {\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\r\n\totherchainstotalset = true;\r\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\r\n\t\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 supplyLOCKER)"
      VariableDeclaration "supplyLOCKER"
         Type: uint256
         Source: "uint256 supplyLOCKER"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\t    \t   if (supplylimitset != false) {\r\n      throw;\r\n    }\r\n\r\n\totherchainstotalset = true;\r\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\r\n\t\r\n  }"
      IfStatement
         Source: "if (msg.sender != owner) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if (supplylimitset != false) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 260
           Source: "supplylimitset != false"
          Identifier supplylimitset
             Type: bool
             Source: "supplylimitset"
          Literal, token: false value: false
             Type: bool
             Source: "false"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      ExpressionStatement
         Gas costs: 20317
         Source: "otherchainstotalset = true"
        Assignment using operator =
           Type: bool
           Source: "otherchainstotalset = true"
          Identifier otherchainstotalset
             Type: bool
             Source: "otherchainstotalset"
          Literal, token: true value: true
             Type: bool
             Source: "true"
      ExpressionStatement
         Gas costs: 20080
         Source: "otherchainstotalsupply = supplyLOCKER ** uint256(decimals)"
        Assignment using operator =
           Type: uint256
           Source: "otherchainstotalsupply = supplyLOCKER ** uint256(decimals)"
          Identifier otherchainstotalsupply
             Type: uint256
             Source: "otherchainstotalsupply"
          BinaryOperation using operator **
             Type: uint256
             Source: "supplyLOCKER ** uint256(decimals)"
            Identifier supplyLOCKER
               Type: uint256
               Source: "supplyLOCKER"
            FunctionCall
               Type: uint256
               Source: "uint256(decimals)"
              ElementaryTypeNameExpression uint256
                 Type: type(uint256)
                 Source: "uint256"
              Identifier decimals
                 Type: uint8
                 Source: "decimals"
  FunctionDefinition "approveAndCall" - public
     Source: "function approveAndCall(address _spender, uint256 _value, bytes _extraData)\r\n        public\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value, bytes _extraData)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_extraData"
         Type: bytes memory
         Source: "bytes _extraData"
        ElementaryTypeName bytes
           Source: "bytes"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "tokenRecipient spender = tokenRecipient(_spender)"
        VariableDeclaration "spender"
           Type: contract tokenRecipient
           Source: "tokenRecipient spender"
          UserDefinedTypeName "tokenRecipient"
             Source: "tokenRecipient"
        FunctionCall
           Type: contract tokenRecipient
           Source: "tokenRecipient(_spender)"
          Identifier tokenRecipient
             Type: type(contract tokenRecipient)
             Source: "tokenRecipient"
          Identifier _spender
             Type: address
             Source: "_spender"
      IfStatement
         Source: "if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
        FunctionCall
           Type: bool
           Gas costs: 21
           Source: "approve(_spender, _value)"
          Identifier approve
             Type: function (address,uint256) returns (bool)
             Source: "approve"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
        Block
           Source: "{\r\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: [???]
             Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
            FunctionCall
               Type: tuple()
               Source: "spender.receiveApproval(msg.sender, _value, this, _extraData)"
              MemberAccess to member receiveApproval
                 Type: function (address,uint256,address,bytes memory) external
                 Source: "spender.receiveApproval"
                Identifier spender
                   Type: contract tokenRecipient
                   Source: "spender"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
              Identifier this
                 Type: contract daoPOLSKAtokens
                 Source: "this"
              Identifier _extraData
                 Type: bytes memory
                 Source: "_extraData"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "burn" - public
     Source: "function burn(uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\r\n        balances[msg.sender] -= _value;            // Subtract from the sender\r\n        totalSupply -= _value;                      // Updates totalSupply\r\n        Burn(msg.sender, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balances[msg.sender] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[msg.sender] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(msg.sender, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "burnFrom" - public
     Source: "function burnFrom(address _from, uint256 _value) public returns (bool success) {\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\r\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\r\n        balances[_from] -= _value;                         // Subtract from the targeted balance\r\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\r\n        totalSupply -= _value;                              // Update totalSupply\r\n        Burn(_from, _value);\r\n        return true;\r\n    }"
      ExpressionStatement
         Gas costs: 334
         Source: "require(balances[_from] >= _value)"
        FunctionCall
           Type: tuple()
           Source: "require(balances[_from] >= _value)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[_from] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[_from]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _from
                 Type: address
                 Source: "_from"
            Identifier _value
               Type: uint256
               Source: "_value"
      ExpressionStatement
         Gas costs: 423
         Source: "require(_value <= allowed[_from][msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(_value <= allowed[_from][msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator <=
             Type: bool
             Source: "_value <= allowed[_from][msg.sender]"
            Identifier _value
               Type: uint256
               Source: "_value"
            IndexAccess
               Type: uint256
               Source: "allowed[_from][msg.sender]"
              IndexAccess
                 Type: mapping(address => uint256)
                 Source: "allowed[_from]"
                Identifier allowed
                   Type: mapping(address => mapping(address => uint256))
                   Source: "allowed"
                Identifier _from
                   Type: address
                   Source: "_from"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[_from] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[_from] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[_from]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier _from
               Type: address
               Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20412
         Source: "allowed[_from][msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "allowed[_from][msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "allowed[_from][msg.sender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[_from]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              Identifier _from
                 Type: address
                 Source: "_from"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Burn(_from, _value)"
        FunctionCall
           Type: tuple()
           Source: "Burn(_from, _value)"
          Identifier Burn
             Type: function (address,uint256)
             Source: "Burn"
          Identifier _from
             Type: address
             Source: "_from"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "transfer" - public
     Source: "function transfer(address _to, uint256 _value) returns (bool success) {\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _to, uint256 _value)"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    //Default assumes totalSupply can't be over max (2^256 - 1).\r\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n    //Replace the if with this one instead.\r\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }"
      IfStatement
         Source: "if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 930
           Source: "balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]"
          BinaryOperation using operator >=
             Type: bool
             Source: "balances[msg.sender] >= _value"
            IndexAccess
               Type: uint256
               Source: "balances[msg.sender]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _value
               Type: uint256
               Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_to] + _value > balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
        Block
           Source: "{\r\n    //if (balances[msg.sender] >= _value && _value > 0) {\r\n      balances[msg.sender] -= _value;\r\n      balances[_to] += _value;\r\n      Transfer(msg.sender, _to, _value);\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20328
             Source: "balances[msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(msg.sender, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(msg.sender, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "transferFrom" - public
     Source: "function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _from, address _to, uint256 _value)"
      VariableDeclaration "_from"
         Type: address
         Source: "address _from"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_to"
         Type: address
         Source: "address _to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }\r\n  }"
      IfStatement
         Source: "if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    } else { return false; }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 1350
           Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]"
          BinaryOperation using operator &&
             Type: bool
             Source: "balances[_from] >= _value && allowed[_from][msg.sender] >= _value"
            BinaryOperation using operator >=
               Type: bool
               Source: "balances[_from] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            BinaryOperation using operator >=
               Type: bool
               Source: "allowed[_from][msg.sender] >= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          BinaryOperation using operator >
             Type: bool
             Source: "balances[_to] + _value > balances[_to]"
            BinaryOperation using operator +
               Type: uint256
               Source: "balances[_to] + _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
            IndexAccess
               Type: uint256
               Source: "balances[_to]"
              Identifier balances
                 Type: mapping(address => uint256)
                 Source: "balances"
              Identifier _to
                 Type: address
                 Source: "_to"
        Block
           Source: "{\r\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\r\n      balances[_to] += _value;\r\n      balances[_from] -= _value;\r\n      allowed[_from][msg.sender] -= _value;\r\n      Transfer(_from, _to, _value);\r\n      return true;\r\n    }"
          ExpressionStatement
             Gas costs: 20329
             Source: "balances[_to] += _value"
            Assignment using operator +=
               Type: uint256
               Source: "balances[_to] += _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_to]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _to
                   Type: address
                   Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20323
             Source: "balances[_from] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "balances[_from] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "balances[_from]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                Identifier _from
                   Type: address
                   Source: "_from"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: 20412
             Source: "allowed[_from][msg.sender] -= _value"
            Assignment using operator -=
               Type: uint256
               Source: "allowed[_from][msg.sender] -= _value"
              IndexAccess
                 Type: uint256
                 Source: "allowed[_from][msg.sender]"
                IndexAccess
                   Type: mapping(address => uint256)
                   Source: "allowed[_from]"
                  Identifier allowed
                     Type: mapping(address => mapping(address => uint256))
                     Source: "allowed"
                  Identifier _from
                     Type: address
                     Source: "_from"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          ExpressionStatement
             Gas costs: [???]
             Source: "Transfer(_from, _to, _value)"
            FunctionCall
               Type: tuple()
               Source: "Transfer(_from, _to, _value)"
              Identifier Transfer
                 Type: function (address,address,uint256)
                 Source: "Transfer"
              Identifier _from
                 Type: address
                 Source: "_from"
              Identifier _to
                 Type: address
                 Source: "_to"
              Identifier _value
                 Type: uint256
                 Source: "_value"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{ return false; }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "balanceOf" - public - const
     Source: "function balanceOf(address _owner) constant returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 balance)"
      VariableDeclaration "balance"
         Type: uint256
         Source: "uint256 balance"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return balances[_owner];\r\n  }"
      Return
         Gas costs: 304
         Source: "return balances[_owner]"
        IndexAccess
           Type: uint256
           Source: "balances[_owner]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          Identifier _owner
             Type: address
             Source: "_owner"
  FunctionDefinition "approve" - public
     Source: "function approve(address _spender, uint256 _value) returns (bool success) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _spender, uint256 _value)"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(bool success)"
      VariableDeclaration "success"
         Type: bool
         Source: "bool success"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }"
      ExpressionStatement
         Gas costs: 20199
         Source: "allowed[msg.sender][_spender] = _value"
        Assignment using operator =
           Type: uint256
           Source: "allowed[msg.sender][_spender] = _value"
          IndexAccess
             Type: uint256
             Source: "allowed[msg.sender][_spender]"
            IndexAccess
               Type: mapping(address => uint256)
               Source: "allowed[msg.sender]"
              Identifier allowed
                 Type: mapping(address => mapping(address => uint256))
                 Source: "allowed"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier _spender
               Type: address
               Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Approval(msg.sender, _spender, _value)"
        FunctionCall
           Type: tuple()
           Source: "Approval(msg.sender, _spender, _value)"
          Identifier Approval
             Type: function (address,address,uint256)
             Source: "Approval"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _spender
             Type: address
             Source: "_spender"
          Identifier _value
             Type: uint256
             Source: "_value"
      Return
         Gas costs: 8
         Source: "return true"
        Literal, token: true value: true
           Type: bool
           Source: "true"
  FunctionDefinition "allowance" - public - const
     Source: "function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return allowed[_owner][_spender];\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address _owner, address _spender)"
      VariableDeclaration "_owner"
         Type: address
         Source: "address _owner"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "_spender"
         Type: address
         Source: "address _spender"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint256 remaining)"
      VariableDeclaration "remaining"
         Type: uint256
         Source: "uint256 remaining"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n    return allowed[_owner][_spender];\r\n  }"
      Return
         Gas costs: 394
         Source: "return allowed[_owner][_spender]"
        IndexAccess
           Type: uint256
           Source: "allowed[_owner][_spender]"
          IndexAccess
             Type: mapping(address => uint256)
             Source: "allowed[_owner]"
            Identifier allowed
               Type: mapping(address => mapping(address => uint256))
               Source: "allowed"
            Identifier _owner
               Type: address
               Source: "_owner"
          Identifier _spender
             Type: address
             Source: "_spender"
  FunctionDefinition "" - public
     Source: "function () payable  public {\r\n\t\t if(funding){ \r\n        receivedEther(msg.sender, msg.value);\r\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\r\n\t\t} else throw;\r\n\t\t\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\t if(funding){ \r\n        receivedEther(msg.sender, msg.value);\r\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\r\n\t\t} else throw;\r\n\t\t\r\n    }"
      IfStatement
         Source: "if(funding){ \r\n        receivedEther(msg.sender, msg.value);\r\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\r\n\t\t} else throw"
        Identifier funding
           Type: bool
           Gas costs: 239
           Source: "funding"
        Block
           Source: "{ \r\n        receivedEther(msg.sender, msg.value);\r\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\r\n\t\t}"
          ExpressionStatement
             Gas costs: [???]
             Source: "receivedEther(msg.sender, msg.value)"
            FunctionCall
               Type: tuple()
               Source: "receivedEther(msg.sender, msg.value)"
              Identifier receivedEther
                 Type: function (address,uint256)
                 Source: "receivedEther"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
          ExpressionStatement
             Gas costs: 20397
             Source: "balances[msg.sender]=balances[msg.sender]+msg.value"
            Assignment using operator =
               Type: uint256
               Source: "balances[msg.sender]=balances[msg.sender]+msg.value"
              IndexAccess
                 Type: uint256
                 Source: "balances[msg.sender]"
                Identifier balances
                   Type: mapping(address => uint256)
                   Source: "balances"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "balances[msg.sender]+msg.value"
                IndexAccess
                   Type: uint256
                   Source: "balances[msg.sender]"
                  Identifier balances
                     Type: mapping(address => uint256)
                     Source: "balances"
                  MemberAccess to member sender
                     Type: address
                     Source: "msg.sender"
                    Identifier msg
                       Type: msg
                       Source: "msg"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
  FunctionDefinition "setTokenInformation" - public
     Source: "function setTokenInformation(string _name, string _symbol) {\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tname = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(string _name, string _symbol)"
      VariableDeclaration "_name"
         Type: string memory
         Source: "string _name"
        ElementaryTypeName string
           Source: "string"
      VariableDeclaration "_symbol"
         Type: string memory
         Source: "string _symbol"
        ElementaryTypeName string
           Source: "string"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tname = _name;\r\n    symbol = _symbol;\r\n\r\n    UpdatedTokenInformation(name, symbol);\r\n  }"
      IfStatement
         Source: "if (msg.sender != owner) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      ExpressionStatement
         Gas costs: [???]
         Source: "name = _name"
        Assignment using operator =
           Type: string storage ref
           Source: "name = _name"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier _name
             Type: string memory
             Source: "_name"
      ExpressionStatement
         Gas costs: [???]
         Source: "symbol = _symbol"
        Assignment using operator =
           Type: string storage ref
           Source: "symbol = _symbol"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
          Identifier _symbol
             Type: string memory
             Source: "_symbol"
      ExpressionStatement
         Gas costs: [???]
         Source: "UpdatedTokenInformation(name, symbol)"
        FunctionCall
           Type: tuple()
           Source: "UpdatedTokenInformation(name, symbol)"
          Identifier UpdatedTokenInformation
             Type: function (string memory,string memory)
             Source: "UpdatedTokenInformation"
          Identifier name
             Type: string storage ref
             Source: "name"
          Identifier symbol
             Type: string storage ref
             Source: "symbol"
  FunctionDefinition "setChainsAddresses" - public
     Source: "function setChainsAddresses(address chainAd, int chainnumber) {\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tif(chainnumber==1){Chain1=chainAd;}\r\n\tif(chainnumber==2){Chain2=chainAd;}\r\n\tif(chainnumber==3){Chain3=chainAd;}\r\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\r\n  }"
    ParameterList
       Gas costs: 0
       Source: "(address chainAd, int chainnumber)"
      VariableDeclaration "chainAd"
         Type: address
         Source: "address chainAd"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "chainnumber"
         Type: int256
         Source: "int chainnumber"
        ElementaryTypeName int
           Source: "int"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    \r\n\t   if (msg.sender != owner) {\r\n      throw;\r\n    }\r\n\tif(chainnumber==1){Chain1=chainAd;}\r\n\tif(chainnumber==2){Chain2=chainAd;}\r\n\tif(chainnumber==3){Chain3=chainAd;}\r\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\r\n  }"
      IfStatement
         Source: "if (msg.sender != owner) {\r\n      throw;\r\n    }"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n      throw;\r\n    }"
          Throw
             Gas costs: 6
             Source: "throw"
      IfStatement
         Source: "if(chainnumber==1){Chain1=chainAd;}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "chainnumber==1"
          Identifier chainnumber
             Type: int256
             Source: "chainnumber"
          Literal, token: [no token] value: 1
             Type: int_const 1
             Source: "1"
        Block
           Source: "{Chain1=chainAd;}"
          ExpressionStatement
             Gas costs: 20267
             Source: "Chain1=chainAd"
            Assignment using operator =
               Type: address
               Source: "Chain1=chainAd"
              Identifier Chain1
                 Type: address
                 Source: "Chain1"
              Identifier chainAd
                 Type: address
                 Source: "chainAd"
      IfStatement
         Source: "if(chainnumber==2){Chain2=chainAd;}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "chainnumber==2"
          Identifier chainnumber
             Type: int256
             Source: "chainnumber"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
        Block
           Source: "{Chain2=chainAd;}"
          ExpressionStatement
             Gas costs: 20267
             Source: "Chain2=chainAd"
            Assignment using operator =
               Type: address
               Source: "Chain2=chainAd"
              Identifier Chain2
                 Type: address
                 Source: "Chain2"
              Identifier chainAd
                 Type: address
                 Source: "chainAd"
      IfStatement
         Source: "if(chainnumber==3){Chain3=chainAd;}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "chainnumber==3"
          Identifier chainnumber
             Type: int256
             Source: "chainnumber"
          Literal, token: [no token] value: 3
             Type: int_const 3
             Source: "3"
        Block
           Source: "{Chain3=chainAd;}"
          ExpressionStatement
             Gas costs: 20267
             Source: "Chain3=chainAd"
            Assignment using operator =
               Type: address
               Source: "Chain3=chainAd"
              Identifier Chain3
                 Type: address
                 Source: "Chain3"
              Identifier chainAd
                 Type: address
                 Source: "chainAd"
      IfStatement
         Source: "if(chainnumber==4){Chain4=chainAd;}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "chainnumber==4"
          Identifier chainnumber
             Type: int256
             Source: "chainnumber"
          Literal, token: [no token] value: 4
             Type: int_const 4
             Source: "4"
        Block
           Source: "{Chain4=chainAd;}"
          ExpressionStatement
             Gas costs: 20267
             Source: "Chain4=chainAd"
            Assignment using operator =
               Type: address
               Source: "Chain4=chainAd"
              Identifier Chain4
                 Type: address
                 Source: "Chain4"
              Identifier chainAd
                 Type: address
                 Source: "chainAd"
  FunctionDefinition "DAOPolskaTokenICOregulations" - public
     Source: "function DAOPolskaTokenICOregulations() external returns(string wow) {\r\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string wow)"
      VariableDeclaration "wow"
         Type: string memory
         Source: "string wow"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\r\n}"
      Return
         Gas costs: [???]
         Source: "return 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules'"
        Literal, token: [no token] value: Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules
           Type: literal_string "Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules"
           Source: "'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules'"
  FunctionDefinition "sendTokenAw" - public
     Source: "function sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\r\n\t\tif (msg.sender != owner) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\tsendTokenAway t = transfers[numTransfers];\r\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\r\n\t\tt.amount = amount;\r\n\t\tt.recipient = receiver;\r\n\t\tt.coinContract.transfer(receiver, amount);\r\n\t\tnumTransfers++;\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address StandardTokenAddress, address receiver, uint amount)"
      VariableDeclaration "StandardTokenAddress"
         Type: address
         Source: "address StandardTokenAddress"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "receiver"
         Type: address
         Source: "address receiver"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t\tif (msg.sender != owner) {\r\n\t\tthrow;\r\n\t\t}\r\n\t\tsendTokenAway t = transfers[numTransfers];\r\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\r\n\t\tt.amount = amount;\r\n\t\tt.recipient = receiver;\r\n\t\tt.coinContract.transfer(receiver, amount);\r\n\t\tnumTransfers++;\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) {\r\n\t\tthrow;\r\n\t\t}"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n\t\tthrow;\r\n\t\t}"
          Throw
             Gas costs: 6
             Source: "throw"
      VariableDeclarationStatement
         Gas costs: 295
         Source: "sendTokenAway t = transfers[numTransfers]"
        VariableDeclaration "t"
           Type: struct daoPOLSKAtokens.sendTokenAway storage pointer
           Source: "sendTokenAway t"
          UserDefinedTypeName "sendTokenAway"
             Source: "sendTokenAway"
        IndexAccess
           Type: struct daoPOLSKAtokens.sendTokenAway storage ref
           Source: "transfers[numTransfers]"
          Identifier transfers
             Type: mapping(uint256 => struct daoPOLSKAtokens.sendTokenAway storage ref)
             Source: "transfers"
          Identifier numTransfers
             Type: uint256
             Source: "numTransfers"
      ExpressionStatement
         Gas costs: 20273
         Source: "t.coinContract = StandardToken(StandardTokenAddress)"
        Assignment using operator =
           Type: contract StandardToken
           Source: "t.coinContract = StandardToken(StandardTokenAddress)"
          MemberAccess to member coinContract
             Type: contract StandardToken
             Source: "t.coinContract"
            Identifier t
               Type: struct daoPOLSKAtokens.sendTokenAway storage pointer
               Source: "t"
          FunctionCall
             Type: contract StandardToken
             Source: "StandardToken(StandardTokenAddress)"
            Identifier StandardToken
               Type: type(contract StandardToken)
               Source: "StandardToken"
            Identifier StandardTokenAddress
               Type: address
               Source: "StandardTokenAddress"
      ExpressionStatement
         Gas costs: 20020
         Source: "t.amount = amount"
        Assignment using operator =
           Type: uint256
           Source: "t.amount = amount"
          MemberAccess to member amount
             Type: uint256
             Source: "t.amount"
            Identifier t
               Type: struct daoPOLSKAtokens.sendTokenAway storage pointer
               Source: "t"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20273
         Source: "t.recipient = receiver"
        Assignment using operator =
           Type: address
           Source: "t.recipient = receiver"
          MemberAccess to member recipient
             Type: address
             Source: "t.recipient"
            Identifier t
               Type: struct daoPOLSKAtokens.sendTokenAway storage pointer
               Source: "t"
          Identifier receiver
             Type: address
             Source: "receiver"
      ExpressionStatement
         Gas costs: [???]
         Source: "t.coinContract.transfer(receiver, amount)"
        FunctionCall
           Type: bool
           Source: "t.coinContract.transfer(receiver, amount)"
          MemberAccess to member transfer
             Type: function (address,uint256) external returns (bool)
             Source: "t.coinContract.transfer"
            MemberAccess to member coinContract
               Type: contract StandardToken
               Source: "t.coinContract"
              Identifier t
                 Type: struct daoPOLSKAtokens.sendTokenAway storage pointer
                 Source: "t"
          Identifier receiver
             Type: address
             Source: "receiver"
          Identifier amount
             Type: uint256
             Source: "amount"
      ExpressionStatement
         Gas costs: 20237
         Source: "numTransfers++"
        UnaryOperation (postfix) ++
           Type: uint256
           Source: "numTransfers++"
          Identifier numTransfers
             Type: uint256
             Source: "numTransfers"
  VariableDeclaration "tokenCreationRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public tokenCreationRate=1000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "bonusCreationRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public bonusCreationRate=1000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1000
       Type: int_const 1000
       Source: "1000"
  VariableDeclaration "CreationRate"
     Type: uint256
     Gas costs: [???]
     Source: "uint public CreationRate=1761"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 1761
       Type: int_const 1761
       Source: "1761"
  VariableDeclaration "oneweek"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public constant oneweek = 36000"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 36000
       Type: int_const 36000
       Source: "36000"
  VariableDeclaration "fundingEndBlock"
     Type: uint256
     Gas costs: [???]
     Source: "uint256 public fundingEndBlock = 5433616"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 5433616
       Type: int_const 5433616
       Source: "5433616"
  VariableDeclaration "funding"
     Type: bool
     Gas costs: [???]
     Source: "bool public funding = true"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: true value: true
       Type: bool
       Source: "true"
  VariableDeclaration "refundstate"
     Type: bool
     Gas costs: [???]
     Source: "bool public refundstate = false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  VariableDeclaration "migratestate"
     Type: bool
     Gas costs: [???]
     Source: "bool public migratestate= false"
    ElementaryTypeName bool
       Source: "bool"
    Literal, token: false value: false
       Type: bool
       Source: "false"
  FunctionDefinition "createDaoPOLSKAtokens" - public
     Source: "function createDaoPOLSKAtokens(address holder) payable {\r\n\r\n        if (!funding) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n\t\t// check the maximum token creation cap\r\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\r\n          throw;\r\n\t\t\r\n\t\t//bonus structure\r\n// in early stage there is about 100% more details in ico regulations on website\r\n// price and converstion rate in tabled to PLN not ether, and is updated daily\r\n\r\n\r\n\r\n\t var numTokensRAW = msg.value;\r\n\r\n        var numTokens = msg.value * CreationRate;\r\n        totalSupply += numTokens;\r\n\r\n        // Assign new tokens to the sender\r\n        balances[holder] += numTokens;\r\n        balancesRAW[holder] += numTokensRAW;\r\n        // Log token creation event\r\n        Transfer(0, holder, numTokens);\r\n\t\t\r\n\t\t// Create additional Dao Tokens for the community and developers around 12%\r\n        uint256 percentOfTotal = 12;\r\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\r\n\r\n        totalSupply += additionalTokens;\r\n\r\n        balances[migrationMaster] += additionalTokens;\r\n        Transfer(0, migrationMaster, additionalTokens);\r\n\t\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(address holder)"
      VariableDeclaration "holder"
         Type: address
         Source: "address holder"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\r\n        if (!funding) throw;\r\n\r\n        // Do not allow creating 0 or more than the cap tokens.\r\n        if (msg.value == 0) throw;\r\n\t\t// check the maximum token creation cap\r\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\r\n          throw;\r\n\t\t\r\n\t\t//bonus structure\r\n// in early stage there is about 100% more details in ico regulations on website\r\n// price and converstion rate in tabled to PLN not ether, and is updated daily\r\n\r\n\r\n\r\n\t var numTokensRAW = msg.value;\r\n\r\n        var numTokens = msg.value * CreationRate;\r\n        totalSupply += numTokens;\r\n\r\n        // Assign new tokens to the sender\r\n        balances[holder] += numTokens;\r\n        balancesRAW[holder] += numTokensRAW;\r\n        // Log token creation event\r\n        Transfer(0, holder, numTokens);\r\n\t\t\r\n\t\t// Create additional Dao Tokens for the community and developers around 12%\r\n        uint256 percentOfTotal = 12;\r\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\r\n\r\n        totalSupply += additionalTokens;\r\n\r\n        balances[migrationMaster] += additionalTokens;\r\n        Transfer(0, migrationMaster, additionalTokens);\r\n\t\r\n\t}"
      IfStatement
         Source: "if (!funding) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 242
           Source: "!funding"
          Identifier funding
             Type: bool
             Source: "funding"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (msg.value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 8
           Source: "msg.value == 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (msg.value > (supplylimit - totalSupply) / CreationRate)\r\n          throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 645
           Source: "msg.value > (supplylimit - totalSupply) / CreationRate"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          BinaryOperation using operator /
             Type: uint256
             Source: "(supplylimit - totalSupply) / CreationRate"
            TupleExpression
               Type: uint256
               Source: "(supplylimit - totalSupply)"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "supplylimit - totalSupply"
                Identifier supplylimit
                   Type: uint256
                   Source: "supplylimit"
                Identifier totalSupply
                   Type: uint256
                   Source: "totalSupply"
            Identifier CreationRate
               Type: uint256
               Source: "CreationRate"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 10
         Source: "var numTokensRAW = msg.value"
        VariableDeclaration "numTokensRAW"
           Type: uint256
           Source: "var numTokensRAW"
        MemberAccess to member value
           Type: uint256
           Source: "msg.value"
          Identifier msg
             Type: msg
             Source: "msg"
      VariableDeclarationStatement
         Gas costs: 218
         Source: "var numTokens = msg.value * CreationRate"
        VariableDeclaration "numTokens"
           Type: uint256
           Source: "var numTokens"
        BinaryOperation using operator *
           Type: uint256
           Source: "msg.value * CreationRate"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier CreationRate
             Type: uint256
             Source: "CreationRate"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += numTokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += numTokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier numTokens
             Type: uint256
             Source: "numTokens"
      ExpressionStatement
         Gas costs: 20329
         Source: "balances[holder] += numTokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[holder] += numTokens"
          IndexAccess
             Type: uint256
             Source: "balances[holder]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier holder
               Type: address
               Source: "holder"
          Identifier numTokens
             Type: uint256
             Source: "numTokens"
      ExpressionStatement
         Gas costs: 20323
         Source: "balancesRAW[holder] += numTokensRAW"
        Assignment using operator +=
           Type: uint256
           Source: "balancesRAW[holder] += numTokensRAW"
          IndexAccess
             Type: uint256
             Source: "balancesRAW[holder]"
            Identifier balancesRAW
               Type: mapping(address => uint256)
               Source: "balancesRAW"
            Identifier holder
               Type: address
               Source: "holder"
          Identifier numTokensRAW
             Type: uint256
             Source: "numTokensRAW"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, holder, numTokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, holder, numTokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier holder
             Type: address
             Source: "holder"
          Identifier numTokens
             Type: uint256
             Source: "numTokens"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "uint256 percentOfTotal = 12"
        VariableDeclaration "percentOfTotal"
           Type: uint256
           Source: "uint256 percentOfTotal"
          ElementaryTypeName uint256
             Source: "uint256"
        Literal, token: [no token] value: 12
           Type: int_const 12
           Source: "12"
      VariableDeclarationStatement
         Gas costs: 50
         Source: "uint256 additionalTokens = \tnumTokens * percentOfTotal / (100)"
        VariableDeclaration "additionalTokens"
           Type: uint256
           Source: "uint256 additionalTokens"
          ElementaryTypeName uint256
             Source: "uint256"
        BinaryOperation using operator /
           Type: uint256
           Source: "numTokens * percentOfTotal / (100)"
          BinaryOperation using operator *
             Type: uint256
             Source: "numTokens * percentOfTotal"
            Identifier numTokens
               Type: uint256
               Source: "numTokens"
            Identifier percentOfTotal
               Type: uint256
               Source: "percentOfTotal"
          TupleExpression
             Type: int_const 100
             Source: "(100)"
            Literal, token: [no token] value: 100
               Type: int_const 100
               Source: "100"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply += additionalTokens"
        Assignment using operator +=
           Type: uint256
           Source: "totalSupply += additionalTokens"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier additionalTokens
             Type: uint256
             Source: "additionalTokens"
      ExpressionStatement
         Gas costs: 20565
         Source: "balances[migrationMaster] += additionalTokens"
        Assignment using operator +=
           Type: uint256
           Source: "balances[migrationMaster] += additionalTokens"
          IndexAccess
             Type: uint256
             Source: "balances[migrationMaster]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            Identifier migrationMaster
               Type: address
               Source: "migrationMaster"
          Identifier additionalTokens
             Type: uint256
             Source: "additionalTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "Transfer(0, migrationMaster, additionalTokens)"
        FunctionCall
           Type: tuple()
           Source: "Transfer(0, migrationMaster, additionalTokens)"
          Identifier Transfer
             Type: function (address,address,uint256)
             Source: "Transfer"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
          Identifier migrationMaster
             Type: address
             Source: "migrationMaster"
          Identifier additionalTokens
             Type: uint256
             Source: "additionalTokens"
  FunctionDefinition "setBonusCreationRate" - public
     Source: "function setBonusCreationRate(uint newRate){\r\n\tif(msg.sender == owner) {\r\n\tbonusCreationRate=newRate;\r\n\tCreationRate=tokenCreationRate+bonusCreationRate;\r\n\t}\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint newRate)"
      VariableDeclaration "newRate"
         Type: uint256
         Source: "uint newRate"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\tif(msg.sender == owner) {\r\n\tbonusCreationRate=newRate;\r\n\tCreationRate=tokenCreationRate+bonusCreationRate;\r\n\t}\r\n\t}"
      IfStatement
         Source: "if(msg.sender == owner) {\r\n\tbonusCreationRate=newRate;\r\n\tCreationRate=tokenCreationRate+bonusCreationRate;\r\n\t}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 256
           Source: "msg.sender == owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Block
           Source: "{\r\n\tbonusCreationRate=newRate;\r\n\tCreationRate=tokenCreationRate+bonusCreationRate;\r\n\t}"
          ExpressionStatement
             Gas costs: 20014
             Source: "bonusCreationRate=newRate"
            Assignment using operator =
               Type: uint256
               Source: "bonusCreationRate=newRate"
              Identifier bonusCreationRate
                 Type: uint256
                 Source: "bonusCreationRate"
              Identifier newRate
                 Type: uint256
                 Source: "newRate"
          ExpressionStatement
             Gas costs: 20420
             Source: "CreationRate=tokenCreationRate+bonusCreationRate"
            Assignment using operator =
               Type: uint256
               Source: "CreationRate=tokenCreationRate+bonusCreationRate"
              Identifier CreationRate
                 Type: uint256
                 Source: "CreationRate"
              BinaryOperation using operator +
                 Type: uint256
                 Source: "tokenCreationRate+bonusCreationRate"
                Identifier tokenCreationRate
                   Type: uint256
                   Source: "tokenCreationRate"
                Identifier bonusCreationRate
                   Type: uint256
                   Source: "bonusCreationRate"
  FunctionDefinition "FundsTransfer" - public
     Source: "function FundsTransfer() external {\r\n\tif(funding==true) throw;\r\n\t\t \tif (!owner.send(this.balance)) throw;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\tif(funding==true) throw;\r\n\t\t \tif (!owner.send(this.balance)) throw;\r\n    }"
      IfStatement
         Source: "if(funding==true) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 257
           Source: "funding==true"
          Identifier funding
             Type: bool
             Source: "funding"
          Literal, token: true value: true
             Type: bool
             Source: "true"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (!owner.send(this.balance)) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: [???]
           Source: "!owner.send(this.balance)"
          FunctionCall
             Type: bool
             Source: "owner.send(this.balance)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "owner.send"
              Identifier owner
                 Type: address
                 Source: "owner"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract daoPOLSKAtokens
                 Source: "this"
        Throw
           Gas costs: 6
           Source: "throw"
  FunctionDefinition "PartialFundsTransfer" - public
     Source: "function PartialFundsTransfer(uint SubX) external {\r\n\t      if (msg.sender != owner) throw;\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n        owner.send(this.balance - SubX);\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "(uint SubX)"
      VariableDeclaration "SubX"
         Type: uint256
         Source: "uint SubX"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t      if (msg.sender != owner) throw;\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n        owner.send(this.balance - SubX);\r\n\t}"
      IfStatement
         Source: "if (msg.sender != owner) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: [???]
         Source: "owner.send(this.balance - SubX)"
        FunctionCall
           Type: bool
           Source: "owner.send(this.balance - SubX)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "owner.send"
            Identifier owner
               Type: address
               Source: "owner"
          BinaryOperation using operator -
             Type: uint256
             Source: "this.balance - SubX"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract daoPOLSKAtokens
                 Source: "this"
            Identifier SubX
               Type: uint256
               Source: "SubX"
  FunctionDefinition "turnrefund" - public
     Source: "function turnrefund() external {\r\n\t      if (msg.sender != owner) throw;\r\n\trefundstate=!refundstate;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t      if (msg.sender != owner) throw;\r\n\trefundstate=!refundstate;\r\n        }"
      IfStatement
         Source: "if (msg.sender != owner) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20606
         Source: "refundstate=!refundstate"
        Assignment using operator =
           Type: bool
           Source: "refundstate=!refundstate"
          Identifier refundstate
             Type: bool
             Source: "refundstate"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!refundstate"
            Identifier refundstate
               Type: bool
               Source: "refundstate"
  FunctionDefinition "fundingState" - public
     Source: "function fundingState() external {\r\n\t      if (msg.sender != owner) throw;\r\n\tfunding=!funding;\r\n        }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t      if (msg.sender != owner) throw;\r\n\tfunding=!funding;\r\n        }"
      IfStatement
         Source: "if (msg.sender != owner) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20506
         Source: "funding=!funding"
        Assignment using operator =
           Type: bool
           Source: "funding=!funding"
          Identifier funding
             Type: bool
             Source: "funding"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!funding"
            Identifier funding
               Type: bool
               Source: "funding"
  FunctionDefinition "turnmigrate" - public
     Source: "function turnmigrate() external {\r\n\t      if (msg.sender != migrationMaster) throw;\r\n\tmigratestate=!migratestate;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\t      if (msg.sender != migrationMaster) throw;\r\n\tmigratestate=!migratestate;\r\n}"
      IfStatement
         Source: "if (msg.sender != migrationMaster) throw"
        BinaryOperation using operator !=
           Type: bool
           Gas costs: 259
           Source: "msg.sender != migrationMaster"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier migrationMaster
             Type: address
             Source: "migrationMaster"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20606
         Source: "migratestate=!migratestate"
        Assignment using operator =
           Type: bool
           Source: "migratestate=!migratestate"
          Identifier migratestate
             Type: bool
             Source: "migratestate"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!migratestate"
            Identifier migratestate
               Type: bool
               Source: "migratestate"
  FunctionDefinition "finalize" - public
     Source: "function finalize() external {\r\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\r\n        // Switch to Operational state. This is the only place this can happen.\r\n        funding = false;\t\r\n\t\trefundstate=!refundstate;\r\n        // Transfer ETH to theDAO Polska Token network Storage address.\r\n        if (msg.sender==owner)\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n\t\towner.send(this.balance);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\r\n        // Switch to Operational state. This is the only place this can happen.\r\n        funding = false;\t\r\n\t\trefundstate=!refundstate;\r\n        // Transfer ETH to theDAO Polska Token network Storage address.\r\n        if (msg.sender==owner)\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n\t\towner.send(this.balance);\r\n    }"
      IfStatement
         Source: "if (block.number <= fundingEndBlock+8*oneweek) throw"
        BinaryOperation using operator <=
           Type: bool
           Gas costs: 222
           Source: "block.number <= fundingEndBlock+8*oneweek"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          BinaryOperation using operator +
             Type: uint256
             Source: "fundingEndBlock+8*oneweek"
            Identifier fundingEndBlock
               Type: uint256
               Source: "fundingEndBlock"
            BinaryOperation using operator *
               Type: uint256
               Source: "8*oneweek"
              Literal, token: [no token] value: 8
                 Type: int_const 8
                 Source: "8"
              Identifier oneweek
                 Type: uint256
                 Source: "oneweek"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20267
         Source: "funding = false"
        Assignment using operator =
           Type: bool
           Source: "funding = false"
          Identifier funding
             Type: bool
             Source: "funding"
          Literal, token: false value: false
             Type: bool
             Source: "false"
      ExpressionStatement
         Gas costs: 20606
         Source: "refundstate=!refundstate"
        Assignment using operator =
           Type: bool
           Source: "refundstate=!refundstate"
          Identifier refundstate
             Type: bool
             Source: "refundstate"
          UnaryOperation (prefix) !
             Type: bool
             Source: "!refundstate"
            Identifier refundstate
               Type: bool
               Source: "refundstate"
      IfStatement
         Source: "if (msg.sender==owner)\r\n        // <yes> <report> UNCHECKED_LL_CALLS\r\n\t\towner.send(this.balance)"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 256
           Source: "msg.sender==owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier owner
             Type: address
             Source: "owner"
        ExpressionStatement
           Gas costs: [???]
           Source: "owner.send(this.balance)"
          FunctionCall
             Type: bool
             Source: "owner.send(this.balance)"
            MemberAccess to member send
               Type: function (uint256) returns (bool)
               Source: "owner.send"
              Identifier owner
                 Type: address
                 Source: "owner"
            MemberAccess to member balance
               Type: uint256
               Source: "this.balance"
              Identifier this
                 Type: contract daoPOLSKAtokens
                 Source: "this"
  FunctionDefinition "migrate" - public
     Source: "function migrate(uint256 _value) external {\r\n        // Abort if not in Operational Migration state.\r\n        if (migratestate) throw;\r\n\r\n\r\n        // Validate input value.\r\n        if (_value == 0) throw;\r\n        if (_value > balances[msg.sender]) throw;\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _value)"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // Abort if not in Operational Migration state.\r\n        if (migratestate) throw;\r\n\r\n\r\n        // Validate input value.\r\n        if (_value == 0) throw;\r\n        if (_value > balances[msg.sender]) throw;\r\n\r\n        balances[msg.sender] -= _value;\r\n        totalSupply -= _value;\r\n        totalMigrated += _value;\r\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\r\n        Migrate(msg.sender, migrationAgent, _value);\r\n    }"
      IfStatement
         Source: "if (migratestate) throw"
        Identifier migratestate
           Type: bool
           Gas costs: 289
           Source: "migratestate"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (_value == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "_value == 0"
          Identifier _value
             Type: uint256
             Source: "_value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (_value > balances[msg.sender]) throw"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 304
           Source: "_value > balances[msg.sender]"
          Identifier _value
             Type: uint256
             Source: "_value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 20328
         Source: "balances[msg.sender] -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "balances[msg.sender] -= _value"
          IndexAccess
             Type: uint256
             Source: "balances[msg.sender]"
            Identifier balances
               Type: mapping(address => uint256)
               Source: "balances"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= _value"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= _value"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalMigrated += _value"
        Assignment using operator +=
           Type: uint256
           Source: "totalMigrated += _value"
          Identifier totalMigrated
             Type: uint256
             Source: "totalMigrated"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value)"
        FunctionCall
           Type: tuple()
           Source: "MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value)"
          MemberAccess to member migrateFrom
             Type: function (address,uint256) external
             Source: "MigrationAgent(migrationAgent).migrateFrom"
            FunctionCall
               Type: contract MigrationAgent
               Source: "MigrationAgent(migrationAgent)"
              Identifier MigrationAgent
                 Type: type(contract MigrationAgent)
                 Source: "MigrationAgent"
              Identifier migrationAgent
                 Type: address
                 Source: "migrationAgent"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier _value
             Type: uint256
             Source: "_value"
      ExpressionStatement
         Gas costs: [???]
         Source: "Migrate(msg.sender, migrationAgent, _value)"
        FunctionCall
           Type: tuple()
           Source: "Migrate(msg.sender, migrationAgent, _value)"
          Identifier Migrate
             Type: function (address,address,uint256)
             Source: "Migrate"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier migrationAgent
             Type: address
             Source: "migrationAgent"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "refundTRA" - public
     Source: "function refundTRA() external {\r\n        // Abort if not in Funding Failure state.\r\n        if (funding) throw;\r\n        if (!refundstate) throw;\r\n\r\n        var DAOPLTokenValue = balances[msg.sender];\r\n        var ETHValue = balancesRAW[msg.sender];\r\n        if (ETHValue == 0) throw;\r\n        balancesRAW[msg.sender] = 0;\r\n        totalSupply -= DAOPLTokenValue;\r\n         \r\n        Refund(msg.sender, ETHValue);\r\n        msg.sender.transfer(ETHValue);\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // Abort if not in Funding Failure state.\r\n        if (funding) throw;\r\n        if (!refundstate) throw;\r\n\r\n        var DAOPLTokenValue = balances[msg.sender];\r\n        var ETHValue = balancesRAW[msg.sender];\r\n        if (ETHValue == 0) throw;\r\n        balancesRAW[msg.sender] = 0;\r\n        totalSupply -= DAOPLTokenValue;\r\n         \r\n        Refund(msg.sender, ETHValue);\r\n        msg.sender.transfer(ETHValue);\r\n}"
      IfStatement
         Source: "if (funding) throw"
        Identifier funding
           Type: bool
           Gas costs: 239
           Source: "funding"
        Throw
           Gas costs: 6
           Source: "throw"
      IfStatement
         Source: "if (!refundstate) throw"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!refundstate"
          Identifier refundstate
             Type: bool
             Source: "refundstate"
        Throw
           Gas costs: 6
           Source: "throw"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "var DAOPLTokenValue = balances[msg.sender]"
        VariableDeclaration "DAOPLTokenValue"
           Type: uint256
           Source: "var DAOPLTokenValue"
        IndexAccess
           Type: uint256
           Source: "balances[msg.sender]"
          Identifier balances
             Type: mapping(address => uint256)
             Source: "balances"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "var ETHValue = balancesRAW[msg.sender]"
        VariableDeclaration "ETHValue"
           Type: uint256
           Source: "var ETHValue"
        IndexAccess
           Type: uint256
           Source: "balancesRAW[msg.sender]"
          Identifier balancesRAW
             Type: mapping(address => uint256)
             Source: "balancesRAW"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (ETHValue == 0) throw"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "ETHValue == 0"
          Identifier ETHValue
             Type: uint256
             Source: "ETHValue"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Throw
           Gas costs: 6
           Source: "throw"
      ExpressionStatement
         Gas costs: 5109
         Source: "balancesRAW[msg.sender] = 0"
        Assignment using operator =
           Type: uint256
           Source: "balancesRAW[msg.sender] = 0"
          IndexAccess
             Type: uint256
             Source: "balancesRAW[msg.sender]"
            Identifier balancesRAW
               Type: mapping(address => uint256)
               Source: "balancesRAW"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ExpressionStatement
         Gas costs: 20233
         Source: "totalSupply -= DAOPLTokenValue"
        Assignment using operator -=
           Type: uint256
           Source: "totalSupply -= DAOPLTokenValue"
          Identifier totalSupply
             Type: uint256
             Source: "totalSupply"
          Identifier DAOPLTokenValue
             Type: uint256
             Source: "DAOPLTokenValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "Refund(msg.sender, ETHValue)"
        FunctionCall
           Type: tuple()
           Source: "Refund(msg.sender, ETHValue)"
          Identifier Refund
             Type: function (address,uint256)
             Source: "Refund"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier ETHValue
             Type: uint256
             Source: "ETHValue"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(ETHValue)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(ETHValue)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier ETHValue
             Type: uint256
             Source: "ETHValue"
  FunctionDefinition "preICOregulations" - public
     Source: "function preICOregulations() external returns(string wow) {\r\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(string wow)"
      VariableDeclaration "wow"
         Type: string memory
         Source: "string wow"
        ElementaryTypeName string
           Source: "string"
    Block
       Source: "{\r\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\r\n}"
      Return
         Gas costs: [???]
         Source: "return 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules'"
        Literal, token: [no token] value: Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules
           Type: literal_string "Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules"
           Source: "'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules'"
