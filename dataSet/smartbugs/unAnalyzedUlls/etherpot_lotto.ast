Syntax trees:


======= etherpot_lotto.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.0;"
ContractDefinition "Lotto"
   Source: "contract Lotto {\n\n     uint constant public blocksPerRound = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public ticketPrice = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public blockReward = 5000000000000000000;\n\n     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\n     function getTicketPrice() constant returns(uint){ return ticketPrice; }\n     //accessors for constants\n\n     struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }\n     mapping(uint => Round) rounds;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }\n\n     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }\n\n\n     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }\n\n     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }\n\n     function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }\n\n     function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }\n\n     function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }\n\n     function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }\n\n     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }\n\n     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }\n\n     function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }\n\n     function () {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }\n\n }"
  VariableDeclaration "blocksPerRound"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public blocksPerRound = 6800"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 6800
       Type: int_const 6800
       Source: "6800"
  VariableDeclaration "ticketPrice"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public ticketPrice = 100000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 100000000000000000
       Type: int_const 100000000000000000
       Source: "100000000000000000"
  VariableDeclaration "blockReward"
     Type: uint256
     Gas costs: [???]
     Source: "uint constant public blockReward = 5000000000000000000"
    ElementaryTypeName uint
       Source: "uint"
    Literal, token: [no token] value: 5000000000000000000
       Type: int_const 5000000000000000000
       Source: "5000000000000000000"
  FunctionDefinition "getBlocksPerRound" - public - const
     Source: "function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{ return blocksPerRound; }"
      Return
         Gas costs: 5
         Source: "return blocksPerRound"
        Identifier blocksPerRound
           Type: uint256
           Source: "blocksPerRound"
  FunctionDefinition "getTicketPrice" - public - const
     Source: "function getTicketPrice() constant returns(uint){ return ticketPrice; }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{ return ticketPrice; }"
      Return
         Gas costs: 5
         Source: "return ticketPrice"
        Identifier ticketPrice
           Type: uint256
           Source: "ticketPrice"
  StructDefinition "Round"
     Gas costs: 0
     Source: "struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }"
    VariableDeclaration "buyers"
       Type: address[] storage pointer
       Source: "address[] buyers"
      ArrayTypeName
         Source: "address[]"
        ElementaryTypeName address
           Source: "address"
    VariableDeclaration "pot"
       Type: uint256
       Source: "uint pot"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "ticketsCount"
       Type: uint256
       Source: "uint ticketsCount"
      ElementaryTypeName uint
         Source: "uint"
    VariableDeclaration "isCashed"
       Type: mapping(uint256 => bool)
       Source: "mapping(uint=>bool) isCashed"
      Mapping
         Source: "mapping(uint=>bool)"
        ElementaryTypeName uint
           Source: "uint"
        ElementaryTypeName bool
           Source: "bool"
    VariableDeclaration "ticketsCountByBuyer"
       Type: mapping(address => uint256)
       Source: "mapping(address=>uint) ticketsCountByBuyer"
      Mapping
         Source: "mapping(address=>uint)"
        ElementaryTypeName address
           Source: "address"
        ElementaryTypeName uint
           Source: "uint"
  VariableDeclaration "rounds"
     Type: mapping(uint256 => struct Lotto.Round storage ref)
     Gas costs: 0
     Source: "mapping(uint => Round) rounds"
    Mapping
       Source: "mapping(uint => Round)"
      ElementaryTypeName uint
         Source: "uint"
      UserDefinedTypeName "Round"
         Source: "Round"
  FunctionDefinition "getRoundIndex" - public - const
     Source: "function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }"
      Return
         Gas costs: 35
         Source: "return block.number/blocksPerRound"
        BinaryOperation using operator /
           Type: uint256
           Source: "block.number/blocksPerRound"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
          Identifier blocksPerRound
             Type: uint256
             Source: "blocksPerRound"
  FunctionDefinition "getIsCashed" - public - const
     Source: "function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex,uint subpotIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "subpotIndex"
         Type: uint256
         Source: "uint subpotIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }"
      Return
         Gas costs: 412
         Source: "return rounds[roundIndex].isCashed[subpotIndex]"
        IndexAccess
           Type: bool
           Source: "rounds[roundIndex].isCashed[subpotIndex]"
          MemberAccess to member isCashed
             Type: mapping(uint256 => bool)
             Source: "rounds[roundIndex].isCashed"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
  FunctionDefinition "calculateWinner" - public - const
     Source: "function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex, uint subpotIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "subpotIndex"
         Type: uint256
         Source: "uint subpotIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(address)"
      VariableDeclaration ""
         Type: address
         Source: "address"
        ElementaryTypeName address
           Source: "address"
    Block
       Source: "{\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }"
      VariableDeclarationStatement
         Gas costs: 18
         Source: "var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex)"
        VariableDeclaration "decisionBlockNumber"
           Type: uint256
           Source: "var decisionBlockNumber"
        FunctionCall
           Type: uint256
           Source: "getDecisionBlockNumber(roundIndex,subpotIndex)"
          Identifier getDecisionBlockNumber
             Type: function (uint256,uint256) view returns (uint256)
             Source: "getDecisionBlockNumber"
          Identifier roundIndex
             Type: uint256
             Source: "roundIndex"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
      IfStatement
         Source: "if(decisionBlockNumber>block.number)\n             return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "decisionBlockNumber>block.number"
          Identifier decisionBlockNumber
             Type: uint256
             Source: "decisionBlockNumber"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "var decisionBlockHash = getHashOfBlock(decisionBlockNumber)"
        VariableDeclaration "decisionBlockHash"
           Type: uint256
           Source: "var decisionBlockHash"
        FunctionCall
           Type: uint256
           Source: "getHashOfBlock(decisionBlockNumber)"
          Identifier getHashOfBlock
             Type: function (uint256) view returns (uint256)
             Source: "getHashOfBlock"
          Identifier decisionBlockNumber
             Type: uint256
             Source: "decisionBlockNumber"
      VariableDeclarationStatement
         Gas costs: 332
         Source: "var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount"
        VariableDeclaration "winningTicketIndex"
           Type: uint256
           Source: "var winningTicketIndex"
        BinaryOperation using operator %
           Type: uint256
           Source: "decisionBlockHash%rounds[roundIndex].ticketsCount"
          Identifier decisionBlockHash
             Type: uint256
             Source: "decisionBlockHash"
          MemberAccess to member ticketsCount
             Type: uint256
             Source: "rounds[roundIndex].ticketsCount"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
      VariableDeclarationStatement
         Gas costs: 11
         Source: "var ticketIndex = uint256(0)"
        VariableDeclaration "ticketIndex"
           Type: uint256
           Source: "var ticketIndex"
        FunctionCall
           Type: uint256
           Source: "uint256(0)"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
      ForStatement
         Source: "for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }"
        VariableDeclarationStatement
           Gas costs: 11
           Source: "var buyerIndex = 0"
          VariableDeclaration "buyerIndex"
             Type: uint8
             Source: "var buyerIndex"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 313
           Source: "buyerIndex<rounds[roundIndex].buyers.length"
          Identifier buyerIndex
             Type: uint8
             Source: "buyerIndex"
          MemberAccess to member length
             Type: uint256
             Source: "rounds[roundIndex].buyers.length"
            MemberAccess to member buyers
               Type: address[] storage ref
               Source: "rounds[roundIndex].buyers"
              IndexAccess
                 Type: struct Lotto.Round storage ref
                 Source: "rounds[roundIndex]"
                Identifier rounds
                   Type: mapping(uint256 => struct Lotto.Round storage ref)
                   Source: "rounds"
                Identifier roundIndex
                   Type: uint256
                   Source: "roundIndex"
        ExpressionStatement
           Gas costs: 19
           Source: "buyerIndex++"
          UnaryOperation (postfix) ++
             Type: uint8
             Source: "buyerIndex++"
            Identifier buyerIndex
               Type: uint8
               Source: "buyerIndex"
        Block
           Source: "{\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }"
          VariableDeclarationStatement
             Gas costs: 632
             Source: "var buyer = rounds[roundIndex].buyers[buyerIndex]"
            VariableDeclaration "buyer"
               Type: address
               Source: "var buyer"
            IndexAccess
               Type: address
               Source: "rounds[roundIndex].buyers[buyerIndex]"
              MemberAccess to member buyers
                 Type: address[] storage ref
                 Source: "rounds[roundIndex].buyers"
                IndexAccess
                   Type: struct Lotto.Round storage ref
                   Source: "rounds[roundIndex]"
                  Identifier rounds
                     Type: mapping(uint256 => struct Lotto.Round storage ref)
                     Source: "rounds"
                  Identifier roundIndex
                     Type: uint256
                     Source: "roundIndex"
              Identifier buyerIndex
                 Type: uint8
                 Source: "buyerIndex"
          ExpressionStatement
             Gas costs: 391
             Source: "ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer]"
            Assignment using operator +=
               Type: uint256
               Source: "ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer]"
              Identifier ticketIndex
                 Type: uint256
                 Source: "ticketIndex"
              IndexAccess
                 Type: uint256
                 Source: "rounds[roundIndex].ticketsCountByBuyer[buyer]"
                MemberAccess to member ticketsCountByBuyer
                   Type: mapping(address => uint256)
                   Source: "rounds[roundIndex].ticketsCountByBuyer"
                  IndexAccess
                     Type: struct Lotto.Round storage ref
                     Source: "rounds[roundIndex]"
                    Identifier rounds
                       Type: mapping(uint256 => struct Lotto.Round storage ref)
                       Source: "rounds"
                    Identifier roundIndex
                       Type: uint256
                       Source: "roundIndex"
                Identifier buyer
                   Type: address
                   Source: "buyer"
          IfStatement
             Source: "if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }"
            BinaryOperation using operator >
               Type: bool
               Gas costs: 9
               Source: "ticketIndex>winningTicketIndex"
              Identifier ticketIndex
                 Type: uint256
                 Source: "ticketIndex"
              Identifier winningTicketIndex
                 Type: uint256
                 Source: "winningTicketIndex"
            Block
               Source: "{\n                 return buyer;\n             }"
              Return
                 Gas costs: 19
                 Source: "return buyer"
                Identifier buyer
                   Type: address
                   Source: "buyer"
  FunctionDefinition "getDecisionBlockNumber" - public - const
     Source: "function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex,uint subpotIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "subpotIndex"
         Type: uint256
         Source: "uint subpotIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }"
      Return
         Gas costs: 25
         Source: "return ((roundIndex+1)*blocksPerRound)+subpotIndex"
        BinaryOperation using operator +
           Type: uint256
           Source: "((roundIndex+1)*blocksPerRound)+subpotIndex"
          TupleExpression
             Type: uint256
             Source: "((roundIndex+1)*blocksPerRound)"
            BinaryOperation using operator *
               Type: uint256
               Source: "(roundIndex+1)*blocksPerRound"
              TupleExpression
                 Type: uint256
                 Source: "(roundIndex+1)"
                BinaryOperation using operator +
                   Type: uint256
                   Source: "roundIndex+1"
                  Identifier roundIndex
                     Type: uint256
                     Source: "roundIndex"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
              Identifier blocksPerRound
                 Type: uint256
                 Source: "blocksPerRound"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
  FunctionDefinition "getSubpotsCount" - public - const
     Source: "function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }"
      VariableDeclarationStatement
         Gas costs: 329
         Source: "var subpotsCount = rounds[roundIndex].pot/blockReward"
        VariableDeclaration "subpotsCount"
           Type: uint256
           Source: "var subpotsCount"
        BinaryOperation using operator /
           Type: uint256
           Source: "rounds[roundIndex].pot/blockReward"
          MemberAccess to member pot
             Type: uint256
             Source: "rounds[roundIndex].pot"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier blockReward
             Type: uint256
             Source: "blockReward"
      IfStatement
         Source: "if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 327
           Source: "rounds[roundIndex].pot%blockReward>0"
          BinaryOperation using operator %
             Type: uint256
             Source: "rounds[roundIndex].pot%blockReward"
            MemberAccess to member pot
               Type: uint256
               Source: "rounds[roundIndex].pot"
              IndexAccess
                 Type: struct Lotto.Round storage ref
                 Source: "rounds[roundIndex]"
                Identifier rounds
                   Type: mapping(uint256 => struct Lotto.Round storage ref)
                   Source: "rounds"
                Identifier roundIndex
                   Type: uint256
                   Source: "roundIndex"
            Identifier blockReward
               Type: uint256
               Source: "blockReward"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        ExpressionStatement
           Gas costs: 19
           Source: "subpotsCount++"
          UnaryOperation (postfix) ++
             Type: uint256
             Source: "subpotsCount++"
            Identifier subpotsCount
               Type: uint256
               Source: "subpotsCount"
      Return
         Gas costs: 8
         Source: "return subpotsCount"
        Identifier subpotsCount
           Type: uint256
           Source: "subpotsCount"
  FunctionDefinition "getSubpot" - public - const
     Source: "function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }"
      Return
         Gas costs: 344
         Source: "return rounds[roundIndex].pot/getSubpotsCount(roundIndex)"
        BinaryOperation using operator /
           Type: uint256
           Source: "rounds[roundIndex].pot/getSubpotsCount(roundIndex)"
          MemberAccess to member pot
             Type: uint256
             Source: "rounds[roundIndex].pot"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          FunctionCall
             Type: uint256
             Source: "getSubpotsCount(roundIndex)"
            Identifier getSubpotsCount
               Type: function (uint256) view returns (uint256)
               Source: "getSubpotsCount"
            Identifier roundIndex
               Type: uint256
               Source: "roundIndex"
  FunctionDefinition "cash" - public
     Source: "function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex, uint subpotIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "subpotIndex"
         Type: uint256
         Source: "uint subpotIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "var subpotsCount = getSubpotsCount(roundIndex)"
        VariableDeclaration "subpotsCount"
           Type: uint256
           Source: "var subpotsCount"
        FunctionCall
           Type: uint256
           Source: "getSubpotsCount(roundIndex)"
          Identifier getSubpotsCount
             Type: function (uint256) view returns (uint256)
             Source: "getSubpotsCount"
          Identifier roundIndex
             Type: uint256
             Source: "roundIndex"
      IfStatement
         Source: "if(subpotIndex>=subpotsCount)\n             return;"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 12
           Source: "subpotIndex>=subpotsCount"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
          Identifier subpotsCount
             Type: uint256
             Source: "subpotsCount"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 29
         Source: "var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex)"
        VariableDeclaration "decisionBlockNumber"
           Type: uint256
           Source: "var decisionBlockNumber"
        FunctionCall
           Type: uint256
           Source: "getDecisionBlockNumber(roundIndex,subpotIndex)"
          Identifier getDecisionBlockNumber
             Type: function (uint256,uint256) view returns (uint256)
             Source: "getDecisionBlockNumber"
          Identifier roundIndex
             Type: uint256
             Source: "roundIndex"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
      IfStatement
         Source: "if(decisionBlockNumber>block.number)\n             return;"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "decisionBlockNumber>block.number"
          Identifier decisionBlockNumber
             Type: uint256
             Source: "decisionBlockNumber"
          MemberAccess to member number
             Type: uint256
             Source: "block.number"
            Identifier block
               Type: block
               Source: "block"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if(rounds[roundIndex].isCashed[subpotIndex])\n             return;"
        IndexAccess
           Type: bool
           Gas costs: 407
           Source: "rounds[roundIndex].isCashed[subpotIndex]"
          MemberAccess to member isCashed
             Type: mapping(uint256 => bool)
             Source: "rounds[roundIndex].isCashed"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
        Return
           Gas costs: 11
           Source: "return;"
      VariableDeclarationStatement
         Gas costs: 29
         Source: "var winner = calculateWinner(roundIndex,subpotIndex)"
        VariableDeclaration "winner"
           Type: address
           Source: "var winner"
        FunctionCall
           Type: address
           Source: "calculateWinner(roundIndex,subpotIndex)"
          Identifier calculateWinner
             Type: function (uint256,uint256) view returns (address)
             Source: "calculateWinner"
          Identifier roundIndex
             Type: uint256
             Source: "roundIndex"
          Identifier subpotIndex
             Type: uint256
             Source: "subpotIndex"
      VariableDeclarationStatement
         Gas costs: 26
         Source: "var subpot = getSubpot(roundIndex)"
        VariableDeclaration "subpot"
           Type: uint256
           Source: "var subpot"
        FunctionCall
           Type: uint256
           Source: "getSubpot(roundIndex)"
          Identifier getSubpot
             Type: function (uint256) view returns (uint256)
             Source: "getSubpot"
          Identifier roundIndex
             Type: uint256
             Source: "roundIndex"
      ExpressionStatement
         Gas costs: [???]
         Source: "winner.send(subpot)"
        FunctionCall
           Type: bool
           Source: "winner.send(subpot)"
          MemberAccess to member send
             Type: function (uint256) returns (bool)
             Source: "winner.send"
            Identifier winner
               Type: address
               Source: "winner"
          Identifier subpot
             Type: uint256
             Source: "subpot"
      ExpressionStatement
         Gas costs: 20429
         Source: "rounds[roundIndex].isCashed[subpotIndex] = true"
        Assignment using operator =
           Type: bool
           Source: "rounds[roundIndex].isCashed[subpotIndex] = true"
          IndexAccess
             Type: bool
             Source: "rounds[roundIndex].isCashed[subpotIndex]"
            MemberAccess to member isCashed
               Type: mapping(uint256 => bool)
               Source: "rounds[roundIndex].isCashed"
              IndexAccess
                 Type: struct Lotto.Round storage ref
                 Source: "rounds[roundIndex]"
                Identifier rounds
                   Type: mapping(uint256 => struct Lotto.Round storage ref)
                   Source: "rounds"
                Identifier roundIndex
                   Type: uint256
                   Source: "roundIndex"
            Identifier subpotIndex
               Type: uint256
               Source: "subpotIndex"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "getHashOfBlock" - public - const
     Source: "function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint blockIndex)"
      VariableDeclaration "blockIndex"
         Type: uint256
         Source: "uint blockIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         return uint(block.blockhash(blockIndex));\n     }"
      Return
         Gas costs: 39
         Source: "return uint(block.blockhash(blockIndex))"
        FunctionCall
           Type: uint256
           Source: "uint(block.blockhash(blockIndex))"
          ElementaryTypeNameExpression uint
             Type: type(uint256)
             Source: "uint"
          FunctionCall
             Type: bytes32
             Source: "block.blockhash(blockIndex)"
            MemberAccess to member blockhash
               Type: function (uint256) view returns (bytes32)
               Source: "block.blockhash"
              Identifier block
                 Type: block
                 Source: "block"
            Identifier blockIndex
               Type: uint256
               Source: "blockIndex"
  FunctionDefinition "getBuyers" - public - const
     Source: "function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex,address buyer)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "buyer"
         Type: address
         Source: "address buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(address[])"
      VariableDeclaration ""
         Type: address[] memory
         Source: "address[]"
        ArrayTypeName
           Source: "address[]"
          ElementaryTypeName address
             Source: "address"
    Block
       Source: "{\n         return rounds[roundIndex].buyers;\n     }"
      Return
         Gas costs: [???]
         Source: "return rounds[roundIndex].buyers"
        MemberAccess to member buyers
           Type: address[] storage ref
           Source: "rounds[roundIndex].buyers"
          IndexAccess
             Type: struct Lotto.Round storage ref
             Source: "rounds[roundIndex]"
            Identifier rounds
               Type: mapping(uint256 => struct Lotto.Round storage ref)
               Source: "rounds"
            Identifier roundIndex
               Type: uint256
               Source: "roundIndex"
  FunctionDefinition "getTicketsCountByBuyer" - public - const
     Source: "function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex,address buyer)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
      VariableDeclaration "buyer"
         Type: address
         Source: "address buyer"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }"
      Return
         Gas costs: 388
         Source: "return rounds[roundIndex].ticketsCountByBuyer[buyer]"
        IndexAccess
           Type: uint256
           Source: "rounds[roundIndex].ticketsCountByBuyer[buyer]"
          MemberAccess to member ticketsCountByBuyer
             Type: mapping(address => uint256)
             Source: "rounds[roundIndex].ticketsCountByBuyer"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier buyer
             Type: address
             Source: "buyer"
  FunctionDefinition "getPot" - public - const
     Source: "function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }"
    ParameterList
       Gas costs: 0
       Source: "(uint roundIndex)"
      VariableDeclaration "roundIndex"
         Type: uint256
         Source: "uint roundIndex"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\n         return rounds[roundIndex].pot;\n     }"
      Return
         Gas costs: 298
         Source: "return rounds[roundIndex].pot"
        MemberAccess to member pot
           Type: uint256
           Source: "rounds[roundIndex].pot"
          IndexAccess
             Type: struct Lotto.Round storage ref
             Source: "rounds[roundIndex]"
            Identifier rounds
               Type: mapping(uint256 => struct Lotto.Round storage ref)
               Source: "rounds"
            Identifier roundIndex
               Type: uint256
               Source: "roundIndex"
  FunctionDefinition "" - public
     Source: "function () {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }"
      VariableDeclarationStatement
         Gas costs: 12
         Source: "var roundIndex = getRoundIndex()"
        VariableDeclaration "roundIndex"
           Type: uint256
           Source: "var roundIndex"
        FunctionCall
           Type: uint256
           Source: "getRoundIndex()"
          Identifier getRoundIndex
             Type: function () view returns (uint256)
             Source: "getRoundIndex"
      VariableDeclarationStatement
         Gas costs: 43
         Source: "var value = msg.value-(msg.value%ticketPrice)"
        VariableDeclaration "value"
           Type: uint256
           Source: "var value"
        BinaryOperation using operator -
           Type: uint256
           Source: "msg.value-(msg.value%ticketPrice)"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          TupleExpression
             Type: uint256
             Source: "(msg.value%ticketPrice)"
            BinaryOperation using operator %
               Type: uint256
               Source: "msg.value%ticketPrice"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
              Identifier ticketPrice
                 Type: uint256
                 Source: "ticketPrice"
      IfStatement
         Source: "if(value==0) return;"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 9
           Source: "value==0"
          Identifier value
             Type: uint256
             Source: "value"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Return
           Gas costs: 11
           Source: "return;"
      IfStatement
         Source: "if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }"
        BinaryOperation using operator <
           Type: bool
           Gas costs: 8
           Source: "value<msg.value"
          Identifier value
             Type: uint256
             Source: "value"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
        Block
           Source: "{\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.send(msg.value-value)"
            FunctionCall
               Type: bool
               Source: "msg.sender.send(msg.value-value)"
              MemberAccess to member send
                 Type: function (uint256) returns (bool)
                 Source: "msg.sender.send"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              BinaryOperation using operator -
                 Type: uint256
                 Source: "msg.value-value"
                MemberAccess to member value
                   Type: uint256
                   Source: "msg.value"
                  Identifier msg
                     Type: msg
                     Source: "msg"
                Identifier value
                   Type: uint256
                   Source: "value"
      VariableDeclarationStatement
         Gas costs: 39
         Source: "var ticketsCount = value/ticketPrice"
        VariableDeclaration "ticketsCount"
           Type: uint256
           Source: "var ticketsCount"
        BinaryOperation using operator /
           Type: uint256
           Source: "value/ticketPrice"
          Identifier value
             Type: uint256
             Source: "value"
          Identifier ticketPrice
             Type: uint256
             Source: "ticketPrice"
      ExpressionStatement
         Gas costs: 20323
         Source: "rounds[roundIndex].ticketsCount+=ticketsCount"
        Assignment using operator +=
           Type: uint256
           Source: "rounds[roundIndex].ticketsCount+=ticketsCount"
          MemberAccess to member ticketsCount
             Type: uint256
             Source: "rounds[roundIndex].ticketsCount"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier ticketsCount
             Type: uint256
             Source: "ticketsCount"
      IfStatement
         Source: "if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 382
           Source: "rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0"
          IndexAccess
             Type: uint256
             Source: "rounds[roundIndex].ticketsCountByBuyer[msg.sender]"
            MemberAccess to member ticketsCountByBuyer
               Type: mapping(address => uint256)
               Source: "rounds[roundIndex].ticketsCountByBuyer"
              IndexAccess
                 Type: struct Lotto.Round storage ref
                 Source: "rounds[roundIndex]"
                Identifier rounds
                   Type: mapping(uint256 => struct Lotto.Round storage ref)
                   Source: "rounds"
                Identifier roundIndex
                   Type: uint256
                   Source: "roundIndex"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }"
          VariableDeclarationStatement
             Gas costs: 329
             Source: "var buyersLength = rounds[roundIndex].buyers.length++"
            VariableDeclaration "buyersLength"
               Type: uint256
               Source: "var buyersLength"
            UnaryOperation (postfix) ++
               Type: uint256
               Source: "rounds[roundIndex].buyers.length++"
              MemberAccess to member length
                 Type: uint256
                 Source: "rounds[roundIndex].buyers.length"
                MemberAccess to member buyers
                   Type: address[] storage ref
                   Source: "rounds[roundIndex].buyers"
                  IndexAccess
                     Type: struct Lotto.Round storage ref
                     Source: "rounds[roundIndex]"
                    Identifier rounds
                       Type: mapping(uint256 => struct Lotto.Round storage ref)
                       Source: "rounds"
                    Identifier roundIndex
                       Type: uint256
                       Source: "roundIndex"
          ExpressionStatement
             Gas costs: 20645
             Source: "rounds[roundIndex].buyers[buyersLength] = msg.sender"
            Assignment using operator =
               Type: address
               Source: "rounds[roundIndex].buyers[buyersLength] = msg.sender"
              IndexAccess
                 Type: address
                 Source: "rounds[roundIndex].buyers[buyersLength]"
                MemberAccess to member buyers
                   Type: address[] storage ref
                   Source: "rounds[roundIndex].buyers"
                  IndexAccess
                     Type: struct Lotto.Round storage ref
                     Source: "rounds[roundIndex]"
                    Identifier rounds
                       Type: mapping(uint256 => struct Lotto.Round storage ref)
                       Source: "rounds"
                    Identifier roundIndex
                       Type: uint256
                       Source: "roundIndex"
                Identifier buyersLength
                   Type: uint256
                   Source: "buyersLength"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
      ExpressionStatement
         Gas costs: 20412
         Source: "rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount"
        Assignment using operator +=
           Type: uint256
           Source: "rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount"
          IndexAccess
             Type: uint256
             Source: "rounds[roundIndex].ticketsCountByBuyer[msg.sender]"
            MemberAccess to member ticketsCountByBuyer
               Type: mapping(address => uint256)
               Source: "rounds[roundIndex].ticketsCountByBuyer"
              IndexAccess
                 Type: struct Lotto.Round storage ref
                 Source: "rounds[roundIndex]"
                Identifier rounds
                   Type: mapping(uint256 => struct Lotto.Round storage ref)
                   Source: "rounds"
                Identifier roundIndex
                   Type: uint256
                   Source: "roundIndex"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier ticketsCount
             Type: uint256
             Source: "ticketsCount"
      ExpressionStatement
         Gas costs: 20317
         Source: "rounds[roundIndex].ticketsCount+=ticketsCount"
        Assignment using operator +=
           Type: uint256
           Source: "rounds[roundIndex].ticketsCount+=ticketsCount"
          MemberAccess to member ticketsCount
             Type: uint256
             Source: "rounds[roundIndex].ticketsCount"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier ticketsCount
             Type: uint256
             Source: "ticketsCount"
      ExpressionStatement
         Gas costs: 20317
         Source: "rounds[roundIndex].pot+=value"
        Assignment using operator +=
           Type: uint256
           Source: "rounds[roundIndex].pot+=value"
          MemberAccess to member pot
             Type: uint256
             Source: "rounds[roundIndex].pot"
            IndexAccess
               Type: struct Lotto.Round storage ref
               Source: "rounds[roundIndex]"
              Identifier rounds
                 Type: mapping(uint256 => struct Lotto.Round storage ref)
                 Source: "rounds"
              Identifier roundIndex
                 Type: uint256
                 Source: "roundIndex"
          Identifier value
             Type: uint256
             Source: "value"
