Syntax trees:


======= 0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.23;"
ContractDefinition "DrainMe"
   Source: "contract DrainMe {\r\n\r\n//constants\r\n\r\naddress public winner = 0x0;\r\naddress public owner;\r\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\r\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\r\naddress[] public players;\r\n\r\nmapping(address=>bool) approvedPlayers;\r\n\r\nuint256 public secret;\r\nuint256[] public seed = [951828771,158769871220];\r\nuint256[] public balance;\r\n\r\n//constructor\r\n\r\nfunction DranMe() public payable{\r\n\towner = msg.sender;\r\n}\r\n\r\n//modifiers\r\n\r\nmodifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n}\r\n\r\nmodifier onlyWinner() {\r\n    require(msg.sender == winner);\r\n    _;\r\n}\r\n\r\nmodifier onlyPlayers() {\r\n    require(approvedPlayers[msg.sender]);\r\n    _;\r\n}\r\n\r\n//functions\r\n\r\nfunction getLength() public constant returns(uint256) {\r\n\treturn seed.length;\r\n}\r\n\r\nfunction setSecret(uint256 _secret) public payable onlyOwner{\r\n\tsecret = _secret;\r\n}\r\n\r\nfunction getPlayerCount() public constant returns(uint256) {\r\n\treturn players.length;\r\n}\r\n\r\nfunction getPrize() public constant returns(uint256) {\r\n\treturn address(this).balance;\r\n}\r\n\r\nfunction becomePlayer() public payable{\r\n\trequire(msg.value >= 0.02 ether);\r\n\tplayers.push(msg.sender);\r\n\tapprovedPlayers[msg.sender]=true;\r\n}\r\n\r\nfunction manipulateSecret() public payable onlyPlayers{\r\n\trequire (msg.value >= 0.01 ether);\r\n\tif(msg.sender!=owner || unlockSecret()){\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}\r\n}\r\n\r\nfunction unlockSecret() private returns(bool){\r\n    bytes32 hash = keccak256(blockhash(block.number-1));\r\n    uint256 secret = uint256(hash);\r\n        if(secret%5==0){\r\n            winner = msg.sender;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\nfunction callFirstTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tfirstTarget.call.value(msg.value)();\r\n}\r\n\r\nfunction callSecondTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tsecondTarget.call.value(msg.value)();\r\n}\r\n\r\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\r\n\tseed[_index] = _value;\r\n}\r\n\t\r\nfunction addSeed (uint256 _add) public payable onlyPlayers {\r\n\tseed.length = _add;\r\n}\r\n\r\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\r\n\treturn (_seed / (seed[0]*seed[1]));\r\n\tif((_seed / (seed[0]*seed[1])) == secret) {\r\n\t\towner = winner;\r\n\t}\r\n}\r\n\r\nfunction checkSecret () public payable onlyPlayers returns(bool) {\r\n    require(msg.value >= 0.01 ether);\r\n    if(msg.value == secret){\r\n        return true;\r\n    }\r\n}\r\n\r\nfunction winPrize() public payable onlyOwner {\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\towner.call.value(1 wei)();\r\n}\r\n\r\nfunction claimPrize() public payable onlyWinner {\r\n\twinner.transfer(address(this).balance);\r\n}\r\n\r\n//fallback function\r\n\r\nfunction() public payable{\r\n\t}\r\n}"
  VariableDeclaration "winner"
     Type: address
     Gas costs: 335
     Source: "address public winner = 0x0"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x0
       Type: int_const 0
       Source: "0x0"
  VariableDeclaration "owner"
     Type: address
     Gas costs: 335
     Source: "address public owner"
    ElementaryTypeName address
       Source: "address"
  VariableDeclaration "firstTarget"
     Type: address
     Gas costs: 335
     Source: "address public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b
       Type: address
       Source: "0x461ec7309F187dd4650EE6b4D25D93c922d7D56b"
  VariableDeclaration "secondTarget"
     Type: address
     Gas costs: 335
     Source: "address public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766"
    ElementaryTypeName address
       Source: "address"
    Literal, token: [no token] value: 0x1C3E062c77f09fC61550703bDd1D59842C22c766
       Type: address
       Source: "0x1C3E062c77f09fC61550703bDd1D59842C22c766"
  VariableDeclaration "players"
     Type: address[] storage ref
     Gas costs: 682
     Source: "address[] public players"
    ArrayTypeName
       Source: "address[]"
      ElementaryTypeName address
         Source: "address"
  VariableDeclaration "approvedPlayers"
     Type: mapping(address => bool)
     Gas costs: 0
     Source: "mapping(address=>bool) approvedPlayers"
    Mapping
       Source: "mapping(address=>bool)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName bool
         Source: "bool"
  VariableDeclaration "secret"
     Type: uint256
     Gas costs: 287
     Source: "uint256 public secret"
    ElementaryTypeName uint256
       Source: "uint256"
  VariableDeclaration "seed"
     Type: uint256[] storage ref
     Gas costs: 645
     Source: "uint256[] public seed = [951828771,158769871220]"
    ArrayTypeName
       Source: "uint256[]"
      ElementaryTypeName uint256
         Source: "uint256"
    TupleExpression
       Type: uint40[2] memory
       Source: "[951828771,158769871220]"
      Literal, token: [no token] value: 951828771
         Type: int_const 951828771
         Source: "951828771"
      Literal, token: [no token] value: 158769871220
         Type: int_const 158769871220
         Source: "158769871220"
  VariableDeclaration "balance"
     Type: uint256[] storage ref
     Gas costs: 645
     Source: "uint256[] public balance"
    ArrayTypeName
       Source: "uint256[]"
      ElementaryTypeName uint256
         Source: "uint256"
  FunctionDefinition "DranMe" - public
     Source: "function DranMe() public payable{\r\n\towner = msg.sender;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\towner = msg.sender;\r\n}"
      ExpressionStatement
         Gas costs: 20266
         Source: "owner = msg.sender"
        Assignment using operator =
           Type: address
           Source: "owner = msg.sender"
          Identifier owner
             Type: address
             Source: "owner"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  ModifierDefinition "onlyOwner"
     Source: "modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == owner);\r\n    _;\r\n}"
      ExpressionStatement
         Gas costs: 564
         Source: "require(msg.sender == owner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == owner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyWinner"
     Source: "modifier onlyWinner() {\r\n    require(msg.sender == winner);\r\n    _;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(msg.sender == winner);\r\n    _;\r\n}"
      ExpressionStatement
         Gas costs: 282
         Source: "require(msg.sender == winner)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.sender == winner)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.sender == winner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier winner
               Type: address
               Source: "winner"
      PlaceholderStatement
         Gas costs: 0
         Source: "_"
  ModifierDefinition "onlyPlayers"
     Source: "modifier onlyPlayers() {\r\n    require(approvedPlayers[msg.sender]);\r\n    _;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    Block
       Source: "{\r\n    require(approvedPlayers[msg.sender]);\r\n    _;\r\n}"
      ExpressionStatement
         Gas costs: 2520
         Source: "require(approvedPlayers[msg.sender])"
        FunctionCall
           Type: tuple()
           Source: "require(approvedPlayers[msg.sender])"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          IndexAccess
             Type: bool
             Source: "approvedPlayers[msg.sender]"
            Identifier approvedPlayers
               Type: mapping(address => bool)
               Source: "approvedPlayers"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
      PlaceholderStatement
         Gas costs: 1
         Source: "_"
  FunctionDefinition "getLength" - public - const
     Source: "function getLength() public constant returns(uint256) {\r\n\treturn seed.length;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\treturn seed.length;\r\n}"
      Return
         Gas costs: 216
         Source: "return seed.length"
        MemberAccess to member length
           Type: uint256
           Source: "seed.length"
          Identifier seed
             Type: uint256[] storage ref
             Source: "seed"
  FunctionDefinition "setSecret" - public
     Source: "function setSecret(uint256 _secret) public payable onlyOwner{\r\n\tsecret = _secret;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _secret)"
      VariableDeclaration "_secret"
         Type: uint256
         Source: "uint256 _secret"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\tsecret = _secret;\r\n}"
      ExpressionStatement
         Gas costs: 20014
         Source: "secret = _secret"
        Assignment using operator =
           Type: uint256
           Source: "secret = _secret"
          Identifier secret
             Type: uint256
             Source: "secret"
          Identifier _secret
             Type: uint256
             Source: "_secret"
  FunctionDefinition "getPlayerCount" - public - const
     Source: "function getPlayerCount() public constant returns(uint256) {\r\n\treturn players.length;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\treturn players.length;\r\n}"
      Return
         Gas costs: 216
         Source: "return players.length"
        MemberAccess to member length
           Type: uint256
           Source: "players.length"
          Identifier players
             Type: address[] storage ref
             Source: "players"
  FunctionDefinition "getPrize" - public - const
     Source: "function getPrize() public constant returns(uint256) {\r\n\treturn address(this).balance;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    Block
       Source: "{\r\n\treturn address(this).balance;\r\n}"
      Return
         Gas costs: 413
         Source: "return address(this).balance"
        MemberAccess to member balance
           Type: uint256
           Source: "address(this).balance"
          FunctionCall
             Type: address
             Source: "address(this)"
            ElementaryTypeNameExpression address
               Type: type(address)
               Source: "address"
            Identifier this
               Type: contract DrainMe
               Source: "this"
  FunctionDefinition "becomePlayer" - public
     Source: "function becomePlayer() public payable{\r\n\trequire(msg.value >= 0.02 ether);\r\n\tplayers.push(msg.sender);\r\n\tapprovedPlayers[msg.sender]=true;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n\trequire(msg.value >= 0.02 ether);\r\n\tplayers.push(msg.sender);\r\n\tapprovedPlayers[msg.sender]=true;\r\n}"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value >= 0.02 ether)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= 0.02 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 0.02 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0.02
               Type: int_const 20000000000000000
               Source: "0.02 ether"
      ExpressionStatement
         Gas costs: 20364
         Source: "players.push(msg.sender)"
        FunctionCall
           Type: uint256
           Source: "players.push(msg.sender)"
          MemberAccess to member push
             Type: function (address) returns (uint256)
             Source: "players.push"
            Identifier players
               Type: address[] storage ref
               Source: "players"
          MemberAccess to member sender
             Type: address
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      ExpressionStatement
         Gas costs: 20359
         Source: "approvedPlayers[msg.sender]=true"
        Assignment using operator =
           Type: bool
           Source: "approvedPlayers[msg.sender]=true"
          IndexAccess
             Type: bool
             Source: "approvedPlayers[msg.sender]"
            Identifier approvedPlayers
               Type: mapping(address => bool)
               Source: "approvedPlayers"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Literal, token: true value: true
             Type: bool
             Source: "true"
  FunctionDefinition "manipulateSecret" - public
     Source: "function manipulateSecret() public payable onlyPlayers{\r\n\trequire (msg.value >= 0.01 ether);\r\n\tif(msg.sender!=owner || unlockSecret()){\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\trequire (msg.value >= 0.01 ether);\r\n\tif(msg.sender!=owner || unlockSecret()){\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}\r\n}"
      ExpressionStatement
         Gas costs: 37
         Source: "require (msg.value >= 0.01 ether)"
        FunctionCall
           Type: tuple()
           Source: "require (msg.value >= 0.01 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 0.01 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0.01
               Type: int_const 10000000000000000
               Source: "0.01 ether"
      IfStatement
         Source: "if(msg.sender!=owner || unlockSecret()){\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}"
        BinaryOperation using operator ||
           Type: bool
           Gas costs: 282
           Source: "msg.sender!=owner || unlockSecret()"
          BinaryOperation using operator !=
             Type: bool
             Source: "msg.sender!=owner"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Identifier owner
               Type: address
               Source: "owner"
          FunctionCall
             Type: bool
             Source: "unlockSecret()"
            Identifier unlockSecret
               Type: function () returns (bool)
               Source: "unlockSecret"
        Block
           Source: "{\r\n\t    uint256 amount = 0;\r\n        msg.sender.transfer(amount);\r\n\t}"
          VariableDeclarationStatement
             Gas costs: 11
             Source: "uint256 amount = 0"
            VariableDeclaration "amount"
               Type: uint256
               Source: "uint256 amount"
              ElementaryTypeName uint256
                 Source: "uint256"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(amount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(amount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
  FunctionDefinition "unlockSecret"
     Source: "function unlockSecret() private returns(bool){\r\n    bytes32 hash = keccak256(blockhash(block.number-1));\r\n    uint256 secret = uint256(hash);\r\n        if(secret%5==0){\r\n            winner = msg.sender;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\r\n    bytes32 hash = keccak256(blockhash(block.number-1));\r\n    uint256 secret = uint256(hash);\r\n        if(secret%5==0){\r\n            winner = msg.sender;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 154
         Source: "bytes32 hash = keccak256(blockhash(block.number-1))"
        VariableDeclaration "hash"
           Type: bytes32
           Source: "bytes32 hash"
          ElementaryTypeName bytes32
             Source: "bytes32"
        FunctionCall
           Type: bytes32
           Source: "keccak256(blockhash(block.number-1))"
          Identifier keccak256
             Type: function () pure returns (bytes32)
             Source: "keccak256"
          FunctionCall
             Type: bytes32
             Source: "blockhash(block.number-1)"
            Identifier blockhash
               Type: function (uint256) view returns (bytes32)
               Source: "blockhash"
            BinaryOperation using operator -
               Type: uint256
               Source: "block.number-1"
              MemberAccess to member number
                 Type: uint256
                 Source: "block.number"
                Identifier block
                   Type: block
                   Source: "block"
              Literal, token: [no token] value: 1
                 Type: int_const 1
                 Source: "1"
      VariableDeclarationStatement
         Gas costs: 22
         Source: "uint256 secret = uint256(hash)"
        VariableDeclaration "secret"
           Type: uint256
           Source: "uint256 secret"
          ElementaryTypeName uint256
             Source: "uint256"
        FunctionCall
           Type: uint256
           Source: "uint256(hash)"
          ElementaryTypeNameExpression uint256
             Type: type(uint256)
             Source: "uint256"
          Identifier hash
             Type: bytes32
             Source: "hash"
      IfStatement
         Source: "if(secret%5==0){\r\n            winner = msg.sender;\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 40
           Source: "secret%5==0"
          BinaryOperation using operator %
             Type: uint256
             Source: "secret%5"
            Identifier secret
               Type: uint256
               Source: "secret"
            Literal, token: [no token] value: 5
               Type: int_const 5
               Source: "5"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{\r\n            winner = msg.sender;\r\n            return true;\r\n        }"
          ExpressionStatement
             Gas costs: 20266
             Source: "winner = msg.sender"
            Assignment using operator =
               Type: address
               Source: "winner = msg.sender"
              Identifier winner
                 Type: address
                 Source: "winner"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
        Block
           Source: "{\r\n            return false;\r\n        }"
          Return
             Gas costs: 8
             Source: "return false"
            Literal, token: false value: false
               Type: bool
               Source: "false"
  FunctionDefinition "callFirstTarget" - public
     Source: "function callFirstTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tfirstTarget.call.value(msg.value)();\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tfirstTarget.call.value(msg.value)();\r\n}"
      ExpressionStatement
         Gas costs: 37
         Source: "require (msg.value >= 0.005 ether)"
        FunctionCall
           Type: tuple()
           Source: "require (msg.value >= 0.005 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 0.005 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0.005
               Type: int_const 5000000000000000
               Source: "0.005 ether"
      ExpressionStatement
         Gas costs: [???]
         Source: "firstTarget.call.value(msg.value)()"
        FunctionCall
           Type: bool
           Source: "firstTarget.call.value(msg.value)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "firstTarget.call.value(msg.value)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "firstTarget.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "firstTarget.call"
                Identifier firstTarget
                   Type: address
                   Source: "firstTarget"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "callSecondTarget" - public
     Source: "function callSecondTarget () public payable onlyPlayers {\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tsecondTarget.call.value(msg.value)();\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\trequire (msg.value >= 0.005 ether);\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\tsecondTarget.call.value(msg.value)();\r\n}"
      ExpressionStatement
         Gas costs: 37
         Source: "require (msg.value >= 0.005 ether)"
        FunctionCall
           Type: tuple()
           Source: "require (msg.value >= 0.005 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 0.005 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0.005
               Type: int_const 5000000000000000
               Source: "0.005 ether"
      ExpressionStatement
         Gas costs: [???]
         Source: "secondTarget.call.value(msg.value)()"
        FunctionCall
           Type: bool
           Source: "secondTarget.call.value(msg.value)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "secondTarget.call.value(msg.value)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "secondTarget.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "secondTarget.call"
                Identifier secondTarget
                   Type: address
                   Source: "secondTarget"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
  FunctionDefinition "setSeed" - public
     Source: "function setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\r\n\tseed[_index] = _value;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _index, uint256 _value)"
      VariableDeclaration "_index"
         Type: uint256
         Source: "uint256 _index"
        ElementaryTypeName uint256
           Source: "uint256"
      VariableDeclaration "_value"
         Type: uint256
         Source: "uint256 _value"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\tseed[_index] = _value;\r\n}"
      ExpressionStatement
         Gas costs: 20303
         Source: "seed[_index] = _value"
        Assignment using operator =
           Type: uint256
           Source: "seed[_index] = _value"
          IndexAccess
             Type: uint256
             Source: "seed[_index]"
            Identifier seed
               Type: uint256[] storage ref
               Source: "seed"
            Identifier _index
               Type: uint256
               Source: "_index"
          Identifier _value
             Type: uint256
             Source: "_value"
  FunctionDefinition "addSeed" - public
     Source: "function addSeed (uint256 _add) public payable onlyPlayers {\r\n\tseed.length = _add;\r\n}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _add)"
      VariableDeclaration "_add"
         Type: uint256
         Source: "uint256 _add"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\tseed.length = _add;\r\n}"
      ExpressionStatement
         Gas costs: 21
         Source: "seed.length = _add"
        Assignment using operator =
           Type: uint256
           Source: "seed.length = _add"
          MemberAccess to member length
             Type: uint256
             Source: "seed.length"
            Identifier seed
               Type: uint256[] storage ref
               Source: "seed"
          Identifier _add
             Type: uint256
             Source: "_add"
  FunctionDefinition "guessSeed" - public
     Source: "function guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\r\n\treturn (_seed / (seed[0]*seed[1]));\r\n\tif((_seed / (seed[0]*seed[1])) == secret) {\r\n\t\towner = winner;\r\n\t}\r\n}"
    ParameterList
       Gas costs: 0
       Source: "(uint256 _seed)"
      VariableDeclaration "_seed"
         Type: uint256
         Source: "uint256 _seed"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 3
       Source: "(uint256)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint256"
        ElementaryTypeName uint256
           Source: "uint256"
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n\treturn (_seed / (seed[0]*seed[1]));\r\n\tif((_seed / (seed[0]*seed[1])) == secret) {\r\n\t\towner = winner;\r\n\t}\r\n}"
      Return
         Gas costs: 1025
         Source: "return (_seed / (seed[0]*seed[1]))"
        TupleExpression
           Type: uint256
           Source: "(_seed / (seed[0]*seed[1]))"
          BinaryOperation using operator /
             Type: uint256
             Source: "_seed / (seed[0]*seed[1])"
            Identifier _seed
               Type: uint256
               Source: "_seed"
            TupleExpression
               Type: uint256
               Source: "(seed[0]*seed[1])"
              BinaryOperation using operator *
                 Type: uint256
                 Source: "seed[0]*seed[1]"
                IndexAccess
                   Type: uint256
                   Source: "seed[0]"
                  Identifier seed
                     Type: uint256[] storage ref
                     Source: "seed"
                  Literal, token: [no token] value: 0
                     Type: int_const 0
                     Source: "0"
                IndexAccess
                   Type: uint256
                   Source: "seed[1]"
                  Identifier seed
                     Type: uint256[] storage ref
                     Source: "seed"
                  Literal, token: [no token] value: 1
                     Type: int_const 1
                     Source: "1"
      IfStatement
         Source: "if((_seed / (seed[0]*seed[1])) == secret) {\r\n\t\towner = winner;\r\n\t}"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 0
           Source: "(_seed / (seed[0]*seed[1])) == secret"
          TupleExpression
             Type: uint256
             Source: "(_seed / (seed[0]*seed[1]))"
            BinaryOperation using operator /
               Type: uint256
               Source: "_seed / (seed[0]*seed[1])"
              Identifier _seed
                 Type: uint256
                 Source: "_seed"
              TupleExpression
                 Type: uint256
                 Source: "(seed[0]*seed[1])"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "seed[0]*seed[1]"
                  IndexAccess
                     Type: uint256
                     Source: "seed[0]"
                    Identifier seed
                       Type: uint256[] storage ref
                       Source: "seed"
                    Literal, token: [no token] value: 0
                       Type: int_const 0
                       Source: "0"
                  IndexAccess
                     Type: uint256
                     Source: "seed[1]"
                    Identifier seed
                       Type: uint256[] storage ref
                       Source: "seed"
                    Literal, token: [no token] value: 1
                       Type: int_const 1
                       Source: "1"
          Identifier secret
             Type: uint256
             Source: "secret"
        Block
           Source: "{\r\n\t\towner = winner;\r\n\t}"
          ExpressionStatement
             Gas costs: 0
             Source: "owner = winner"
            Assignment using operator =
               Type: address
               Source: "owner = winner"
              Identifier owner
                 Type: address
                 Source: "owner"
              Identifier winner
                 Type: address
                 Source: "winner"
  FunctionDefinition "checkSecret" - public
     Source: "function checkSecret () public payable onlyPlayers returns(bool) {\r\n    require(msg.value >= 0.01 ether);\r\n    if(msg.value == secret){\r\n        return true;\r\n    }\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    ModifierInvocation "onlyPlayers"
       Gas costs: 0
       Source: "onlyPlayers"
      Identifier onlyPlayers
         Type: modifier ()
         Source: "onlyPlayers"
    Block
       Source: "{\r\n    require(msg.value >= 0.01 ether);\r\n    if(msg.value == secret){\r\n        return true;\r\n    }\r\n}"
      ExpressionStatement
         Gas costs: 37
         Source: "require(msg.value >= 0.01 ether)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value >= 0.01 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "msg.value >= 0.01 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 0.01
               Type: int_const 10000000000000000
               Source: "0.01 ether"
      IfStatement
         Source: "if(msg.value == secret){\r\n        return true;\r\n    }"
        BinaryOperation using operator ==
           Type: bool
           Gas costs: 208
           Source: "msg.value == secret"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Identifier secret
             Type: uint256
             Source: "secret"
        Block
           Source: "{\r\n        return true;\r\n    }"
          Return
             Gas costs: 19
             Source: "return true"
            Literal, token: true value: true
               Type: bool
               Source: "true"
  FunctionDefinition "winPrize" - public
     Source: "function winPrize() public payable onlyOwner {\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\towner.call.value(1 wei)();\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyOwner"
       Gas costs: 0
       Source: "onlyOwner"
      Identifier onlyOwner
         Type: modifier ()
         Source: "onlyOwner"
    Block
       Source: "{\r\n\t// <yes> <report> UNCHECKED_LL_CALLS\r\n\towner.call.value(1 wei)();\r\n}"
      ExpressionStatement
         Gas costs: [???]
         Source: "owner.call.value(1 wei)()"
        FunctionCall
           Type: bool
           Source: "owner.call.value(1 wei)()"
          FunctionCall
             Type: function () payable returns (bool)
             Source: "owner.call.value(1 wei)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable returns (bool))
               Source: "owner.call.value"
              MemberAccess to member call
                 Type: function () payable returns (bool)
                 Source: "owner.call"
                Identifier owner
                   Type: address
                   Source: "owner"
            Literal, token: [no token] value: 1
               Type: int_const 1
               Source: "1 wei"
  FunctionDefinition "claimPrize" - public
     Source: "function claimPrize() public payable onlyWinner {\r\n\twinner.transfer(address(this).balance);\r\n}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    ModifierInvocation "onlyWinner"
       Gas costs: 0
       Source: "onlyWinner"
      Identifier onlyWinner
         Type: modifier ()
         Source: "onlyWinner"
    Block
       Source: "{\r\n\twinner.transfer(address(this).balance);\r\n}"
      ExpressionStatement
         Gas costs: [???]
         Source: "winner.transfer(address(this).balance)"
        FunctionCall
           Type: tuple()
           Source: "winner.transfer(address(this).balance)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "winner.transfer"
            Identifier winner
               Type: address
               Source: "winner"
          MemberAccess to member balance
             Type: uint256
             Source: "address(this).balance"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract DrainMe
                 Source: "this"
  FunctionDefinition "" - public
     Source: "function() public payable{\r\n\t}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{\r\n\t}"
