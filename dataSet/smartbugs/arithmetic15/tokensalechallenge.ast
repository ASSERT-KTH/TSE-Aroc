Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/smartbugs-21-7-13/arithmetic15/tokensalechallenge.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.4.21;"
ContractDefinition "TokenSaleChallenge"
   Source: "contract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        // <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        // <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        // <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}"
  VariableDeclaration "balanceOf"
     Type: mapping(address => uint256)
     Gas costs: 431
     Source: "mapping(address => uint256) public balanceOf"
    Mapping
       Source: "mapping(address => uint256)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint256
         Source: "uint256"
  VariableDeclaration "PRICE_PER_TOKEN"
     Type: uint256
     Gas costs: 6
     Source: "uint256 constant PRICE_PER_TOKEN = 1 ether"
    ElementaryTypeName uint256
       Source: "uint256"
    Literal, token: [no token] value: 1
       Type: int_const 1000000000000000000
       Source: "1 ether"
  FunctionDefinition "TokenSaleChallenge" - public
     Source: "function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address _player)"
      VariableDeclaration "_player"
         Type: address
         Source: "address _player"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        require(msg.value == 1 ether);\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "require(msg.value == 1 ether)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value == 1 ether)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.value == 1 ether"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            Literal, token: [no token] value: 1
               Type: int_const 1000000000000000000
               Source: "1 ether"
  FunctionDefinition "isComplete" - public - const
     Source: "function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(bool)"
      VariableDeclaration ""
         Type: bool
         Source: "bool"
        ElementaryTypeName bool
           Source: "bool"
    Block
       Source: "{\n        return address(this).balance < 1 ether;\n    }"
      Return
         Gas costs: 419
         Source: "return address(this).balance < 1 ether"
        BinaryOperation using operator <
           Type: bool
           Source: "address(this).balance < 1 ether"
          MemberAccess to member balance
             Type: uint256
             Source: "address(this).balance"
            FunctionCall
               Type: address
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract TokenSaleChallenge
                 Source: "this"
          Literal, token: [no token] value: 1
             Type: int_const 1000000000000000000
             Source: "1 ether"
  FunctionDefinition "buy" - public
     Source: "function buy(uint256 numTokens) public payable {\n        // <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        // <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 numTokens)"
      VariableDeclaration "numTokens"
         Type: uint256
         Source: "uint256 numTokens"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        // <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        // <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }"
      ExpressionStatement
         Gas costs: 39
         Source: "require(msg.value == numTokens * PRICE_PER_TOKEN)"
        FunctionCall
           Type: tuple()
           Source: "require(msg.value == numTokens * PRICE_PER_TOKEN)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator ==
             Type: bool
             Source: "msg.value == numTokens * PRICE_PER_TOKEN"
            MemberAccess to member value
               Type: uint256
               Source: "msg.value"
              Identifier msg
                 Type: msg
                 Source: "msg"
            BinaryOperation using operator *
               Type: uint256
               Source: "numTokens * PRICE_PER_TOKEN"
              Identifier numTokens
                 Type: uint256
                 Source: "numTokens"
              Identifier PRICE_PER_TOKEN
                 Type: uint256
                 Source: "PRICE_PER_TOKEN"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] += numTokens"
        Assignment using operator +=
           Type: uint256
           Source: "balanceOf[msg.sender] += numTokens"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier numTokens
             Type: uint256
             Source: "numTokens"
  FunctionDefinition "sell" - public
     Source: "function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        // <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint256 numTokens)"
      VariableDeclaration "numTokens"
         Type: uint256
         Source: "uint256 numTokens"
        ElementaryTypeName uint256
           Source: "uint256"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        // <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }"
      ExpressionStatement
         Gas costs: 333
         Source: "require(balanceOf[msg.sender] >= numTokens)"
        FunctionCall
           Type: tuple()
           Source: "require(balanceOf[msg.sender] >= numTokens)"
          Identifier require
             Type: function (bool) pure
             Source: "require"
          BinaryOperation using operator >=
             Type: bool
             Source: "balanceOf[msg.sender] >= numTokens"
            IndexAccess
               Type: uint256
               Source: "balanceOf[msg.sender]"
              Identifier balanceOf
                 Type: mapping(address => uint256)
                 Source: "balanceOf"
              MemberAccess to member sender
                 Type: address
                 Source: "msg.sender"
                Identifier msg
                   Type: msg
                   Source: "msg"
            Identifier numTokens
               Type: uint256
               Source: "numTokens"
      ExpressionStatement
         Gas costs: 20328
         Source: "balanceOf[msg.sender] -= numTokens"
        Assignment using operator -=
           Type: uint256
           Source: "balanceOf[msg.sender] -= numTokens"
          IndexAccess
             Type: uint256
             Source: "balanceOf[msg.sender]"
            Identifier balanceOf
               Type: mapping(address => uint256)
               Source: "balanceOf"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier numTokens
             Type: uint256
             Source: "numTokens"
      ExpressionStatement
         Gas costs: [???]
         Source: "msg.sender.transfer(numTokens * PRICE_PER_TOKEN)"
        FunctionCall
           Type: tuple()
           Source: "msg.sender.transfer(numTokens * PRICE_PER_TOKEN)"
          MemberAccess to member transfer
             Type: function (uint256)
             Source: "msg.sender.transfer"
            MemberAccess to member sender
               Type: address
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          BinaryOperation using operator *
             Type: uint256
             Source: "numTokens * PRICE_PER_TOKEN"
            Identifier numTokens
               Type: uint256
               Source: "numTokens"
            Identifier PRICE_PER_TOKEN
               Type: uint256
               Source: "PRICE_PER_TOKEN"
